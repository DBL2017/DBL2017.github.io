<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>生如夏花</title><link>https://DBL2017.github.io/</link><description>Recent content on 生如夏花</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 17 Dec 2024 22:44:11 +0800</lastBuildDate><atom:link href="https://DBL2017.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>tmux使用方法</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/tmux%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Tue, 17 Dec 2024 22:44:11 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/tmux%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>本文目前主要记录了一些tmux使用的快捷键。</description><tags>Tmux Session</tags><summary>&lt;p>tmux是一种终端多路复用器：它可以在一个屏幕上创建、访问和控制多个终端。&lt;/p>
&lt;p>启动tmux时，它会创建一个带有单一窗口的新会话并显示在屏幕上。 屏幕底部的状态行显示当前会话的信息，并用于输入交互式命令。&lt;/p>
&lt;p>本文目前主要记录了一些tmux使用的快捷键。&lt;/p>
&lt;p>持续更新中🛵🛵🛵&lt;/p></summary></item><item><title>iptables自定义链</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/</link><pubDate>Tue, 17 Dec 2024 22:39:42 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/</guid><description>iptables中包含默认链、规则，同时也可以创建自定义链，用来对规则进行分类。本文介绍了如何创建、删除自定义链、规则等。</description><tags>Iptables 防火墙</tags><summary>&lt;p>使用自定义链可以对规则进行分类，将特定的类放在一个链中，比如将HTTP服务的放在一个链中，SSH服务的放在另一个链中&lt;/p>
&lt;p>自定义链默认是不可使用的，只有被默认链引用才会生效&lt;/p></summary></item><item><title>Ubuntu24.04 apt upgrade提示esm-apps</title><link>https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ubuntu24.04-apt-upgrade%E6%8F%90%E7%A4%BAesm-apps/</link><pubDate>Tue, 17 Dec 2024 22:32:01 +0800</pubDate><guid>https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ubuntu24.04-apt-upgrade%E6%8F%90%E7%A4%BAesm-apps/</guid><description/><tags>Ubuntu24 Ubuntu Esm-Apps</tags><summary>&lt;p>记录一下Ubuntu24.04上进行&lt;code>apt upgrade&lt;/code>时提示信息包含&lt;code>esm-apps&lt;/code>的问题，然后通过移除&lt;code>20apt-esm-hook.conf&lt;/code>去掉该提示信息。&lt;/p></summary></item><item><title>Ubuntu24.04搭建PPPoE Server并进行拨号测试</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/ubuntu24.04%E6%90%AD%E5%BB%BApppoe-server%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%8B%A8%E5%8F%B7%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 07 Dec 2024 15:09:26 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/ubuntu24.04%E6%90%AD%E5%BB%BApppoe-server%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%8B%A8%E5%8F%B7%E6%B5%8B%E8%AF%95/</guid><description>VMWare NAT模式启用了虚拟NAT设备、虚拟DHCP服务器以及VMnet虚拟交换机，启用虚拟机的ens33网卡和宿主机VMware Network Adapter VMnet8均连接在VMnet8虚拟交换机上，两者之间通过VMnet8虚拟交换进行通信，而虚拟机通过虚拟NAT设备访问外部网络。本文在Ubuntu24.04虚拟机上搭建了PPPoE Server，Windows10虚拟机通过仅主机模式的网卡与Ubuntu24.04建立连接，然后通过拨号进行上网。</description><tags>拨号 PPPoE</tags><summary>&lt;p>本文主要记录如何搭建PPPoE Server，并进行拨号连接，并不包含PPPoE协议的细节。&lt;/p>
&lt;p>本文在VMWare虚拟机Ubuntu24.04上搭建PPPoE Server，然后Windows10虚拟机通过PPPoE拨号获取IP，并进行上网。&lt;/p></summary></item><item><title>OpenWrt下载编译以及在VMWare上运行</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/openwrt%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E5%9C%A8vmware%E4%B8%8A%E8%BF%90%E8%A1%8C/</link><pubDate>Thu, 21 Nov 2024 23:11:53 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/openwrt%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E5%9C%A8vmware%E4%B8%8A%E8%BF%90%E8%A1%8C/</guid><description>本文描述了OpenWrt源码下载、编译过程以及产物，并在VMWare上运行配置IP，并远程连接到OpenWrt系统中。</description><tags>OpenWrt</tags><summary>&lt;p>本文记录以下OpenWrt的入门知识，包括源码编译，&lt;code>make menuconfig&lt;/code>配置，&lt;code>feeds&lt;/code>包下载以及生成可以运行在VMWare上的镜像。&lt;/p>
&lt;p>然后在VMWare上运行，并配置静态IP，然后可以使用SSH工具远程连接到OpenWrt系统中。&lt;/p></summary></item><item><title>Ubuntu24.04环境编译glibc-2.40错误记录</title><link>https://DBL2017.github.io/post/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/ubuntu24.04%E7%8E%AF%E5%A2%83%E7%BC%96%E8%AF%91glibc-2.40%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 26 Oct 2024 12:47:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/ubuntu24.04%E7%8E%AF%E5%A2%83%E7%BC%96%E8%AF%91glibc-2.40%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/</guid><description>Ubuntu24.04-x86_64 gcc-13.2.0 glibc-2.40编译错误记录，</description><tags>GCC GLibc</tags><summary>&lt;p>本文记录了在&lt;code>Ubuntu24.04-x86_64 gcc-13.2.0&lt;/code>环境下编译&lt;code>glibc-2.40&lt;/code>出现的一系列错误以及解决方法。&lt;/p></summary></item><item><title>UNIX域套接字</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</link><pubDate>Sun, 18 Aug 2024 11:15:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</guid><description>UNIX域套接字主要用于进程间通信IPC，创建UNIX域套接字的方法有两种，分别是socket函数和socketpair函数。UNIX域套接字分为匿名和命名套接字，匿名套接字仅用于具有亲缘关系的进程之间，命名套接字需要和其特定地址绑定，绑定后会系统会创建一个文件，其他进程通过该文件建立连接。</description><tags>域套接字 进程间通信 IPC Sockpair Socket</tags><summary>&lt;p>UNIX域套接字是单个主机上&lt;strong>客户端与服务器通信&lt;/strong>的一种方式。允许同一台计算机上&lt;strong>不同进程&lt;/strong>之间通过文件系统中的特殊文件（&lt;strong>套接字文件&lt;/strong>）进行数据交换。&lt;/p>
&lt;p>可以在同一台计算机上运行的两个进程之间传递打开的文件描述符。&lt;/p>
&lt;p>与TCP套接字相比较，UNIX域套接字不涉及网络协议栈，因此传递速度更快，效率更高。&lt;/p></summary></item><item><title>Job systemd-networkd-wait-online.service start running</title><link>https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/job-systemd-networkd-wait-online.service-start-running/</link><pubDate>Sun, 18 Aug 2024 10:22:58 +0800</pubDate><guid>https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/job-systemd-networkd-wait-online.service-start-running/</guid><description>解决systemd-networkd-wait-online.service导致Ubuntu24.04启动时间过长（超过2min）的问题，问题原因在于systemd-networkd-wait-online.service会在启动时默认检测网络设备，然而此时的网络设备还未连接。</description><tags>Ubuntu Ubuntu24 Systemd-Networkd-Wait-Online 启动超时 Netplan</tags><summary>&lt;p>本文记录Ubuntu24.04在启动时网络设备未连接，因此由于&lt;code>systemd-networkd-wait-online.service&lt;/code>导致启动时间过长的问题，并最终在&lt;code>/etc/netplan/50-cloud-init.yaml&lt;/code>配置文件中增加参数得以解决的过程。&lt;/p></summary></item><item><title>fdisk创建磁盘分区并格式化</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/fdisk%E5%88%9B%E5%BB%BA%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96/</link><pubDate>Sat, 17 Aug 2024 11:19:28 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/fdisk%E5%88%9B%E5%BB%BA%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid><description>使用fdisk、parted、e2fsck、resize2fs、mkfs等工具在命令行创建或修改磁盘分区。</description><tags>Linux Fdisk 磁盘分区</tags><summary>&lt;p>本文主要记录一下在Linux命令行环境中如何对新磁盘进行分区并格式化，以及对已有分区如何进行扩容。&lt;/p>
&lt;p>使用的分区工具是&lt;code>fdisk&lt;/code>，格式化工具为&lt;code>mkfs&lt;/code>，验证的环境为&lt;code>Ubuntu24.04&lt;/code>虚拟机。&lt;/p>
&lt;p>使用&lt;code>parted&lt;/code>工具扩容已有分区，&lt;code>e2fsck&lt;/code>检查文件系统是否被破坏，&lt;code>resize2fs&lt;/code>扩容文件系统以适应分区大小。&lt;/p></summary></item><item><title>VMware虚拟机Ubuntu24.04桥接到宿主机无线网卡上网</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vmware%E8%99%9A%E6%8B%9F%E6%9C%BAubuntu24.04%E6%A1%A5%E6%8E%A5%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E4%B8%8A%E7%BD%91/</link><pubDate>Wed, 14 Aug 2024 00:05:07 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vmware%E8%99%9A%E6%8B%9F%E6%9C%BAubuntu24.04%E6%A1%A5%E6%8E%A5%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E4%B8%8A%E7%BD%91/</guid><description>Ubuntu24.04虚拟机上使用桥接模式，桥接虚拟机网卡到Win11无线网卡上，然后通过WiFi进行上网。</description><tags>网络路由 桥接 Ubuntu VMware</tags><summary>&lt;p>VMware为虚拟机提供三种上网方式，分别是桥接模式、仅主机以及NAT模式，同时会在宿主机上创建两个虚拟网卡，分别是VMnet1：仅主机模式和VMnet8：NAT模式。&lt;/p>
&lt;p>为什么桥接模式没有在宿主机上创建虚拟网卡呢？这是因为桥接模式是&lt;strong>通过虚拟网桥将虚拟机的网卡和宿主机的网卡桥接在一起&lt;/strong>的（类似于宿主机物理网卡和虚拟机网卡通过虚拟交换机连接在一起）。&lt;/p></summary></item><item><title>I/O多路转接之poll函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bpoll%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 04 Aug 2024 10:26:27 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bpoll%E5%87%BD%E6%95%B0/</guid><description>poll函数是另一种支持I/O多路复用的技术。其和select的区别在于selec是基于事件类型来划分文件描述符，而poll则是针对每个文件描述来指定关注的事件。同时poll函数支持更多的事件类型，以及文件描述符数量仅受系统性能限制。因此poll可以看作是select的一大进步。</description><tags>文件IO I/O 多路转接 Poll</tags><summary>&lt;p>如上节所述，&lt;code>poll&lt;/code>函数是另一个支持I/O多路转接的函数。&lt;/p>
&lt;p>与&lt;code>select&lt;/code>不同的是&lt;code>poll&lt;/code>函数支持更多的条件，而非&lt;code>select&lt;/code>函数仅有的三种条件（可读、可写以及异常）。&lt;/p>
&lt;p>同时&lt;code>poll&lt;/code>函数是以&lt;code>struct pollfd&lt;/code>数组类型保存文件描述符（没有文件描述符的数量限制），并为每个文件描述符指定关注的哪些条件，而&lt;code>select&lt;/code>函数则是另一种角度，为每个条件设置哪些文件描述符。&lt;/p></summary></item><item><title>Win11上nvim配置文件目录路径设置</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/win11%E4%B8%8Anvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/</link><pubDate>Thu, 06 Jun 2024 16:06:32 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/win11%E4%B8%8Anvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/</guid><description>windows下配置neovim，包括默认配置路径init.lua或init.vim，以及插件安装位置等。</description><tags>NVIM</tags><summary>&lt;p>Windows下neovim的相关配置。&lt;/p>
&lt;p>默认情况下nvim的配置文件位置在&lt;code>~/AppData/Local/nvim/init.lua&lt;/code>，如果设置了&lt;code>XDG_CONFIG_HOME&lt;/code>，则配置文件位置在&lt;code>$XDG_CONFIG_HOME/nvim/init.lua&lt;/code>。&lt;/p></summary></item><item><title>vim删除空行、行首、行尾的空格</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/nvim%E5%88%A0%E9%99%A4%E7%A9%BA%E8%A1%8C%E8%A1%8C%E9%A6%96%E8%A1%8C%E5%B0%BE%E7%9A%84%E7%A9%BA%E6%A0%BC/</link><pubDate>Mon, 03 Jun 2024 13:10:26 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/nvim%E5%88%A0%E9%99%A4%E7%A9%BA%E8%A1%8C%E8%A1%8C%E9%A6%96%E8%A1%8C%E5%B0%BE%E7%9A%84%E7%A9%BA%E6%A0%BC/</guid><description>vim、nvim删除空行、删除行首空格、删除行尾空格。</description><tags>NVIM</tags><summary>&lt;p>记录一下vim操作空白字符的相关方式，现在包括删除空行、删除行首空格以及删除行尾空格。&lt;/p></summary></item><item><title>PKCS之数据块填充算法</title><link>https://DBL2017.github.io/post/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/pkcs%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%9D%97%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/</link><pubDate>Fri, 31 May 2024 15:50:20 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/pkcs%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%9D%97%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/</guid><description>本文主要介绍与实现AES加密算法中的数据填充规则PKCS#5和PKCS#7</description><tags>AES 填充规则 PKCS</tags><summary>&lt;p>PKCS（Public Key Cryptography Standards）公钥加密标准包含了一系列公钥密码学标准，其中包含了数据填充的相关规范。&lt;/p>
&lt;p>当涉及到块加密算法（例如AES）时，PKCS#7（扩展了PKCS#5）是一种常用的填充方式。&lt;/p>
&lt;p>当数据长度不是加密算法所要求块大小（AES块大小为16字节）的整数倍时，就需要使用填充算法来确保数据能够被正确地加密和解密。&lt;/p></summary></item><item><title>neovim设置swapfile保存路径</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/neovim/neovim%E8%AE%BE%E7%BD%AEswapfile%E4%BF%9D%E5%AD%98%E8%B7%AF%E5%BE%84/</link><pubDate>Wed, 29 May 2024 14:53:56 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/neovim/neovim%E8%AE%BE%E7%BD%AEswapfile%E4%BF%9D%E5%AD%98%E8%B7%AF%E5%BE%84/</guid><description>neovim设置缓存文件路径，nvim设置swapfile设置路径</description><tags>NVIM Swapfile</tags><summary>&lt;p>本文记录了如何在neovim中配置自定义的swapfile路径。&lt;/p>
&lt;p>Lua配置：&lt;code> vim.go.directory = vim.fn.expand('~/.nvim/swapfiles//') .. ',!,'&lt;/code>&lt;/p></summary></item><item><title>I/O多路转接之select函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bselect%E5%87%BD%E6%95%B0/</link><pubDate>Wed, 15 May 2024 21:59:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bselect%E5%87%BD%E6%95%B0/</guid><description>I/O多路转接主要用于一个进程中同时操作多个文件进行I/O，Linux提供了三个函数分别是select、poll以及epoll。本文主要探索了select函数的用法，以及返回值。比较有意思的一点是，select函数会修改传入的参数的值，不止时传入的超时参数timeout，还包括传入的文件描述符集。而修改之后的文件描述符集和函数返回值两者一起被用来判断是否有文件描述符准备好。</description><tags>I/O</tags><summary>&lt;p>当一个进程需要从多个文件描述中读，并写入多个文件描述符中（例如TCP服务器）。&lt;/p>
&lt;ol>
&lt;li>如果采用阻塞I/O，那么前面的描述符中没有数据时就会阻塞，这样即使后面的描述符有数据也无法读取，写描述符同理。&lt;/li>
&lt;li>如果采用非阻I/O，那么就需要不断轮询所有描述符（浪费CPU时间）。&lt;/li>
&lt;/ol>
&lt;p>当一个进程需要对一个文件描述符同时进行读写，两者并没有前后关系。如果采用阻塞I/O，那么没有数据读就会阻塞，进而导致进程无法处理写入，写阻塞时同理。&lt;/p>
&lt;p>上述问题的一个解决方法是采用多线程，每个线程中对一个描述符进行阻塞I/O，缺点是线程实现复杂，同时进程支持的线程数量有限。&lt;/p></summary></item><item><title>modbus-tcp读取示例</title><link>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/modbus/modbus-tcp%E8%AF%BB%E5%8F%96%E7%A4%BA%E4%BE%8B/</link><pubDate>Sun, 12 May 2024 21:23:52 +0800</pubDate><guid>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/modbus/modbus-tcp%E8%AF%BB%E5%8F%96%E7%A4%BA%E4%BE%8B/</guid><description>modbus modbus-tcp，线圈，寄存器，输入寄存器，输出寄存器，功能码</description><tags>传输协议 Modbus Modbus-Tcp</tags><summary>&lt;p>本节主要记录一下学习modbus的编程实践，给出了一个读取modbus数据的示例。&lt;/p>
&lt;p>数据提供源是Win上的Modbus Slave软件。&lt;/p>
&lt;p>依赖库是&lt;code>libmodbus&lt;/code>。&lt;/p></summary></item><item><title>struct数据对齐</title><link>https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/struct%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/</link><pubDate>Sat, 11 May 2024 12:49:49 +0800</pubDate><guid>https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/struct%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/</guid><description>结构体对齐，__attribute__((packed))，struct</description><tags>C语言</tags><summary>&lt;p>C语言结构体不同字段之间按照系统位数进行数据对齐，32位系统4字节对齐，64位系统8字节对齐。&lt;/p>
&lt;p>GCC编译器默认会进行数据对齐，但也提供了专用属性&lt;code>__attribute__((packed))&lt;/code>使结构体采用紧凑模式，不对数据进行对齐，此时&lt;code>sizeof&lt;/code>获得的大小为结构体各字段的大小。&lt;/p></summary></item><item><title>Linux内核编译</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</link><pubDate>Tue, 07 May 2024 16:17:30 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</guid><description>Linux内核6.8.9，Linux内核编译，Linux内核编译相关问题解决，基于Ubuntu23.04编译最新版Linux内核（6.8.9）.</description><tags>Linux内核 内核编译</tags><summary>&lt;p>基于Ubuntu23.04编译最新版Linux内核（6.8.9），并解决编译过程中的相关问题。&lt;/p>
&lt;p>根据出现的问题，需要安装一下软件：&lt;code>sudo apt install flex bc libelf-dev&lt;/code>，并禁用系统相关证书：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-txt" data-lang="txt">&lt;span class="line">&lt;span class="cl">scripts/config --disable SYSTEM_TRUSTED_KEYS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">scripts/config --disable SYSTEM_REVOCATION_KEYS
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></summary></item><item><title>文件锁之flock</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E9%94%81%E4%B9%8Bflock/</link><pubDate>Thu, 18 Apr 2024 23:35:29 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E9%94%81%E4%B9%8Bflock/</guid><description>flock锁对dup、open、fork等情况的处理，flock锁的继承与实现，flock锁内核实现解析，所有文件描述符关闭时会自动解除flock锁</description><tags>APUE 文件锁 记录锁 建议性锁 强制性锁 Flock</tags><summary>&lt;p>文件锁的作用：当第一个进程正在读或修改文件的某个部分时，使用文件锁可以阻止其他进程修改文件的相同部分。&lt;/p>
&lt;p>因此文件锁可用于多个进程之间进行同步，防止进程间的竞争状态。&lt;/p>
&lt;p>Linux系统支持两组给文件加锁的不同API，分别是&lt;code>fcntl&lt;/code>与&lt;code>flock&lt;/code>。本节主要记录&lt;code>flock&lt;/code>的实现原理以及使用方式。&lt;/p></summary></item><item><title>文件锁之fcntl</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E9%94%81%E4%B9%8Bfcntl/</link><pubDate>Thu, 18 Apr 2024 20:07:19 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E9%94%81%E4%B9%8Bfcntl/</guid><description>文件锁、fcntl、读写锁、F_SETLK、F_GETLK、F_SETLKW、F_RDLCK、F_WRLCK、F_UNLCK、死锁、TELL_WAIT、锁的继承与释放</description><tags>APUE 建议性锁 强制性锁 文件锁 记录锁 Fcntl</tags><summary>&lt;p>文件锁的作用：当第一个进程正在读或修改文件的某个部分时，使用文件锁可以阻止其他进程修改文件的相同部分。&lt;/p>
&lt;p>因此文件锁可用于多个进程之间进行同步，防止进程间的竞争状态。&lt;/p>
&lt;p>Linux系统支持两组给文件加锁的不同API，分别是&lt;code>fcntl&lt;/code>与&lt;code>flock&lt;/code>。本节主要记录&lt;code>fcntl&lt;/code>的实现原理以及使用方式。&lt;/p>
&lt;p>&lt;strong>任意多个进程在同一个给定字节上都可以有一把共享读锁，但一个给定字节上仅能有一个进程持有一把独占写锁&lt;/strong>。&lt;/p></summary></item><item><title>非阻塞IO</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E9%9D%9E%E9%98%BB%E5%A1%9Eio/</link><pubDate>Wed, 17 Apr 2024 18:39:49 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E9%9D%9E%E9%98%BB%E5%A1%9Eio/</guid><description>系统调用、低速系统调用、非阻塞IO、O_NONBLOCK、fcntl</description><tags>APUE 非阻塞I/O 低速系统调用 O_NONBLOCK Fcntl</tags><summary>&lt;p>系统调用分为两类，“低速”系统调用和其他。&lt;/p>
&lt;p>“低速”系统调用指的是&lt;strong>可能会使进程永远阻塞&lt;/strong>的一类系统调用。&lt;/p>
&lt;p>非阻塞I/O则指的是当进行诸如&lt;code>open, read, write&lt;/code>等I/O操作时，这些操作&lt;strong>不会永远阻塞&lt;/strong>。&lt;strong>如果操作不能完成，则调用立即出错返回，以表示继续该操作将会阻塞&lt;/strong>。&lt;/p>
&lt;p>一般非阻塞I/O需要不断轮询判断是否有数据要进行读写，这种情况是比较浪费CPU时间的。&lt;strong>避免非阻塞I/O的两种方式：I/O多路转接或多线程采用阻塞I/O&lt;/strong>。&lt;/p></summary></item><item><title>OpenSSL生成SM2证书链</title><link>https://DBL2017.github.io/post/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/openssl%E7%94%9F%E6%88%90sm2%E8%AF%81%E4%B9%A6%E9%93%BE/</link><pubDate>Fri, 12 Apr 2024 14:26:50 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/openssl%E7%94%9F%E6%88%90sm2%E8%AF%81%E4%B9%A6%E9%93%BE/</guid><description>使用openssl工具并采用国密SM2算法生成证书链，包括根证书CA、二级CA、三级CA、服务端证书server.crt以及客户端证书client.crt。</description><tags>Openssl SM2 SM3 SM4 国密 TLS 证书 认证 CA</tags><summary>&lt;p>本文使用OpenSSL工具生成国密算法SM2的三级CA证书，组成证书链，并使用证书链签名客户端证书和服务端证书。&lt;/p>
&lt;p>可以通过证书链对生成的客户端和服务端证书进行校验。&lt;/p>
&lt;p>&lt;strong>虽然OpenSSL工具可以使用SM2算法来生成并校验证书，但是在TLS握手过程中主要支持RSA和ECC算法作为公钥加密算法，不支持SM2算法&lt;/strong>，因此无法在TLS加密连接中使用SM2证书。&lt;/p>
&lt;p>SSL/TLS协议主要使用RSA和ECC（椭圆曲线密码学）算法作为公钥加密算法，而SM2算法属于ECC算法的一种。&lt;a href="https://www.rfc-editor.org/rfc/rfc8998">RFC8898&lt;/a>&lt;/p></summary></item><item><title>守护进程</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</link><pubDate>Sat, 30 Mar 2024 22:26:53 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</guid><description>守护进程（dameon）控制终端，会话首进程，孤儿进程组，后台进程。编写守护进程（daemonize）的7个步骤（umask，fork，setsid，/dev/null），基于文件记录锁的单实例守护进程</description><tags>进程 守护进程 后台进程 出错管理</tags><summary>&lt;p>守护进程是生存期长的一种进程，在系统引导装入时启动，在系统关闭时终止。&lt;/p>
&lt;p>守护进程没有控制终端，通常在后台运行，实际上是在后台的孤儿进程组中运行。&lt;/p>
&lt;p>没有控制终端的原因在于&lt;strong>不与用户交互，避免终端信号影响&lt;/strong>。&lt;/p>
&lt;p>在孤儿进程组中运行的原因在于&lt;strong>防止其获取控制终端（通过每次打开终端设备设置参数&lt;code>O_NOCTTY&lt;/code>的方式不太靠谱）&lt;/strong>。&lt;/p></summary></item><item><title>线程和fork</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%92%8Cfork/</link><pubDate>Mon, 25 Mar 2024 19:30:47 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%92%8Cfork/</guid><description>本文探索多线程环境下调用fork创建子进程的方式，以及在父进程与子进程之间的数据共享方式。</description><tags>线程 Fork 多线程 写时复制 Pthread_atfork Fork处理程序</tags><summary>&lt;p>多线程环境下，调用&lt;code>fork&lt;/code>函数创建子进程时，子进程完全继承了父进程的整个内存地址空间。&lt;/p>
&lt;p>父进程中的互斥锁、多个线程在子进程中是如何处理的呢？&lt;/p>
&lt;p>由于父子进程之间采用了&lt;strong>写时复制&lt;/strong>技术，在子进程未改变互斥锁之前，父子进程对锁的状态是相同的，此时如何处理同步状态？&lt;/p></summary></item><item><title>多线程环境下信号处理</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</link><pubDate>Sun, 17 Mar 2024 18:37:49 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</guid><description>本文介绍了线程对信号的处理方式，一是共享信号处理行为，二是信号递送给单个线程。同时介绍了线程对信号处理的函数用法，包括`pthread_sigmask`、`sigwait`以及`pthread_kill`等。</description><tags>信号 多线程 Pthread_sigmask Sigwait Pthread_kill</tags><summary>&lt;p>多线程环境下需要使用互斥量等数据来进行线程间数据同步，然而同时使用同步对象与信号处理很容易造成死锁，本文探索如何在多线程环境下来进行信号处理。&lt;/p>
&lt;p>&lt;strong>在多线程环境中，为了防止信号中断线程，通常把信号加到每个线程的信号屏蔽字中。然后安排专用线程来处理信号&lt;/strong>。&lt;/p></summary></item><item><title>codebrowser之从浏览器阅读源码</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/codebrowser%E4%B9%8B%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/</link><pubDate>Wed, 13 Mar 2024 15:58:33 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/codebrowser%E4%B9%8B%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/</guid><description>基于WEB的源码阅读CodeBrowser的使用</description><tags>C语言 工具使用 源码阅读</tags><summary>&lt;p>codebrowser能够对源码生成静态HTML网页，搭配nginx可以在WEB上浏览源码。&lt;/p>
&lt;p>支持功能如下：&lt;/p>
&lt;ol>
&lt;li>代码跳转。&lt;/li>
&lt;li>代码高亮。&lt;/li>
&lt;li>代码提示。&lt;/li>
&lt;/ol></summary></item><item><title>WIN11搭建NFS-Server在开发板与Linux间共享数据</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/win11%E6%90%AD%E5%BB%BAnfs-server%E5%9C%A8%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8Elinux%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</link><pubDate>Tue, 12 Mar 2024 22:31:29 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/win11%E6%90%AD%E5%BB%BAnfs-server%E5%9C%A8%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8Elinux%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</guid><description>本文通过使用NFS Server工具在WIN11上搭建NMS Server，打通Linux开发环境到嵌入式板子之间的通路，优化Linux服务器与嵌入式板子之间的多次SCP拷贝操作。</description><tags>Linux NFS NFSServer 开发板 WIN11</tags><summary>&lt;p>本文通过使用NFS Server工具在WIN11上搭建NMS Server，打通Linux开发环境到嵌入式板子之间的通路，优化Linux服务器与嵌入式板子之间的多次SCP拷贝操作。&lt;/p>
&lt;p>Windows下的NFS Server工具来自于&lt;a href="https://www.hanewin.net/index.html">Networking Software for Windows (hanewin.net)&lt;/a>&lt;/p></summary></item><item><title>线程特定数据</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE/</link><pubDate>Tue, 05 Mar 2024 22:50:37 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE/</guid><description>线程特定数据（thread-specific data），也称为线程私有数据（thread-private data），是线程单独的数据副本，存储在线程的私有存储空间，不与进程中其他线程共享。</description><tags>线程 线程特定数据 Pthread_key_t 线程键 析构函数 Pthread_once Pthread_setspecific</tags><summary>&lt;p>线程特定数据（thread-specific data），也称为线程私有数据（thread-private data），是线程单独的数据副本，存储在线程的私有存储空间，不与进程中其他线程共享。&lt;/p>
&lt;p>线程键（&lt;code>pthread_key_t&lt;/code>），每个线程用其与自身特定数据地址进行关联。&lt;/p>
&lt;p>析构函数用于线程退出时调用。通常使用&lt;code>malloc&lt;/code>为线程特定数据分配内存，析构函数通常用于释放已分配的内存。&lt;/p></summary></item><item><title>线程安全、可重入以及异步信号安全函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 02 Mar 2024 23:07:15 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/</guid><description>异步信号安全函数是可重入的，可重入函数是线程安全的。</description><tags>线程 线程安全 可重入函数 异步信号安全</tags><summary>&lt;p>可重入等价于异步信号安全。&lt;/p>
&lt;p>线程安全与可重入以及异步信号安全没有必然联系。&lt;/p></summary></item><item><title>线程同步之屏障属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C%E5%B1%9E%E6%80%A7/</link><pubDate>Mon, 26 Feb 2024 22:38:16 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C%E5%B1%9E%E6%80%A7/</guid><description>线程同步的相关属性，控制线程同步时的行为</description><tags>同步属性 条件变量 进程共享 屏障</tags><summary>&lt;p>屏障的作用是允许每个线程完成自身任务之后等待，直到所有线程都达到某一点，然后从该点继续执行。&lt;/p>
&lt;p>默认情况下屏障应用于单个进程的多个线程之间。&lt;/p>
&lt;p>屏障的进程共享属性允许将屏障应用于多个进程之间，前提是多个进程能够访问到同一个屏障对象。&lt;/p></summary></item><item><title>线程同步之条件变量属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7/</link><pubDate>Sun, 25 Feb 2024 10:19:46 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7/</guid><description>条件变量属性</description><tags>同步属性 条件变量 进程共享 时钟属性</tags><summary>&lt;p>线程条件变量可以是线程&lt;strong>以非竞争的方式同步执行&lt;/strong>。&lt;/p>
&lt;p>线程条件变量支持两个属性：&lt;strong>进程共享&lt;/strong>与&lt;strong>时钟属性&lt;/strong>。&lt;/p>
&lt;p>进程共享属性可以使条件变量被多进程的线程使用。&lt;/p>
&lt;p>时钟属性控制计算&lt;code>pthread_cond_timedwait()&lt;/code>函数的超时参数（&lt;code>tsptr&lt;/code>）时采用哪个时钟。&lt;/p></summary></item><item><title>线程同步之读写锁属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%B1%9E%E6%80%A7/</link><pubDate>Sat, 24 Feb 2024 17:50:34 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%B1%9E%E6%80%A7/</guid><description>线程的读写锁同步属性，用于控制线程同步时的行为</description><tags>读写锁 同步属性 进程共享</tags><summary>&lt;p>本文介绍了线程的同步对象读写锁的属性，通过读写锁属性可以控制在线程之间使用读写锁同步时的行为。&lt;/p>
&lt;p>线程的读写锁仅支持&lt;strong>进程共享&lt;/strong>属性。&lt;/p></summary></item><item><title>线程同步之互斥量属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F%E5%B1%9E%E6%80%A7/</link><pubDate>Fri, 23 Feb 2024 23:42:59 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F%E5%B1%9E%E6%80%A7/</guid><description>线程的同步类型属性，通过设置属性来控制线程的同步行为</description><tags>线程属性 互斥量属性 健壮 类型 进程共享</tags><summary>&lt;p>本文主要介绍了线程同步对象互斥量的相关属性，并通过代码验证了这些属性。&lt;/p>
&lt;p>通过这些线程同步对象的属性可以控制不同线程在使用互斥量进行同步时的行为。&lt;/p></summary></item><item><title>线程属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7/</link><pubDate>Wed, 31 Jan 2024 22:57:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7/</guid><description>系统对线程的限制、通过属性对象控制线程、线程的同步属性</description><tags>APUE 线程 线程属性 线程限制 Pthread_attr_t</tags><summary>&lt;p>SUS定义了一些系统层面上对于线程的限制，比如进程可以创建的最大线程数、线程栈可用的最小字节数等等。&lt;/p>
&lt;p>&lt;code>pthread&lt;/code>接口允许我们传入&lt;strong>线程或同步对象的属性&lt;/strong>来调节线程或同步对象的行为。&lt;/p></summary></item><item><title>信号集及相关函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 16 Jan 2024 23:18:13 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程 信号集 Sigset_t</tags><summary>&lt;p>&lt;strong>信号集&lt;/strong>（&lt;code>sigset_t&lt;/code>）是表示多个信号的数据类型。&lt;/p>
&lt;p>不同的信号编号可能会超过一个整型量的位数，所以不能用整型量中的一位代表一个信号。&lt;/p>
&lt;p>POSIX.1定义数据类型&lt;code>sigset_t&lt;/code>用以表示信号集，并定义了信号的操作函数。&lt;/p></summary></item><item><title>可靠信号</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7/</link><pubDate>Sun, 14 Jan 2024 23:18:50 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程 可靠信号 信号递送 Kill Pause Alarm</tags><summary>&lt;p>可靠信号的处理有两个过程如下：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>信号产生&lt;/strong>：当这些事件（&lt;strong>硬件异常（如除以0）、软件条件（如alarm定时器超时）、终端产生的信号或调用&lt;code>kill&lt;/code>函数&lt;/strong>）发生时，内核会为进程产生一个信号，同时在进程表中设置一个标志。&lt;/li>
&lt;li>&lt;strong>信号递送&lt;/strong>：内核使&lt;strong>目标进程对该信号作出反应&lt;/strong>称为信号递送：或是改变目标进程的执行状态（默认动作），或是开始执行信号处理程序，或两者都是。&lt;/li>
&lt;/ol></summary></item><item><title>不可靠信号的相关问题</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 12 Jan 2024 21:10:43 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程 不可靠信号 信号丢失</tags><summary>&lt;p>不可靠信号指的是信号可能会丢失，不支持信号阻塞，不能控制是否重启中断的系统调用等等。&lt;/p>
&lt;p>下面是不可靠信号可能会出现的问题：&lt;/p></summary></item><item><title>信号概述</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0/</link><pubDate>Wed, 10 Jan 2024 21:10:43 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程</tags><summary>&lt;p>信号是软件中断。&lt;/p>
&lt;p>信号提供了一种处理异步事件的方法。&lt;/p>
&lt;p>信号用于大多数复杂的应用程序中。&lt;/p>
&lt;p>Unix系统的早期版本就已经提供了信号机制，但不可靠。POSIX.1对可靠信号例程进行了标准化。&lt;/p></summary></item><item><title>线程同步之屏障</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C/</link><pubDate>Fri, 17 Nov 2023 20:45:04 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C/</guid><description>线程同步的另一种方式，屏障</description><tags>APUE 线程 线程同步 屏障 Pthread</tags><summary>&lt;p>屏障（barrier）是用户协调多个线程并行工作的同步机制。&lt;/p>
&lt;p>&lt;strong>屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。&lt;/strong>&lt;/p>
&lt;p>&lt;code>pthread_join&lt;/code>是一种特殊的屏障，允许一个线程等待，直到另一个线程退出。&lt;/p></summary></item><item><title>线程同步之条件变量</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Sun, 22 Oct 2023 21:05:40 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description>线程同步的方式之一，条件变量</description><tags>APUE 线程 线程同步 同步 条件变量 Unix Pthread</tags><summary>&lt;p>&lt;strong>互斥量&lt;/strong>防止多个线程同时访问同一共享变量。&lt;/p>
&lt;p>&lt;strong>条件变量&lt;/strong>允许一个线程就某个&lt;strong>条件&lt;/strong>（共享变量）的变化状态通知其他线程，并让其他线程等待（阻塞于）该通知。&lt;/p>
&lt;p>&lt;strong>条件变量与互斥量一起使用，允许线程以无竞争的方式等待特定的条件发生。&lt;/strong>&lt;/p></summary></item><item><title>线程同步之读写锁</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Mon, 16 Oct 2023 23:07:02 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>线程同步方式之一，读写锁</description><tags>APUE 线程 线程同步 读写锁 Unix Pthread</tags><summary>&lt;p>读写锁也称为共享互斥锁，具有3种状态：&lt;strong>读模式下的加锁状态&lt;/strong>、&lt;strong>写模式下的加锁状态&lt;/strong>、&lt;strong>不加锁状态&lt;/strong>。&lt;/p>
&lt;p>一次仅有一个线程可以占有写模式下的读写锁，但是多个线程可以同时占有读模式下的读写锁。&lt;/p>
&lt;p>读写锁非常&lt;strong>适合于对数据结构读的次数远大于写的情况&lt;/strong>。&lt;/p>
&lt;p>与互斥量相比，读写锁（reader-writer lock）运行更高的并行性。&lt;/p></summary></item><item><title>线程同步之互斥量</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F/</link><pubDate>Sat, 14 Oct 2023 14:29:41 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F/</guid><description>线程的几种同步方式，包括信号量、互斥量、读写锁、自旋锁、屏障等</description><tags>APUE Unix 线程 线程同步 互斥量 死锁 Pthread</tags><summary>&lt;p>当多个线程共享相同的内存时，需要确保每个线程看到的都是一致的数据视图。&lt;/p>
&lt;p>&lt;strong>当一个线程可以修改的变量，其他线程也可以读取或修改的时候&lt;/strong>，就需要对这些线程进行&lt;strong>同步&lt;/strong>，确保访问变量时不会得到无效的值。&lt;/p></summary></item><item><title>线程的全生命周期</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Fri, 06 Oct 2023 14:54:11 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>线程的创建、运行、销毁、释放空间等全生命周期</description><tags>APUE Unix 线程 Pthread</tags><summary>&lt;p>多线程与处理器的核心数无关，即使单核处理器也可以运行多线程。&lt;/p>
&lt;p>多线程的设计有很多优点：&lt;/p>
&lt;ol>
&lt;li>简化处理异步事件&lt;/li>
&lt;li>共享内存和文件描述符&lt;/li>
&lt;li>提高程序吞吐量&lt;/li>
&lt;li>提高交互程序的响应等等&lt;/li>
&lt;/ol></summary></item><item><title>MQTT保活机制</title><link>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6/</link><pubDate>Wed, 26 Jul 2023 23:40:23 +0800</pubDate><guid>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6/</guid><description/><tags>传输协议 MQTT KeepAlive 保活 PINGREQ PINGRESP 保持活动时间</tags><summary>&lt;p>MQTT保持活动机制是MQTT协议定义的一项功能。&lt;/p>
&lt;p>MQTT客户端通过向代理发送为PINGREQ报文来维持与代理的连接。&lt;/p>
&lt;p>MQTT代理通过接收PINGREQ来&lt;strong>检测客户端是否无响应或断开连接&lt;/strong>，同理MQTT客户端通过接收PINGRESP响应来判断代理是否可用。&lt;/p></summary></item><item><title>MQTT遗嘱</title><link>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E9%81%97%E5%98%B1/</link><pubDate>Fri, 21 Jul 2023 23:16:21 +0800</pubDate><guid>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E9%81%97%E5%98%B1/</guid><description/><tags>传输协议 MQTT 保留消息 遗嘱 遗嘱消息 设备状态</tags><summary>&lt;p>MQTT遗嘱（Last Will and Testament, LWT），允许客户端指定一条消息，在发生意外断开连接时，代理自动发布该消息到已订阅的其他客户端。&lt;/p>
&lt;p>MQTT遗嘱 (LWT) 功能对于确保高效通信和在客户端意外断开时保持系统完整性至关重要。&lt;/p></summary></item><item><title>MQTT保留消息</title><link>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E4%BF%9D%E7%95%99%E6%B6%88%E6%81%AF/</link><pubDate>Fri, 21 Jul 2023 20:03:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E4%BF%9D%E7%95%99%E6%B6%88%E6%81%AF/</guid><description/><tags>传输协议 MQTT 保留消息 RetainMessage 保留标志</tags><summary>&lt;p>MQTT的保留消息可以&lt;strong>为订阅者提供指定主题上的最新状态&lt;/strong>（前提是最新消息发布时保留标志设置为true）。&lt;/p>
&lt;p>保留消息是&lt;strong>保留标志设置为true的普通MQTT消息&lt;/strong>。&lt;/p>
&lt;p>每个订阅带有保留消息的主题的客户端在&lt;strong>订阅后都会立即接收保留消息&lt;/strong>。&lt;/p>
&lt;p>当客户端向指定主题发送多条保留消息时，代理仅存储最后的保留消息以及相应的QoS级别。&lt;/p>
&lt;p>&lt;strong>代理为每个主题仅存储一条保留消息&lt;/strong>。&lt;/p></summary></item><item><title>MQTT持久会话</title><link>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E6%8C%81%E4%B9%85%E4%BC%9A%E8%AF%9D/</link><pubDate>Wed, 19 Jul 2023 23:51:14 +0800</pubDate><guid>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E6%8C%81%E4%B9%85%E4%BC%9A%E8%AF%9D/</guid><description/><tags>传输协议 MQTT 会话存在标志 SessionPresent QoS1 QoS2 会话状态 会话信息</tags><summary>&lt;p>MQTT中的持久会话允许客户端在断开连接时维护其会话状态，包括订阅的主题和未传递的消息。&lt;/p>
&lt;p>非持久会话在断开连接时丢弃会话状态，要求客户端重新连接上再次订阅主题，并可能错过在断开连接期间发布的消息。&lt;/p>
&lt;p>持久会话和非持久会话的选择取决于应用程序对会话连续性和消息持久性的要求。&lt;/p></summary></item><item><title>MQTT服务质量</title><link>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/</link><pubDate>Tue, 18 Jul 2023 23:29:49 +0800</pubDate><guid>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/</guid><description>MQTT的消息服务质量QoS，包含QoS0，QoS1以及QoS2，设计报文有PUBLISH、PUBACK、PUBREC、PUBCOMP等。解释了为什么QoS2会保证消息不重复并确保一次。</description><tags>传输协议 MQTT QoS 服务质量 QoS1 QoS2 QoS0</tags><summary>&lt;p>MQTT Quality of Service（QoS，服务质量）是消息发送者和接收者之间的协议，用于定义消息的传递保证级别。&lt;/p>
&lt;p>QoS具有3个级别，分别是：&lt;/p>
&lt;ol>
&lt;li>最多一次（QoS 0）&lt;/li>
&lt;li>至少一次（QoS 1）&lt;/li>
&lt;li>确定一次（QoS 2）&lt;/li>
&lt;/ol>
&lt;p>其中涉及的MQTT报文有四种，分别是PUBLISH、PUBACK、PUBREC以及PUBCOMP。&lt;/p></summary></item><item><title>MQTT主题</title><link>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E4%B8%BB%E9%A2%98/</link><pubDate>Mon, 17 Jul 2023 23:16:16 +0800</pubDate><guid>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E4%B8%BB%E9%A2%98/</guid><description/><tags>传输协议 MQTT MQTT主题 主题 Topic $SYS 通配符</tags><summary>&lt;p>MQTT主题是MQTT客户端和代理之间进行通信的关键。&lt;/p>
&lt;p>根据主题可以对消息进行有效的过滤和路由。&lt;/p>
&lt;p>与消息队列相比，MQTT主题非常轻量。&lt;/p>
&lt;p>客户端在发布或订阅所需的主题之前不需要创建该主题。代理接受每个有效的主题，而不需要事先进行任何初始化。&lt;/p></summary></item><item><title>MQTT消息传递与接收</title><link>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E4%B8%8E%E6%8E%A5%E6%94%B6/</link><pubDate>Sat, 15 Jul 2023 20:57:40 +0800</pubDate><guid>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E4%B8%8E%E6%8E%A5%E6%94%B6/</guid><description/><tags>传输协议 MQTT MQTT客户端 MQTT代理 MQTT连接 PUBLISH SUBSCRIBE SUBACK UNSUBSCRIBE UNSUBACK</tags><summary>&lt;p>MQTT客户端发布消息时使用的是PUBLISH报文，发布成功之后会接收到PUBACK报文。&lt;/p>
&lt;p>订阅时发送SUBSCRIBE报文，订阅成功会接收到SUBACK报文。&lt;/p>
&lt;p>取消订阅发送UNSUBSCIBE报文。&lt;/p></summary></item><item><title>MQTT建立连接</title><link>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/</link><pubDate>Sat, 15 Jul 2023 09:08:17 +0800</pubDate><guid>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/</guid><description/><tags>传输协议 MQTT MQTT客户端 MQTT代理 MQTT连接 CONNECT CONNACK Cleansession WillMessage</tags><summary>&lt;p>MQTT协议的两个主要组件是客户端和代理。&lt;/p>
&lt;p>MQTT客户端可以是任何运行MQTT库并通过网络连接到MQTT代理的设备。&lt;/p>
&lt;p>MQTT代理负责接收、过滤以及向已订阅的客户端发送消息，并处理客户端身份验证和授权。&lt;/p></summary></item><item><title>MQTT发布/订阅模式</title><link>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 13 Jul 2023 23:31:17 +0800</pubDate><guid>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</guid><description/><tags>传输协议 MQTT Pub/Sub 发布/订阅 主题 订阅</tags><summary>&lt;p>发布/订阅（Pub/Sub）架构提供了一种灵活的、可伸缩的方式来构建能够处理许多连接的客户端的分布式系统。&lt;/p>
&lt;p>MQTT基于发布/订阅架构，支持持久会话与服务质量QoS功能，实现了发布者与订阅者在空间、时间以及同步等方面的解耦。&lt;/p></summary></item><item><title>MQTT简介</title><link>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E7%AE%80%E4%BB%8B/</link><pubDate>Wed, 12 Jul 2023 20:10:13 +0800</pubDate><guid>https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/mqtt/mqtt%E7%AE%80%E4%BB%8B/</guid><description/><tags>传输协议 MQTT MQTT3.1.1 MQTT5 消息模型 主题 订阅 QoS 持久会话</tags><summary>&lt;p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议）是一个&lt;strong>基于C/S架构的发布/订阅模式的消息传输协议&lt;/strong>。&lt;/p>
&lt;p>目的是&lt;strong>在带宽和连接有限的不可靠网络的环境下发送少量数据&lt;/strong>，设计思想是轻量、开放、简单并且易于实现。&lt;/p>
&lt;p>这些特性使得MQTT非常适合在受限的环境的环境中使用，比如机器对机器(M2M)通信和物联网(IoT)。&lt;/p></summary></item><item><title>密码技术总结与比特币</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81/</link><pubDate>Sun, 09 Jul 2023 21:14:06 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81/</guid><description/><tags>图解密码技术 对称密码 公钥密码 单向散列函数 消息认证码 数字签名 伪随机生成器 密码框架 压缩技术 比特币 区块链 挖矿 区块添加</tags><summary>&lt;p>“密码学家的工具箱”中一共包含了6种基本的密码技术。分别是对称密码、公钥密码、单向散列函数、消息认证码、数字签名以及伪随机数生成器。&lt;/p>
&lt;p>比特币是一种虚拟货币，也叫密码学货币。&lt;/p>
&lt;p>比特币可以脱离物理介质，仅通过互联网就可以流通。&lt;/p></summary></item><item><title>TLS</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/tls/</link><pubDate>Sat, 08 Jul 2023 21:23:44 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/tls/</guid><description/><tags>图解密码技术 SSL TLS SSL/TLS 主密钥 Diffie-Hellman TLS握手 GCM 伪随机函数 PRF Handshake</tags><summary>&lt;p>SSL/TLS是使用最广泛的加密通信方法。&lt;/p>
&lt;p>SSL/TLS中广泛运用了对称密码、消息认证码、公钥密码、数字签名、伪随机数生成器等密码技术。&lt;/p>
&lt;p>SSL（Secure Socket Layer）与TLS（Transport Layer Security）是不同的，TLS相当于是SSL的后续版本。&lt;/p>
&lt;p>SSL/TLS可以通过切换密码套件来使用强度更高的密码算法。&lt;/p></summary></item><item><title>PGP</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/pgp/</link><pubDate>Tue, 04 Jul 2023 22:45:47 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/pgp/</guid><description/><tags>图解密码技术 PGP OpenGPG GnuPG GnuPGv2 Gpg2 密钥对 信任网 信任级别 消息压缩 数字签名 加解密 混合密码系统</tags><summary>&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>PGP&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>时间&lt;/td>
 &lt;td>1990年&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>作者&lt;/td>
 &lt;td>菲利普·齐默曼&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>全称&lt;/td>
 &lt;td>Pretty Good Privary&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>用途&lt;/td>
 &lt;td>商业密码软件&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>支持平台&lt;/td>
 &lt;td>Windows、Mac OS X、Linux&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>版本&lt;/td>
 &lt;td>商用版、免费版&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>GnuPG&lt;/td>
 &lt;td>GNU Privacy Guard，遵循OpenGPG规范编写的密码软件。&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>PGP设计目的是在连国家都不可信的情况下仍然能够使用，因此并不关心有没有可信的认证机构，而是采用了“&lt;strong>由用户自己来决定信任谁&lt;/strong>”的设计。&lt;/p></summary></item><item><title>PahoMQTT连线中断恢复之后无法收到消息</title><link>https://DBL2017.github.io/post/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/pahomqtt%E8%BF%9E%E7%BA%BF%E4%B8%AD%E6%96%AD%E6%81%A2%E5%A4%8D%E4%B9%8B%E5%90%8E%E6%97%A0%E6%B3%95%E6%94%B6%E5%88%B0%E6%B6%88%E6%81%AF/</link><pubDate>Tue, 04 Jul 2023 09:13:27 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/pahomqtt%E8%BF%9E%E7%BA%BF%E4%B8%AD%E6%96%AD%E6%81%A2%E5%A4%8D%E4%B9%8B%E5%90%8E%E6%97%A0%E6%B3%95%E6%94%B6%E5%88%B0%E6%B6%88%E6%81%AF/</guid><description/><tags>MQTT Topic Paho 连线中断 订阅 Cleansession AutomaticReconnect 会话 自动重连</tags><summary>&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>条目&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>库名&lt;/td>
 &lt;td>paho.mqtt.c&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>版本&lt;/td>
 &lt;td>1.3.12&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>github&lt;/td>
 &lt;td>&lt;a href="https://github.com/eclipse/paho.mqtt.c.git">https://github.com/eclipse/paho.mqtt.c.git&lt;/a>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>问题&lt;/td>
 &lt;td>启用&lt;code>cleansession&lt;/code>和&lt;code>automaticReconnect&lt;/code>后，连接中断恢复之后无法收到之前订阅的主题的消息。&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table></summary></item><item><title>伪随机生成器</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%99%A8/</link><pubDate>Sun, 02 Jul 2023 21:33:49 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%99%A8/</guid><description/><tags>图解密码技术 伪随机数 随机数 随机性 单向散列函数 密码 线性同余法</tags><summary>&lt;p>在密码技术中，随机数被用来生成密码。&lt;/p>
&lt;p>随机数的性质分为三类：随机性、不可预测性和不可重现性。&lt;/p>
&lt;p>线性同余法是很多库函数所采用的生成伪随机数的方法，但不可以用于密码技术。&lt;/p>
&lt;p>用于密码技术的伪随机数生成器，需要使用单向散列函数和密码技术确保不可预测性。&lt;/p></summary></item><item><title>Linux路由表</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E8%B7%AF%E7%94%B1%E8%A1%A8/</link><pubDate>Sat, 01 Jul 2023 12:27:43 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E8%B7%AF%E7%94%B1%E8%A1%A8/</guid><description/><tags>Linux 路由表 路由 Route GW IP 路由选择 静态路由 Netmask 网关 路由标志 路由种类 主机路由 网络路由 默认路由 IP选路</tags><summary>&lt;p>主机和网关（路由器）的本质区别在于&lt;strong>主机从不把数据报从一个接口转发到另一个接口，而网关（路由器）则要转发数据报&lt;/strong>。&lt;/p>
&lt;p>当今大多数用户系统，IP层既可以配置为网关（路由器）的功能，也可以配置为主机的功能。&lt;/p></summary></item><item><title>resolv.conf配置说明</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/resolv.conf%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</link><pubDate>Thu, 29 Jun 2023 23:19:54 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/resolv.conf%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</guid><description/><tags>DNS Resolver Resolv.conf 域名 域名解析</tags><summary>&lt;p>在Linux中，&lt;strong>resolver&lt;/strong>（域名解析器）是一组进行域名转换函数组成的库。&lt;/p>
&lt;p>具体来说，就是通过&lt;strong>查询DNS（Domain Name Server）将域名转换为IP地址&lt;/strong>。&lt;/p>
&lt;p>/etc/resolv.conf是域名解析器的配置文件。&lt;/p></summary></item><item><title>Linux下手动配置网络</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E4%B8%8B%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C/</link><pubDate>Mon, 26 Jun 2023 10:19:40 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E4%B8%8B%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C/</guid><description/><tags>DNS Linux 域名 域名解析 配置文件 Hosts Resolv.conf Ifconfig 静态路由 默认路由 DNS服务器 Nameserver GW 主机路由 广播地址 Route</tags><summary>&lt;p>当一个设备加入到网络中时，通常需要&lt;strong>获得一个IP地址、设置一条正确的默认路由以及一个可以连上的DNS服务器&lt;/strong>。&lt;/p>
&lt;p>当网络采用了DHCP时，那么大部分的配置工作都会在DHCP服务器上完成，设备中的DHCP客户端只需要从服务器上获取到参数，然后配置到设备中即可。&lt;/p>
&lt;p>如果没有采用DHCP或者设备中没有DHCP客户端，就需要手动来配置网络（配置IP、配置静态路由、配置DNS）。&lt;/p></summary></item><item><title>uptime</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/linux%E5%91%BD%E4%BB%A4/uptime/</link><pubDate>Tue, 20 Jun 2023 09:36:05 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/linux%E5%91%BD%E4%BB%A4/uptime/</guid><description/><tags>Linux命令 Uptime 负载</tags><summary>&lt;p>告诉当前用户系统的运行时长。&lt;/p>
&lt;p>用法：&lt;code>uptime [options]&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># ubuntu&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ uptime
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">09:39:24 up &lt;span class="m">266&lt;/span> days, 15:14, &lt;span class="m">9&lt;/span> users, load average: 0.04, 0.11, 0.15
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ nproc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">80&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># busybox&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ uptime
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">01:39:51 up 8:39, load average: 0.71, 0.72, 0.69
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ nproc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></summary></item><item><title>证书</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E8%AF%81%E4%B9%A6/</link><pubDate>Tue, 13 Jun 2023 23:32:17 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E8%AF%81%E4%B9%A6/</guid><description/><tags>图解密码技术 CA 证书 签名 数字签名 散列值 X.509 证书作废 PKI PKCS 认证 认证机构</tags><summary>&lt;p>什么是证书？证书的使用场景。&lt;/p>
&lt;p>证书标准规范X.509、颁发证书的认证机构。&lt;/p>
&lt;p>公钥基础设施PKI，对PKI的攻击方法和对策。&lt;/p>
&lt;p>无论是数字签名、证书，还是认证机构的层级结构，都&lt;strong>不可能在完全不可信的状态下创造出信任关系&lt;/strong>。&lt;/p></summary></item><item><title>数字签名</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</link><pubDate>Mon, 12 Jun 2023 09:44:34 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</guid><description/><tags>图解密码技术 数字签名 密钥 散列值 DSA ECDSA</tags><summary>&lt;p>数字签名的基础知识、如何使用公钥密码实现数字签名。&lt;/p>
&lt;p>使用RSA具体实践数字签名的生成和验证。&lt;/p>
&lt;p>探讨针对数字签名的攻击方法以及数字签名与消息验证码之间的关系。&lt;/p>
&lt;p>数字签名可以识别篡改和伪装，还可以防止否认。&lt;/p>
&lt;p>数字签名是一种非常重要的认证技术，前提&lt;strong>是用于验证签名的发送者的公钥没有被伪造。&lt;/strong>&lt;/p></summary></item><item><title>消息认证码</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/</link><pubDate>Mon, 05 Jun 2023 22:41:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/</guid><description/><tags>图解密码技术 消息认证码 HMAC 单向散列函数 数字签名 对称密码 GCM 认证</tags><summary>&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: right">消息认证码&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: right">作用&lt;/td>
 &lt;td>对消息进行认证并确认其完整性的技术，但不能保证消息的机密性&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: right">原理&lt;/td>
 &lt;td>使用发送者和接收者之间共享的密码，识别是否存在伪装或篡改&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: right">实用技术&lt;/td>
 &lt;td>单向散列函数和对称加密技术&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: right">存在问题&lt;/td>
 &lt;td>由于收发双方共享相同密钥，因此无法对第三方证明以及无法防止否认&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>认证加密&lt;/strong>是将消息认证码与对称加密相结合，同时满足消息机密性、完整性以及认证三大功能。&lt;/p>
&lt;p>由于使用对称密码，发送者和接收者均可以生成消息认证码，因此对于第三方来说无法证明消息是由发送者生成的，即&lt;strong>消息认证码无法防止否认&lt;/strong>。&lt;/p></summary></item><item><title>OpenSSL生成RSA证书链</title><link>https://DBL2017.github.io/post/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/openssl%E7%94%9F%E6%88%90rsa%E8%AF%81%E4%B9%A6%E9%93%BE/</link><pubDate>Sat, 20 May 2023 10:07:32 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/openssl%E7%94%9F%E6%88%90rsa%E8%AF%81%E4%B9%A6%E9%93%BE/</guid><description>使用openssl工具以及RSA加密算法生成证书链，其中包含根证书CA、服务器证书server.crt以及客户端证书client.crt。</description><tags>Openssl CA Cafile 证书 SSL TLS 双向通信校验 RSA 认证</tags><summary>&lt;p>本文使用openssl工具生成RSA算法的三级CA证书，组成证书链，并使用证书链签名客户端证书和服务端证书。&lt;/p>
&lt;p>可以通过证书链对生成的客户端和服务端证书进行校验。&lt;/p></summary></item><item><title>基于SSL的MQTT双向认证加密通信</title><link>https://DBL2017.github.io/post/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/%E5%9F%BA%E4%BA%8Essl%E7%9A%84mqtt%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1/</link><pubDate>Sat, 20 May 2023 10:00:29 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/%E5%9F%BA%E4%BA%8Essl%E7%9A%84mqtt%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1/</guid><description/><tags>MQTT Mosquitto MQTTX SSL TLS SSL/TLS 证书 双向通信验证</tags><summary>&lt;p>在Ubuntu22.04系统上，基于mosquitto version 2.0.11，搭建mqtt+ssl/tls broker。&lt;/p>
&lt;p>测试工具有&lt;a href="https://mqttx.app/zh">MQTTX：跨平台 MQTT 5.0 桌面客户端工具&lt;/a>以及mqtt_sub和mqtt_pub。&lt;/p></summary></item><item><title>单向散列函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 16 May 2023 22:46:08 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</guid><description/><tags>图解密码技术 认证 单向散列函数 SHA SHA-256 SHA3 MD5 Keccak</tags><summary>&lt;p>单向散列函数能够根据任意长度的消息计算出固定长度的散列值，通过对比散列值可以判断两条消息是否一致，这种技术可用来辨别篡改。&lt;/p>
&lt;p>SHA-3的具体实现方法。&lt;/p>
&lt;p>针对单向散列函数的工具：暴力破解和生日攻击。&lt;/p>
&lt;p>使用单向散列函数可以辨别篡改，但无法分辨伪装。要解决这个问题，需要使用消息认证码和数字签名。&lt;/p></summary></item><item><title>混合密码系统</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%B7%B7%E5%90%88%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 15 May 2023 21:55:17 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%B7%B7%E5%90%88%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/</guid><description/><tags>图解密码技术 密码 混合密码 公钥密码 会话密钥</tags><summary>&lt;p>混合密码系统用对称明码加密明文，用公钥密码来加密对称密码中所使用的密钥。&lt;/p>
&lt;p>通过使用混合密码系统，能够在通信中将对称密码和公钥密码的优势结合起来。&lt;/p></summary></item><item><title>2023下半年任务计划</title><link>https://DBL2017.github.io/post/2023%E4%B8%8B%E5%8D%8A%E5%B9%B4%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/</link><pubDate>Sat, 13 May 2023 10:44:08 +0800</pubDate><guid>https://DBL2017.github.io/post/2023%E4%B8%8B%E5%8D%8A%E5%B9%B4%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/</guid><description/><tags>半年计划</tags><summary>&lt;p>本清单罗列了下半年的计划目标&lt;/p></summary></item><item><title>公钥密码</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/</link><pubDate>Fri, 05 May 2023 23:42:48 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/</guid><description/><tags>图解密码技术 密码 密码学 密码技术 公钥密码</tags><summary>&lt;p>&lt;strong>密钥配送问题&lt;/strong>：在对称密码中，由于加密和解密的密钥是相同的，因此必须事先向接收者配送密钥。&lt;/p>
&lt;p>如果使用公钥密码，则无需向接收者配送用于解密的密钥，这就相当于解决了密钥配送问题。&lt;/p>
&lt;p>&lt;strong>对称密码通过将明文转换为复杂的形式来保证机密性，公钥密码则是基于数学难题来保证机密性。&lt;/strong> 例如RSA利用了大整数的质因数分解问题的困难度。&lt;/p>
&lt;p>即使已经有了公钥密码，对称密码也不会消失。&lt;/p>
&lt;p>&lt;strong>公钥密码的运行速度远远低于对称密码&lt;/strong>，因此一般通信过程中，往往会配合使用这两种密码，即用对称密码提高处理速度，用公钥密码解决密钥配送问题。这样的方式称为&lt;strong>混合密码系统&lt;/strong>。&lt;/p></summary></item><item><title>分组密码</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/</link><pubDate>Wed, 03 May 2023 22:14:35 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/</guid><description/><tags>图解密码技术 密码 密码学 密码技术 分组密码</tags><summary>&lt;p>密码算法可以分为分组密码和流密码两种。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>术语&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>分组密码&lt;/td>
 &lt;td>每次只能处理特定长度的一块数据的一类密码算法。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>分组&lt;/td>
 &lt;td>每次处理的数据。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>分组长度&lt;/td>
 &lt;td>每次处理的数据分组的比特数。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>流密码&lt;/td>
 &lt;td>对数据流进行连续处理的一类密码算法。一般以1比特、8比特或32比特等为单位进行加解密。&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>DES、三重DES以及AES（Rijndael）等大多数对称密码算法都属于分组密码。&lt;/p></summary></item><item><title>对称密码之Rijndael和AES</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%B9%8Brijndael%E5%92%8Caes/</link><pubDate>Thu, 20 Apr 2023 20:56:18 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%B9%8Brijndael%E5%92%8Caes/</guid><description/><tags>图解密码技术 密码 密码学 密码技术 AES 对称密码</tags><summary>&lt;p>&lt;strong>AES&lt;/strong>（Advanced Encryption Standard）是取代前任标准（DES）而成为新标准的一种对称密码算法。&lt;/p>
&lt;p>2000年，在多个对称密码候选算法中，选出了一种名为&lt;strong>Rijndael&lt;/strong>的对称密码算法，并将其确定为了AES。&lt;/p></summary></item><item><title>对称密码之Feistel网络</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%B9%8Bfeistel%E7%BD%91%E7%BB%9C/</link><pubDate>Mon, 17 Apr 2023 20:12:56 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%B9%8Bfeistel%E7%BD%91%E7%BB%9C/</guid><description/><tags>图解密码技术 密码 密码学 密码技术 DES Feistel 对称密码</tags><summary>&lt;p>对称密码指的是用相同的密钥进行加密和解密。&lt;/p>
&lt;p>在Feistel网络中，加密的各个步骤称为&lt;strong>轮&lt;/strong>，整个加密过程就是进行若干次轮的循环。&lt;/p>
&lt;p>&lt;strong>DES是一种16轮循环的Feistel网络。&lt;/strong>&lt;/p></summary></item><item><title>历史上的几种简单密码</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81/</link><pubDate>Thu, 13 Apr 2023 23:14:26 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81/</guid><description/><tags>图解密码技术 密码 密码学 历史密码 凯撒密码 简单替换密码 Enigma</tags><summary>&lt;p>3中历史上著名的密码：凯撒密码、简单替换密码、Enigma。&lt;/p>
&lt;p>两种密码破译方法：暴力攻击和频率分析。&lt;/p></summary></item><item><title>密码学常识</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%B8%B8%E8%AF%86/</link><pubDate>Thu, 13 Apr 2023 19:45:37 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%B8%B8%E8%AF%86/</guid><description/><tags>图解密码技术 密码学 密码 对称密码 公钥密码 RSA 哈希 数字签名 随机数 伪随机数 消息认证码</tags><summary>&lt;p>&lt;strong>对称密码&lt;/strong>、&lt;strong>公钥密码&lt;/strong>、&lt;strong>单向散列函数&lt;/strong>、&lt;strong>消息认证码&lt;/strong>、&lt;strong>数字签名&lt;/strong>、&lt;strong>伪随机数生成器&lt;/strong>，这六种技术称为密码学家的工具箱。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>信息安全所面临的威胁&lt;/th>
 &lt;th>受威胁的特性&lt;/th>
 &lt;th>用以应对的密码技术&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>窃听（秘密泄露）&lt;/td>
 &lt;td>机密性&lt;/td>
 &lt;td>对称密码/公钥密码&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>篡改（信息被修改）&lt;/td>
 &lt;td>完整性&lt;/td>
 &lt;td>单向散列函数/消息认证码/数字签名&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>伪装（伪装成真正的发送者）&lt;/td>
 &lt;td>认证&lt;/td>
 &lt;td>消息认证码/数字签名&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>否认（是否称自己没有做过）&lt;/td>
 &lt;td>不可否认性&lt;/td>
 &lt;td>数字签名&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table></summary></item><item><title>树、二叉树、森林</title><link>https://DBL2017.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/adt/tree_binarytree_and_forest/</link><pubDate>Mon, 27 Feb 2023 23:08:38 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/adt/tree_binarytree_and_forest/</guid><description>树的存储结构，树、二叉树和森林的转换</description><tags>ADT 树 森林 二叉树</tags><summary>&lt;p>本文主要是对普通树的存储结构、树与森林与二叉树之间的转换的总结笔记，以及学习一下回溯法和试探求最优解的方法。&lt;/p></summary></item><item><title>二叉树</title><link>https://DBL2017.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/adt/binary_tree/</link><pubDate>Sun, 05 Feb 2023 21:55:24 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/adt/binary_tree/</guid><description/><tags>ADT 数据结构 LeetCode 二叉树 遍历二叉树 线索二叉树 最优二叉树 赫夫曼树</tags><summary>&lt;p>&lt;strong>二叉树&lt;/strong>是另一种树形结构。&lt;/p>
&lt;p>二叉树的每个结点至多只有两颗子树（即二叉树中不存在度大于2的结点）。&lt;/p>
&lt;p>二叉树的子树有左右之分，是有序树的一种。&lt;/p></summary></item><item><title>树的基本概念</title><link>https://DBL2017.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/adt/tree/</link><pubDate>Thu, 02 Feb 2023 23:25:15 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/adt/tree/</guid><description>树的定义以及相关概念</description><tags>ADT LeetCode 数据结构 Tree</tags><summary>&lt;p>树形结构是一种非线性数据结构。树是以分支关系来定义的层次结构。&lt;/p>
&lt;p>树形结构广泛应用在客观世界中，比如人类族谱、社会组织结构以及计算机源码中的语法结构等。&lt;/p></summary></item><item><title>LSP</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/neovim/lsp/</link><pubDate>Fri, 18 Nov 2022 23:30:45 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/neovim/lsp/</guid><description/><tags>NVIM LSP</tags><summary>&lt;p>什么是 LSP（Language Server Protocol）？&lt;/p>
&lt;p>LSP 如何工作？&lt;/p>
&lt;p>neovim 是怎么支持 LSP 的以及要如何配置 LSP？&lt;/p>
&lt;p>nvim-lspconfig，mason 等插件的安装配置。&lt;/p></summary></item><item><title>线性表</title><link>https://DBL2017.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/adt/linear_list/</link><pubDate>Sun, 13 Nov 2022 15:39:56 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/adt/linear_list/</guid><description/><tags>线性表 数据结构 ADT</tags><summary>&lt;p>&lt;strong>线性表&lt;/strong>是最常用且最简单的一种数据结构（逻辑结构）。简言之，一个线性表是 n 个数据元素的有限序列。&lt;/p></summary></item><item><title>数据结构</title><link>https://DBL2017.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/adt/data_struct/</link><pubDate>Sat, 12 Nov 2022 19:34:20 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/adt/data_struct/</guid><description/><tags>ADT 数据结构</tags><summary>&lt;p>本章主要总结了数据结构的基本概念和定义。&lt;/p>
&lt;p>数据结构三要素：&lt;strong>逻辑结构、存储结构（物理结构）以及数据的运算（算法）。&lt;/strong>&lt;/p>
&lt;p>数据结构的存储结构有四种，分别是顺序存储、链式存储、索引存储以及散列存储。本节主要介绍前两种。&lt;/p>
&lt;p>数据的运算定义是基于逻辑结构的，而运算实现是基于存储结构的。同一逻辑结构的不同存储结构的运算的实现是不同的&lt;/p></summary></item><item><title>Linux运维书单</title><link>https://DBL2017.github.io/post/linux%E4%B9%A6%E5%8D%95/</link><pubDate>Thu, 03 Nov 2022 22:26:38 +0800</pubDate><guid>https://DBL2017.github.io/post/linux%E4%B9%A6%E5%8D%95/</guid><description/><tags>Linux运维 Linux参考书</tags><summary>&lt;p>下面介绍了Linux运维或编程一些常见的书籍。&lt;/p></summary></item><item><title>LaTex环境搭建</title><link>https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link><pubDate>Wed, 10 Aug 2022 15:55:23 +0800</pubDate><guid>https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid><description/><tags>LaTex 环境搭建</tags><summary>&lt;p>本文主要介绍的LaTex的作用、用法、以及环境搭建。可以通过neovim+vimtex+zathuura进行编写、编译以及查看tex。&lt;/p></summary></item><item><title>进程关系</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/</link><pubDate>Fri, 22 Jul 2022 21:11:24 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/</guid><description>终端简介之物理终端、模拟终端以及伪终端。终端登录以及网路登录的区别。进程组、会话以及控制终端相关概念。孤儿进程组、作业控制、终端驱动程序。fg、bg切换前后台进程。</description><tags>APUE 进程关系 终端 Unix环境高级编程</tags><summary>&lt;p>本文主要介绍了终端，包括物理终端、模拟终端以及伪终端等。&lt;/p>
&lt;p>两种不同的登录方式、即终端登录和网络登录。&lt;/p>
&lt;p>重点是进程组、会话以及控制终端之间的联系。&lt;/p>
&lt;p>最后是作业控制，作业控制是目前很多类Unix系统都支持的功能。&lt;/p>
&lt;p>介绍了shell程序是如何实现作业控制的以及shell运行程序的方式。&lt;/p></summary></item><item><title>华杉讲透《孙子兵法》(读客熊猫君出品。企业家狂热追捧！这回彻底读懂孙子兵法！) (华杉)</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/kindle/kindle%E7%AC%94%E8%AE%B0/%E5%AD%99%E5%AD%90%E5%85%B5%E6%B3%95/</link><pubDate>Sat, 16 Jul 2022 08:13:13 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/kindle/kindle%E7%AC%94%E8%AE%B0/%E5%AD%99%E5%AD%90%E5%85%B5%E6%B3%95/</guid><description/><tags>Kindle 孙子兵法</tags><summary/></item><item><title>Lua变量类型(三)</title><link>https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/lua%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</link><pubDate>Wed, 06 Jul 2022 16:33:22 +0800</pubDate><guid>https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/lua%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</guid><description/><tags>Lua Lua变量</tags><summary>&lt;p>Lua是动态类型语言。定义变量时不需要指定类型，可以根据变量的值来区分变量类型。&lt;/p>
&lt;p>Lua一种8中基础类型，分别是&lt;code>Nil&lt;/code>、&lt;code>Boolean&lt;/code>、&lt;code>Number&lt;/code>、&lt;code>String&lt;/code>、&lt;code>Userdata&lt;/code>、&lt;code>Function&lt;/code>、&lt;code>Thread&lt;/code>、&lt;code>Table&lt;/code>。&lt;/p>
&lt;p>函数&lt;code>type&lt;/code>可以根据变量值来获取变量的类型。&lt;/p></summary></item><item><title>Lua环境搭建和常识（二）</title><link>https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/lua%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%B8%B8%E8%AF%86/</link><pubDate>Wed, 06 Jul 2022 14:27:00 +0800</pubDate><guid>https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/lua%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%B8%B8%E8%AF%86/</guid><description/><tags>Lua Lua环境搭建</tags><summary>&lt;p>Lua开发环境的搭建以及如何执行，Lua中代码块的定义，以及如何将直接执行Lua脚本。&lt;/p></summary></item><item><title>Lua简介(一)</title><link>https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/lua%E7%AE%80%E4%BB%8B/</link><pubDate>Mon, 04 Jul 2022 15:18:33 +0800</pubDate><guid>https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/lua%E7%AE%80%E4%BB%8B/</guid><description/><tags>Lua Lua简介</tags><summary>&lt;p>Lua是一种强大、高效、轻量、可嵌入的脚本语言。它支持过程式编程、面向对象编程、函数式编程、数据驱动编程和数据描述。&lt;/p>
&lt;p>Lua将简单的过程语法与基于关联数组和可扩展语义的强大数据描述结构相结合。&lt;/p>
&lt;p>Lua是动态类型的，通过使用基于&lt;strong>寄存器的虚拟机&lt;/strong>解释字节码来运行，并具有自动内存管理和增量垃圾收集功能，是配置、脚本和快速原型设计的理想选择。&lt;/p></summary></item><item><title>进程控制</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</link><pubDate>Sun, 26 Jun 2022 12:53:53 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid><description/><tags>APUE Unix环境高级编程 进程控制</tags><summary>&lt;p>&lt;code>fork&lt;/code>创建子进程之后资源如何分配？&lt;/p>
&lt;p>运行中的进程的有效用户和程序文件的所属用户的区别？&lt;/p>
&lt;p>运行中的进程都有什么权限？&lt;/p>
&lt;p>函数&lt;code>system&lt;/code>是否成功执行？&lt;/p>
&lt;p>什么是进程会计？&lt;/p></summary></item><item><title>进程环境</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 23 Apr 2022 16:34:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</guid><description/><tags>APUE Unix 进程 Unix环境高级编程</tags><summary>&lt;p>进程运行时，&lt;code>main&lt;/code>函数如何被调用？&lt;/p>
&lt;p>命令行参数如何传递给进程？&lt;/p>
&lt;p>存储空间的布局以及如何分配？&lt;/p>
&lt;p>进程如何使用环境变量？&lt;/p>
&lt;p>怎么限制进程使用的资源？&lt;/p></summary></item><item><title>系统数据文件和信息</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/</link><pubDate>Tue, 05 Apr 2022 12:21:20 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/</guid><description>本文主要介绍了口令文件/etc/passwd、阴影口令/etc/shadow、组文件/etc/group等内容格式以及解析方式，还是登录账户标志wtmp、utmp以及时间(timeval_t、)、时钟CLOCK等信息。</description><tags>APUE Unix环境高级编程 阴影口令 Shadow Timeval Time_t 时钟 Group</tags><summary>&lt;p>口令文件&lt;code>/etc/passwd&lt;/code>和组文件&lt;code>/etc/group&lt;/code>经常被多个进程频繁使用。用户每次登录Linux和使用&lt;code>ls&lt;/code>命令都会访问口令文件。&lt;/p>
&lt;p>除了直接访问文件之外，系统通过一些接口来对外提供信息，比如系统标识函数、时间和日期函数。&lt;/p></summary></item><item><title>标准IO</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%A0%87%E5%87%86io/</link><pubDate>Wed, 23 Mar 2022 20:56:44 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%A0%87%E5%87%86io/</guid><description>标准IO是以流为基本对象的。</description><tags>APUE Unix 文件 标准IO Unix环境高级编程</tags><summary>&lt;p>标准I/O库由ISO C标准制定的。标准I/O库相对于系统I/O处理了很多细节，比如缓冲区分配、以优化的块大小执行I/O（这个数据存储在&lt;code>stat&lt;/code>结构体中的&lt;code>st_blksize&lt;/code>字段）等。&lt;/p>
&lt;p>系统I/O是以文件描述符来作为基础展开的，而标准I/O是围绕流进行的，打开或创建文件时会将流和文件关联起来。&lt;/p>
&lt;p>获取与流相关的文件描述符可以使用函数&lt;code>fileno()&lt;/code>。&lt;/p>
&lt;p>&lt;strong>流和文件相关联为文件流，流和内存关联起来为内存流。&lt;/strong>&lt;/p></summary></item><item><title>文件和目录</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</link><pubDate>Fri, 04 Mar 2022 23:16:53 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</guid><description>描述文件属性的基本结构`struct stat`，文件权限判断，设置用户ID位，设置组ID位以及粘着位等，其次进程的实际用户ID、有效用户ID、有效组ID、附属组ID以及进程访问文件权限检测，其次是文件的相关操作函数，比如access()，chmod()，umask()，chown()等，之后是软链接、硬链接，最后是创建删除以及读写目录及其相关接口mkdir、chdir等。</description><tags>APUE 文件 目录 粘着位 文件权限 有效用户 附属组 访问权限检测 有效组</tags><summary>&lt;p>本文描述了文件的属性，主要是&lt;code>struct stat&lt;/code>结构体中的相关字段，比如文件所有者ID、文件所属组ID、块大小等。&lt;/p>
&lt;p>其次详细描述了文件权限的相关内容，包括文件的基本权限、进程创建、读写文件的权限验证规则以及修改文件权限的相关接口等。&lt;/p>
&lt;p>最后是文件系统简介，包含&lt;code>inode&lt;/code>、目录项等，以及文件时间，创建删除以及读写目录等。&lt;/p></summary></item><item><title>文件IO</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6io/</link><pubDate>Thu, 24 Feb 2022 22:29:11 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6io/</guid><description>Unix环境下的非缓冲IO</description><tags>APUE Unix 文件IO Unix环境高级编程</tags><summary>&lt;p>本节主要介绍不带缓冲的I/O（unbuffered I/O），不带缓冲指的是每个&lt;code>read&lt;/code>和&lt;code>write&lt;/code>都会调用内核中的一个系统调用。&lt;/p>
&lt;p>不带缓冲的I/O函数不是ISO C的标准函数，但是是符合POSIX的。&lt;/p>
&lt;p>原子操作在多进程之间贡献文件变得相当重要。&lt;/p>
&lt;p>主要涉及的函数有&lt;code>oepn, read, write, lseek, close; dup, fcntl, sync, fsync, ioctl&lt;/code>。&lt;/p></summary></item><item><title>Mermaid使用方式</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/mermaid/</link><pubDate>Wed, 23 Feb 2022 17:57:18 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/mermaid/</guid><description/><tags>Mermaid</tags><summary>&lt;p>&lt;code>Mermaid&lt;/code>是基于&lt;code>Javascript&lt;/code>的一个图标可视化工具，可以使您基于代码创建图表。&lt;/p>
&lt;p>&lt;code>Mermaid&lt;/code>的一个在线编辑站，&lt;a href="https://mermaid-js.github.io/mermaid-live-editor">在线编辑Mermaid&lt;/a>。&lt;/p></summary></item><item><title>vim 配置文件</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/vim/vim_%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link><pubDate>Wed, 23 Feb 2022 15:33:17 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/vim/vim_%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid><description/><tags>Vim配置 Tool</tags><summary>&lt;p>下面是vim的配置文件，使用时需要将其拷贝到用户目录下，然后安装&lt;code>vundle&lt;/code>插件管理器（&lt;code>git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim&lt;/code>），最后启动&lt;code>vim&lt;/code>执行&lt;code>PluginInstall&lt;/code>。&lt;/p>
&lt;p>当前已经配置的插件有&lt;code>NerdTree&lt;/code>、&lt;code>YCM&lt;/code>、&lt;code>ALE&lt;/code>、&lt;code>airline&lt;/code>等&lt;/p></summary></item><item><title>编写Recipe</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/%E7%BC%96%E5%86%99recipe/</link><pubDate>Thu, 27 Jan 2022 23:46:08 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/%E7%BC%96%E5%86%99recipe/</guid><description/><tags>Makefile</tags><summary>&lt;p>规则中的&lt;code>recipe&lt;/code>由一条或多条&lt;code>shell&lt;/code>命令组成， 并会按照顺序执行。&lt;/p>
&lt;p>通常，这些命令执行的结果就是更新&lt;code>target&lt;/code>。&lt;/p>
&lt;p>Linux用户可以使用多种不同的&lt;code>shell&lt;/code>程序，但&lt;code>Makefile&lt;/code>中的&lt;code>recipe&lt;/code>是由&lt;code>/bin/sh&lt;/code>来解释。&lt;/p></summary></item><item><title>Makefile规则</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/makefile%E8%A7%84%E5%88%99/</link><pubDate>Thu, 27 Jan 2022 23:10:05 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/makefile%E8%A7%84%E5%88%99/</guid><description>编写规则</description><tags>Makefile</tags><summary>&lt;p>&lt;code>Makefile&lt;/code>中的规则是为了说明何时以及如何生成&lt;code>target&lt;/code>，规则列出了&lt;code>target&lt;/code>的&lt;code>prerequisites&lt;/code>和&lt;code>recipe&lt;/code>。&lt;/p></summary></item><item><title>编写Makefile</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/%E7%BC%96%E5%86%99makefile/</link><pubDate>Thu, 27 Jan 2022 23:09:37 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/%E7%BC%96%E5%86%99makefile/</guid><description>编写Makefile</description><tags>Makefile</tags><summary>&lt;p>&lt;code>Makefiles&lt;/code>中包含5种内容，分别是显式规则、隐含规则、变量定义、指令以及注释。&lt;/p></summary></item><item><title>Makefile简介</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/makefile%E7%AE%80%E4%BB%8B/</link><pubDate>Thu, 27 Jan 2022 23:08:58 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/makefile%E7%AE%80%E4%BB%8B/</guid><description>Makefile简介</description><tags>Makefile</tags><summary>&lt;p>&lt;code>Makefile&lt;/code>文件告诉&lt;code>make&lt;/code>如何编译和链接一个程序。&lt;/p></summary></item><item><title>GNU Make简介</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/gnu-make%E7%AE%80%E4%BB%8B/</link><pubDate>Thu, 27 Jan 2022 23:07:25 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/gnu-make%E7%AE%80%E4%BB%8B/</guid><description>GNU Make是一个可以自动运行shell命令并帮助执行重复任务的程序。它通常用于将文件转换成其他形式，例如将源代码文件编译成程序或库。它通过跟踪先决条件和执行命令层次结构来生成目标来实现这一点。</description><tags>Makefile</tags><summary>&lt;p>&lt;code>make&lt;/code>能够自动识别大型应用程序中哪些部分需要重新编译，并且会自动编译它们。&lt;/p>
&lt;p>&lt;code>make&lt;/code>并不局限于&lt;code>C&lt;/code>语言，任何语言的编译器可以通过&lt;code>shell&lt;/code>命令执行，那就可以使用&lt;code>make&lt;/code>。&lt;/p>
&lt;p>&lt;code>make&lt;/code>不仅仅用于应用程序，它也适用于其他任务，该任务中的某些文件必须在其他文件发生改动时自动更新。&lt;/p></summary></item><item><title>网络工程师（二）|数据通信基础</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/networkengineer/2_data_communication/</link><pubDate>Sun, 26 Sep 2021 23:12:52 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/networkengineer/2_data_communication/</guid><description/><tags>网络工程师 数据通信 信道</tags><summary>&lt;p>计算机网络采用数据通信的方式传输数据。数据通信和电话网络中的语音通信不同，也和无线电广播通信不同，它有其自身的规律和特点。&lt;/p></summary></item><item><title>网络工程师（一）|计算机网络概论</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/networkengineer/1_network_outline/</link><pubDate>Fri, 10 Sep 2021 00:23:16 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/networkengineer/1_network_outline/</guid><description/><tags>网络工程师 网络分类 ISO OSI TCP/IP参考模型 网络拓扑结构</tags><summary>&lt;p>“计算机网络”这一术语是指由通信线路互相连接的许多&lt;strong>自主工作&lt;/strong>的计算机构成的集合体。这里强调的是自主工作，用来和多终端分时系统区分。多终端分时系统只是终端和主机之间的交互，终端本身不具有计算资源。在计算机网络中的各个计算机本身拥有计算资源，能独立工作，能完成一定的计算任务。同时用户还可以共享网络中其他计算机的资源。&lt;/p></summary></item><item><title>定点数和浮点数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/networkengineer/fixed_and_float/</link><pubDate>Wed, 08 Sep 2021 09:54:40 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/networkengineer/fixed_and_float/</guid><description>定点数, 浮点数</description><tags>网络工程师 定点数 浮点数</tags><summary>&lt;p>小数点位置默认固定的数成为定点数。使用阶码和尾数表示的范围更大的数成为浮点数。&lt;/p></summary></item><item><title>浮点数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/networkengineer/float/</link><pubDate>Tue, 07 Sep 2021 20:31:29 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/networkengineer/float/</guid><description>浮点数</description><tags>网络工程师 浮点数</tags><summary>&lt;p>浮点数表示对形如$V=x*2^y$的有理数进行编码&lt;/p></summary></item><item><title>变量作用域、存储类型以及extern关键字</title><link>https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8Aextern%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Tue, 17 Aug 2021 22:22:18 +0800</pubDate><guid>https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8Aextern%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description/><tags>C语言 作用域 Extern</tags><summary>&lt;p>本文主要介绍C语言的变量作用域、以及不同位置声明定义的变量的存储类型，extern关键字在声明函数和变量时的不同含义。&lt;/p></summary></item><item><title>ubus接口调用解析时遇到的一点问题</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/ubus%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E8%A7%A3%E6%9E%90/</link><pubDate>Sat, 07 Aug 2021 22:06:38 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/ubus%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E8%A7%A3%E6%9E%90/</guid><description/><tags>OpenWrt Ubus BLOBMSG_TYPE_TABLE TABLE_TYPE_ARRAY BLOBMSG_TYPE_INT32 BLOBMSG_TYPE_INT64</tags><summary>&lt;p>本文主要描述在openwrt环境下，使用&lt;code>blobmsg_parse&lt;/code>接口解析双层&lt;code>BLOBMSG_TYPE_TABLE&lt;/code>出现的Segmentation fault问题。带解析的数据来源于&lt;code>ubus call system info&lt;/code>返回的值。&lt;/p></summary></item><item><title>vim 使用指南</title><link>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/vim/vim-guide/</link><pubDate>Fri, 06 Aug 2021 11:57:50 +0800</pubDate><guid>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/vim/vim-guide/</guid><description/><tags>Tool Vim 编辑器</tags><summary>&lt;p>vim使用指南、相关配置以及插件管理vim-plug、Vundle、NERDTree、NERD Commenter、YouCompleteMe以及配色方案solarized和molokai等&lt;/p></summary></item><item><title>程序的交流和通信</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%A4%E6%B5%81%E5%92%8C%E9%80%9A%E4%BF%A1/</link><pubDate>Sat, 30 May 2020 22:23:36 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%A4%E6%B5%81%E5%92%8C%E9%80%9A%E4%BF%A1/</guid><description>主要介绍系统级I/O，TCP/IP的socket通信以及进程之间的通信</description><tags>进程通信 网络编程 I/O CSAPP</tags><summary>&lt;p>下图展示了各种I/O包： 
 &lt;a data-fancybox="gallery" href="10-16.png">
 &lt;img class="mx-auto" alt="" src="10-16.png" />
 &lt;/a>
 &lt;/p></summary></item><item><title>虚拟内存</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link><pubDate>Tue, 26 May 2020 14:07:37 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid><description>虚拟内存是系统对物理内存的一种映射，进程的内存分配是基于虚拟内存的</description><tags>虚拟内存 CSAPP</tags><summary>&lt;p>一个系统中的进程与其他进程共享CPU和主存资源的。&lt;/p>
&lt;p>为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做&lt;strong>虚拟内存VM&lt;/strong>。&lt;/p>
&lt;p>虚拟内存是硬件异常，硬件地址，主存，磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的，一致的和私有的地址空间。&lt;/p>
&lt;p>虚拟内存提供了三个重要的能力：&lt;/p>
&lt;ol>
&lt;li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。&lt;/li>
&lt;li>它为每个进程提供了一致的地址空间，从而简化了内存管理。&lt;/li>
&lt;li>它保护了每个进程的地址空间不被其他进程破坏。&lt;/li>
&lt;/ol></summary></item><item><title>异常控制流</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</link><pubDate>Sun, 24 May 2020 14:07:37 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</guid><description>异常控制流，创建以及控制进程，信号的发送和接收</description><tags>异常 进程 地址空间 CSAPP</tags><summary>&lt;p>从给处理器加电开始，直到断电为止，程序计数器假设一个值的序列$a_0,a_1,&amp;hellip;,a_{n-1}$，其中，每个$a_k$是某个相应指令$I_k$的地址。每次从$a_k$到$a_{k+1}$的过渡称为&lt;strong>控制转移&lt;/strong>。这样的控制转移序列叫做处理器的控制流。&lt;/p></summary></item><item><title>链接</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E9%93%BE%E6%8E%A5/</link><pubDate>Sun, 17 May 2020 13:15:19 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E9%93%BE%E6%8E%A5/</guid><description>链接是将各种代码和数据片段收集并组合成一个单一文件的过程</description><tags>链接 CSAPP</tags><summary>&lt;p>&lt;strong>链接&lt;/strong>是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被夹在到内存中运行。链接可以执行于&lt;strong>编译&lt;/strong>时，也就是在源代码被翻译成机器代码时；也可以执行于&lt;strong>加载&lt;/strong>时，也就是在程序被&lt;strong>加载器&lt;/strong>加载到内存并执行时；甚至执行于&lt;strong>运行&lt;/strong>时，也就是由应用程序来执行。&lt;/p>
&lt;p>链接时由&lt;strong>链接器&lt;/strong>程序自动执行的。链接器在软件开发中扮演这一个关键的角色，因为它们使得&lt;strong>分离编译&lt;/strong>称为可能。&lt;/p>
&lt;p>传统静态链接，加载时共享库的动态链接，以及运行时的共享库的动态链接。&lt;/p></summary></item><item><title>存储器层次结构</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</link><pubDate>Thu, 07 May 2020 21:45:11 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</guid><description>基本存储技术(RAM、ROM以及磁盘)的简介以及存储器山</description><tags>存储器 CSAPP</tags><summary>&lt;p>&lt;strong>存储器系统&lt;/strong>是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU寄存器保存着最常用的数据。靠近CPU的小的、快速的&lt;strong>高速缓存存储器&lt;/strong>（cache memory）作为一部分存储在相对慢速的主存储器中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘通常又作为存储在通过网络连接的其他机器的存盘或磁带上的数据的缓冲区域。&lt;/p></summary></item><item><title>程序的机器级表示</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</link><pubDate>Sat, 18 Apr 2020 11:53:04 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</guid><description>机器级编码，以及AT&amp;T汇编代码的简要介绍，从C语言转换为汇编代码</description><tags>CSAPP AT&amp;T 汇编 GCC</tags><summary>&lt;p>计算机执行&lt;strong>机器代码&lt;/strong>，用字节序列编码低级的操作，包括数据处理、管理内存、读写存储设备上的数据、以及利用网络通信。编译器基于编程语言的规则、目标及其的指令集和操作系统遵循的管理，经过一系列阶段生成机器代码。GCC C语言编译器以&lt;strong>汇编代码&lt;/strong>的形式产生输出，汇编代码是机器代码的文本表示，给出程序中每一条指令。&lt;/p></summary></item><item><title>二进制加法和数值加法的对应关系</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%92%8C%E6%95%B0%E5%80%BC%E5%8A%A0%E6%B3%95%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</link><pubDate>Sat, 18 Apr 2020 11:34:00 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%92%8C%E6%95%B0%E5%80%BC%E5%8A%A0%E6%B3%95%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</guid><description>CS-APP中的信息的表示和处理章节的阅读笔记，可以用来回顾</description><tags>CSAPP 二进制加法 数值加法 全加器 半加器</tags><summary>&lt;h2 id="二进制加法">
 &lt;a href="#%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%8a%a0%e6%b3%95">
 二进制加法&lt;/a>
&lt;/h2>&lt;p>首先，单个位的二进制相加结果如下表所示：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">A&lt;/th>
 &lt;th style="text-align: center">B&lt;/th>
 &lt;th style="text-align: right">SUM&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">0&lt;/td>
 &lt;td style="text-align: center">0&lt;/td>
 &lt;td style="text-align: right">0&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">0&lt;/td>
 &lt;td style="text-align: center">1&lt;/td>
 &lt;td style="text-align: right">1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">1&lt;/td>
 &lt;td style="text-align: center">0&lt;/td>
 &lt;td style="text-align: right">1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">1&lt;/td>
 &lt;td style="text-align: center">1&lt;/td>
 &lt;td style="text-align: right">0&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>通过这个结果表，明显可以看出这是一个单个位的&lt;strong>异或运算&lt;/strong>，所以说不考虑进位的情况下，二进制加法就是异或运算。&lt;/p></summary></item><item><title>关于IEEE754浮点数的一点思考</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%85%B3%E4%BA%8Eieee754%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</link><pubDate>Sat, 18 Apr 2020 11:23:50 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%85%B3%E4%BA%8Eieee754%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</guid><description>IEEE754定义的浮点数的详细介绍，以及自己的一些理解</description><tags>CSAPP IEEE754 浮点数</tags><summary/></item><item><title>信息的表示和处理</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link><pubDate>Fri, 17 Apr 2020 00:04:10 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid><description>CS-APP中的信息的表示和处理章节的阅读笔记，可以用来回顾</description><tags>CSAPP 整数编码 浮点数 IEEE754</tags><summary/></item><item><title>关于我</title><link>https://DBL2017.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://DBL2017.github.io/about/</guid><description>专注于物联网行业，包括但不限于5G网关、Linux系统、项目管理以及软件架构</description><summary/></item><item><title>归档</title><link>https://DBL2017.github.io/archives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://DBL2017.github.io/archives/</guid><description>Android资深工程师 ，Go和Java打杂师，《Android Gradle权威指南》作者，Android官方技术文档译者</description><summary/></item><item><title>搜索</title><link>https://DBL2017.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://DBL2017.github.io/search/</guid><description>搜索页面</description><summary/></item></channel></rss>