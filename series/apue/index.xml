<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>APUE on 生如夏花的博客</title><link>https://DBL2017.github.io/series/apue/</link><description>Recent content in APUE on 生如夏花的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 18 Aug 2024 11:15:51 +0800</lastBuildDate><atom:link href="https://DBL2017.github.io/series/apue/index.xml" rel="self" type="application/rss+xml"/><item><title>文件IO</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6io/</link><pubDate>Thu, 24 Feb 2022 22:29:11 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6io/</guid><description>Unix环境下的非缓冲IO</description><tags>APUE Unix 文件IO Unix环境高级编程</tags><summary>&lt;p>本节主要介绍不带缓冲的I/O（unbuffered I/O），不带缓冲指的是每个&lt;code>read&lt;/code>和&lt;code>write&lt;/code>都会调用内核中的一个系统调用。&lt;/p>
&lt;p>不带缓冲的I/O函数不是ISO C的标准函数，但是是符合POSIX的。&lt;/p>
&lt;p>原子操作在多进程之间贡献文件变得相当重要。&lt;/p>
&lt;p>主要涉及的函数有&lt;code>oepn, read, write, lseek, close; dup, fcntl, sync, fsync, ioctl&lt;/code>。&lt;/p></summary></item><item><title>文件和目录</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</link><pubDate>Fri, 04 Mar 2022 23:16:53 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</guid><description>描述文件属性的基本结构`struct stat`，文件权限判断，设置用户ID位，设置组ID位以及粘着位等，其次进程的实际用户ID、有效用户ID、有效组ID、附属组ID以及进程访问文件权限检测，其次是文件的相关操作函数，比如access()，chmod()，umask()，chown()等，之后是软链接、硬链接，最后是创建删除以及读写目录及其相关接口mkdir、chdir等。</description><tags>APUE 文件 目录 粘着位 文件权限 有效用户 附属组 访问权限检测 有效组</tags><summary>&lt;p>本文描述了文件的属性，主要是&lt;code>struct stat&lt;/code>结构体中的相关字段，比如文件所有者ID、文件所属组ID、块大小等。&lt;/p>
&lt;p>其次详细描述了文件权限的相关内容，包括文件的基本权限、进程创建、读写文件的权限验证规则以及修改文件权限的相关接口等。&lt;/p>
&lt;p>最后是文件系统简介，包含&lt;code>inode&lt;/code>、目录项等，以及文件时间，创建删除以及读写目录等。&lt;/p></summary></item><item><title>标准IO</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%A0%87%E5%87%86io/</link><pubDate>Wed, 23 Mar 2022 20:56:44 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%A0%87%E5%87%86io/</guid><description>标准IO是以流为基本对象的。</description><tags>APUE Unix 文件 标准IO Unix环境高级编程</tags><summary>&lt;p>标准I/O库由ISO C标准制定的。标准I/O库相对于系统I/O处理了很多细节，比如缓冲区分配、以优化的块大小执行I/O（这个数据存储在&lt;code>stat&lt;/code>结构体中的&lt;code>st_blksize&lt;/code>字段）等。&lt;/p>
&lt;p>系统I/O是以文件描述符来作为基础展开的，而标准I/O是围绕流进行的，打开或创建文件时会将流和文件关联起来。&lt;/p>
&lt;p>获取与流相关的文件描述符可以使用函数&lt;code>fileno()&lt;/code>。&lt;/p>
&lt;p>&lt;strong>流和文件相关联为文件流，流和内存关联起来为内存流。&lt;/strong>&lt;/p></summary></item><item><title>系统数据文件和信息</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/</link><pubDate>Tue, 05 Apr 2022 12:21:20 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/</guid><description>本文主要介绍了口令文件/etc/passwd、阴影口令/etc/shadow、组文件/etc/group等内容格式以及解析方式，还是登录账户标志wtmp、utmp以及时间(timeval_t、)、时钟CLOCK等信息。</description><tags>APUE Unix环境高级编程 阴影口令 Shadow Timeval Time_t 时钟 Group</tags><summary>&lt;p>口令文件&lt;code>/etc/passwd&lt;/code>和组文件&lt;code>/etc/group&lt;/code>经常被多个进程频繁使用。用户每次登录Linux和使用&lt;code>ls&lt;/code>命令都会访问口令文件。&lt;/p>
&lt;p>除了直接访问文件之外，系统通过一些接口来对外提供信息，比如系统标识函数、时间和日期函数。&lt;/p></summary></item><item><title>进程环境</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 23 Apr 2022 16:34:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</guid><description/><tags>APUE Unix 进程 Unix环境高级编程</tags><summary>&lt;p>进程运行时，&lt;code>main&lt;/code>函数如何被调用？&lt;/p>
&lt;p>命令行参数如何传递给进程？&lt;/p>
&lt;p>存储空间的布局以及如何分配？&lt;/p>
&lt;p>进程如何使用环境变量？&lt;/p>
&lt;p>怎么限制进程使用的资源？&lt;/p></summary></item><item><title>进程控制</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</link><pubDate>Sun, 26 Jun 2022 12:53:53 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid><description/><tags>APUE Unix环境高级编程 进程控制</tags><summary>&lt;p>&lt;code>fork&lt;/code>创建子进程之后资源如何分配？&lt;/p>
&lt;p>运行中的进程的有效用户和程序文件的所属用户的区别？&lt;/p>
&lt;p>运行中的进程都有什么权限？&lt;/p>
&lt;p>函数&lt;code>system&lt;/code>是否成功执行？&lt;/p>
&lt;p>什么是进程会计？&lt;/p></summary></item><item><title>进程关系</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/</link><pubDate>Fri, 22 Jul 2022 21:11:24 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/</guid><description>终端简介之物理终端、模拟终端以及伪终端。终端登录以及网路登录的区别。进程组、会话以及控制终端相关概念。孤儿进程组、作业控制、终端驱动程序。fg、bg切换前后台进程。</description><tags>APUE 进程关系 终端 Unix环境高级编程</tags><summary>&lt;p>本文主要介绍了终端，包括物理终端、模拟终端以及伪终端等。&lt;/p>
&lt;p>两种不同的登录方式、即终端登录和网络登录。&lt;/p>
&lt;p>重点是进程组、会话以及控制终端之间的联系。&lt;/p>
&lt;p>最后是作业控制，作业控制是目前很多类Unix系统都支持的功能。&lt;/p>
&lt;p>介绍了shell程序是如何实现作业控制的以及shell运行程序的方式。&lt;/p></summary></item><item><title>信号概述</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0/</link><pubDate>Wed, 10 Jan 2024 21:10:43 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程</tags><summary>&lt;p>信号是软件中断。&lt;/p>
&lt;p>信号提供了一种处理异步事件的方法。&lt;/p>
&lt;p>信号用于大多数复杂的应用程序中。&lt;/p>
&lt;p>Unix系统的早期版本就已经提供了信号机制，但不可靠。POSIX.1对可靠信号例程进行了标准化。&lt;/p></summary></item><item><title>不可靠信号的相关问题</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 12 Jan 2024 21:10:43 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程 不可靠信号 信号丢失</tags><summary>&lt;p>不可靠信号指的是信号可能会丢失，不支持信号阻塞，不能控制是否重启中断的系统调用等等。&lt;/p>
&lt;p>下面是不可靠信号可能会出现的问题：&lt;/p></summary></item><item><title>可靠信号</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7/</link><pubDate>Sun, 14 Jan 2024 23:18:50 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程 可靠信号 信号递送 Kill Pause Alarm</tags><summary>&lt;p>可靠信号的处理有两个过程如下：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>信号产生&lt;/strong>：当这些事件（&lt;strong>硬件异常（如除以0）、软件条件（如alarm定时器超时）、终端产生的信号或调用&lt;code>kill&lt;/code>函数&lt;/strong>）发生时，内核会为进程产生一个信号，同时在进程表中设置一个标志。&lt;/li>
&lt;li>&lt;strong>信号递送&lt;/strong>：内核使&lt;strong>目标进程对该信号作出反应&lt;/strong>称为信号递送：或是改变目标进程的执行状态（默认动作），或是开始执行信号处理程序，或两者都是。&lt;/li>
&lt;/ol></summary></item><item><title>信号集及相关函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 16 Jan 2024 23:18:13 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程 信号集 Sigset_t</tags><summary>&lt;p>&lt;strong>信号集&lt;/strong>（&lt;code>sigset_t&lt;/code>）是表示多个信号的数据类型。&lt;/p>
&lt;p>不同的信号编号可能会超过一个整型量的位数，所以不能用整型量中的一位代表一个信号。&lt;/p>
&lt;p>POSIX.1定义数据类型&lt;code>sigset_t&lt;/code>用以表示信号集，并定义了信号的操作函数。&lt;/p></summary></item><item><title>线程的全生命周期</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Fri, 06 Oct 2023 14:54:11 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>线程的创建、运行、销毁、释放空间等全生命周期</description><tags>APUE Unix 线程 Pthread</tags><summary>&lt;p>多线程与处理器的核心数无关，即使单核处理器也可以运行多线程。&lt;/p>
&lt;p>多线程的设计有很多优点：&lt;/p>
&lt;ol>
&lt;li>简化处理异步事件&lt;/li>
&lt;li>共享内存和文件描述符&lt;/li>
&lt;li>提高程序吞吐量&lt;/li>
&lt;li>提高交互程序的响应等等&lt;/li>
&lt;/ol></summary></item><item><title>线程同步之读写锁</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Mon, 16 Oct 2023 23:07:02 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>线程同步方式之一，读写锁</description><tags>APUE 线程 线程同步 读写锁 Unix Pthread</tags><summary>&lt;p>读写锁也称为共享互斥锁，具有3种状态：&lt;strong>读模式下的加锁状态&lt;/strong>、&lt;strong>写模式下的加锁状态&lt;/strong>、&lt;strong>不加锁状态&lt;/strong>。&lt;/p>
&lt;p>一次仅有一个线程可以占有写模式下的读写锁，但是多个线程可以同时占有读模式下的读写锁。&lt;/p>
&lt;p>读写锁非常&lt;strong>适合于对数据结构读的次数远大于写的情况&lt;/strong>。&lt;/p>
&lt;p>与互斥量相比，读写锁（reader-writer lock）运行更高的并行性。&lt;/p></summary></item><item><title>线程同步之互斥量</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F/</link><pubDate>Sat, 14 Oct 2023 14:29:41 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F/</guid><description>线程的几种同步方式，包括信号量、互斥量、读写锁、自旋锁、屏障等</description><tags>APUE Unix 线程 线程同步 互斥量 死锁 Pthread</tags><summary>&lt;p>当多个线程共享相同的内存时，需要确保每个线程看到的都是一致的数据视图。&lt;/p>
&lt;p>&lt;strong>当一个线程可以修改的变量，其他线程也可以读取或修改的时候&lt;/strong>，就需要对这些线程进行&lt;strong>同步&lt;/strong>，确保访问变量时不会得到无效的值。&lt;/p></summary></item><item><title>线程同步之条件变量</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Sun, 22 Oct 2023 21:05:40 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description>线程同步的方式之一，条件变量</description><tags>APUE 线程 线程同步 同步 条件变量 Unix Pthread</tags><summary>&lt;p>&lt;strong>互斥量&lt;/strong>防止多个线程同时访问同一共享变量。&lt;/p>
&lt;p>&lt;strong>条件变量&lt;/strong>允许一个线程就某个&lt;strong>条件&lt;/strong>（共享变量）的变化状态通知其他线程，并让其他线程等待（阻塞于）该通知。&lt;/p>
&lt;p>&lt;strong>条件变量与互斥量一起使用，允许线程以无竞争的方式等待特定的条件发生。&lt;/strong>&lt;/p></summary></item><item><title>线程属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7/</link><pubDate>Wed, 31 Jan 2024 22:57:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7/</guid><description>系统对线程的限制、通过属性对象控制线程、线程的同步属性</description><tags>APUE 线程 线程属性 线程限制 Pthread_attr_t</tags><summary>&lt;p>SUS定义了一些系统层面上对于线程的限制，比如进程可以创建的最大线程数、线程栈可用的最小字节数等等。&lt;/p>
&lt;p>&lt;code>pthread&lt;/code>接口允许我们传入&lt;strong>线程或同步对象的属性&lt;/strong>来调节线程或同步对象的行为。&lt;/p></summary></item><item><title>线程同步之屏障</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C/</link><pubDate>Fri, 17 Nov 2023 20:45:04 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C/</guid><description>线程同步的另一种方式，屏障</description><tags>APUE 线程 线程同步 屏障 Pthread</tags><summary>&lt;p>屏障（barrier）是用户协调多个线程并行工作的同步机制。&lt;/p>
&lt;p>&lt;strong>屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。&lt;/strong>&lt;/p>
&lt;p>&lt;code>pthread_join&lt;/code>是一种特殊的屏障，允许一个线程等待，直到另一个线程退出。&lt;/p></summary></item><item><title>线程同步之互斥量属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F%E5%B1%9E%E6%80%A7/</link><pubDate>Fri, 23 Feb 2024 23:42:59 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F%E5%B1%9E%E6%80%A7/</guid><description>线程的同步类型属性，通过设置属性来控制线程的同步行为</description><tags>线程属性 互斥量属性 健壮 类型 进程共享</tags><summary>&lt;p>本文主要介绍了线程同步对象互斥量的相关属性，并通过代码验证了这些属性。&lt;/p>
&lt;p>通过这些线程同步对象的属性可以控制不同线程在使用互斥量进行同步时的行为。&lt;/p></summary></item><item><title>线程同步之读写锁属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%B1%9E%E6%80%A7/</link><pubDate>Sat, 24 Feb 2024 17:50:34 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%B1%9E%E6%80%A7/</guid><description>线程的读写锁同步属性，用于控制线程同步时的行为</description><tags>读写锁 同步属性 进程共享</tags><summary>&lt;p>本文介绍了线程的同步对象读写锁的属性，通过读写锁属性可以控制在线程之间使用读写锁同步时的行为。&lt;/p>
&lt;p>线程的读写锁仅支持&lt;strong>进程共享&lt;/strong>属性。&lt;/p></summary></item><item><title>线程同步之条件变量属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7/</link><pubDate>Sun, 25 Feb 2024 10:19:46 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7/</guid><description>条件变量属性</description><tags>同步属性 条件变量 进程共享 时钟属性</tags><summary>&lt;p>线程条件变量可以是线程&lt;strong>以非竞争的方式同步执行&lt;/strong>。&lt;/p>
&lt;p>线程条件变量支持两个属性：&lt;strong>进程共享&lt;/strong>与&lt;strong>时钟属性&lt;/strong>。&lt;/p>
&lt;p>进程共享属性可以使条件变量被多进程的线程使用。&lt;/p>
&lt;p>时钟属性控制计算&lt;code>pthread_cond_timedwait()&lt;/code>函数的超时参数（&lt;code>tsptr&lt;/code>）时采用哪个时钟。&lt;/p></summary></item><item><title>线程同步之屏障属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C%E5%B1%9E%E6%80%A7/</link><pubDate>Mon, 26 Feb 2024 22:38:16 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C%E5%B1%9E%E6%80%A7/</guid><description>线程同步的相关属性，控制线程同步时的行为</description><tags>同步属性 条件变量 进程共享 屏障</tags><summary>&lt;p>屏障的作用是允许每个线程完成自身任务之后等待，直到所有线程都达到某一点，然后从该点继续执行。&lt;/p>
&lt;p>默认情况下屏障应用于单个进程的多个线程之间。&lt;/p>
&lt;p>屏障的进程共享属性允许将屏障应用于多个进程之间，前提是多个进程能够访问到同一个屏障对象。&lt;/p></summary></item><item><title>线程安全、可重入以及异步信号安全函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 02 Mar 2024 23:07:15 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/</guid><description>异步信号安全函数是可重入的，可重入函数是线程安全的。</description><tags>线程 线程安全 可重入函数 异步信号安全</tags><summary>&lt;p>可重入等价于异步信号安全。&lt;/p>
&lt;p>线程安全与可重入以及异步信号安全没有必然联系。&lt;/p></summary></item><item><title>线程特定数据</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE/</link><pubDate>Tue, 05 Mar 2024 22:50:37 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE/</guid><description>线程特定数据（thread-specific data），也称为线程私有数据（thread-private data），是线程单独的数据副本，存储在线程的私有存储空间，不与进程中其他线程共享。</description><tags>线程 线程特定数据 Pthread_key_t 线程键 析构函数 Pthread_once Pthread_setspecific</tags><summary>&lt;p>线程特定数据（thread-specific data），也称为线程私有数据（thread-private data），是线程单独的数据副本，存储在线程的私有存储空间，不与进程中其他线程共享。&lt;/p>
&lt;p>线程键（&lt;code>pthread_key_t&lt;/code>），每个线程用其与自身特定数据地址进行关联。&lt;/p>
&lt;p>析构函数用于线程退出时调用。通常使用&lt;code>malloc&lt;/code>为线程特定数据分配内存，析构函数通常用于释放已分配的内存。&lt;/p></summary></item><item><title>多线程环境下信号处理</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</link><pubDate>Sun, 17 Mar 2024 18:37:49 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</guid><description>本文介绍了线程对信号的处理方式，一是共享信号处理行为，二是信号递送给单个线程。同时介绍了线程对信号处理的函数用法，包括`pthread_sigmask`、`sigwait`以及`pthread_kill`等。</description><tags>信号 多线程 Pthread_sigmask Sigwait Pthread_kill</tags><summary>&lt;p>多线程环境下需要使用互斥量等数据来进行线程间数据同步，然而同时使用同步对象与信号处理很容易造成死锁，本文探索如何在多线程环境下来进行信号处理。&lt;/p>
&lt;p>&lt;strong>在多线程环境中，为了防止信号中断线程，通常把信号加到每个线程的信号屏蔽字中。然后安排专用线程来处理信号&lt;/strong>。&lt;/p></summary></item><item><title>线程和fork</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%92%8Cfork/</link><pubDate>Mon, 25 Mar 2024 19:30:47 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%92%8Cfork/</guid><description>本文探索多线程环境下调用fork创建子进程的方式，以及在父进程与子进程之间的数据共享方式。</description><tags>线程 Fork 多线程 写时复制 Pthread_atfork Fork处理程序</tags><summary>&lt;p>多线程环境下，调用&lt;code>fork&lt;/code>函数创建子进程时，子进程完全继承了父进程的整个内存地址空间。&lt;/p>
&lt;p>父进程中的互斥锁、多个线程在子进程中是如何处理的呢？&lt;/p>
&lt;p>由于父子进程之间采用了&lt;strong>写时复制&lt;/strong>技术，在子进程未改变互斥锁之前，父子进程对锁的状态是相同的，此时如何处理同步状态？&lt;/p></summary></item><item><title>守护进程</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</link><pubDate>Sat, 30 Mar 2024 22:26:53 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</guid><description>守护进程（dameon）控制终端，会话首进程，孤儿进程组，后台进程。编写守护进程（daemonize）的7个步骤（umask，fork，setsid，/dev/null），基于文件记录锁的单实例守护进程</description><tags>进程 守护进程 后台进程 出错管理</tags><summary>&lt;p>守护进程是生存期长的一种进程，在系统引导装入时启动，在系统关闭时终止。&lt;/p>
&lt;p>守护进程没有控制终端，通常在后台运行，实际上是在后台的孤儿进程组中运行。&lt;/p>
&lt;p>没有控制终端的原因在于&lt;strong>不与用户交互，避免终端信号影响&lt;/strong>。&lt;/p>
&lt;p>在孤儿进程组中运行的原因在于&lt;strong>防止其获取控制终端（通过每次打开终端设备设置参数&lt;code>O_NOCTTY&lt;/code>的方式不太靠谱）&lt;/strong>。&lt;/p></summary></item><item><title>非阻塞IO</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E9%9D%9E%E9%98%BB%E5%A1%9Eio/</link><pubDate>Wed, 17 Apr 2024 18:39:49 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E9%9D%9E%E9%98%BB%E5%A1%9Eio/</guid><description>系统调用、低速系统调用、非阻塞IO、O_NONBLOCK、fcntl</description><tags>APUE 非阻塞I/O 低速系统调用 O_NONBLOCK Fcntl</tags><summary>&lt;p>系统调用分为两类，“低速”系统调用和其他。&lt;/p>
&lt;p>“低速”系统调用指的是&lt;strong>可能会使进程永远阻塞&lt;/strong>的一类系统调用。&lt;/p>
&lt;p>非阻塞I/O则指的是当进行诸如&lt;code>open, read, write&lt;/code>等I/O操作时，这些操作&lt;strong>不会永远阻塞&lt;/strong>。&lt;strong>如果操作不能完成，则调用立即出错返回，以表示继续该操作将会阻塞&lt;/strong>。&lt;/p>
&lt;p>一般非阻塞I/O需要不断轮询判断是否有数据要进行读写，这种情况是比较浪费CPU时间的。&lt;strong>避免非阻塞I/O的两种方式：I/O多路转接或多线程采用阻塞I/O&lt;/strong>。&lt;/p></summary></item><item><title>文件锁之fcntl</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E9%94%81%E4%B9%8Bfcntl/</link><pubDate>Thu, 18 Apr 2024 20:07:19 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E9%94%81%E4%B9%8Bfcntl/</guid><description>文件锁、fcntl、读写锁、F_SETLK、F_GETLK、F_SETLKW、F_RDLCK、F_WRLCK、F_UNLCK、死锁、TELL_WAIT、锁的继承与释放</description><tags>APUE 建议性锁 强制性锁 文件锁 记录锁 Fcntl</tags><summary>&lt;p>文件锁的作用：当第一个进程正在读或修改文件的某个部分时，使用文件锁可以阻止其他进程修改文件的相同部分。&lt;/p>
&lt;p>因此文件锁可用于多个进程之间进行同步，防止进程间的竞争状态。&lt;/p>
&lt;p>Linux系统支持两组给文件加锁的不同API，分别是&lt;code>fcntl&lt;/code>与&lt;code>flock&lt;/code>。本节主要记录&lt;code>fcntl&lt;/code>的实现原理以及使用方式。&lt;/p>
&lt;p>&lt;strong>任意多个进程在同一个给定字节上都可以有一把共享读锁，但一个给定字节上仅能有一个进程持有一把独占写锁&lt;/strong>。&lt;/p></summary></item><item><title>文件锁之flock</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E9%94%81%E4%B9%8Bflock/</link><pubDate>Thu, 18 Apr 2024 23:35:29 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E9%94%81%E4%B9%8Bflock/</guid><description>flock锁对dup、open、fork等情况的处理，flock锁的继承与实现，flock锁内核实现解析，所有文件描述符关闭时会自动解除flock锁</description><tags>APUE 文件锁 记录锁 建议性锁 强制性锁 Flock</tags><summary>&lt;p>文件锁的作用：当第一个进程正在读或修改文件的某个部分时，使用文件锁可以阻止其他进程修改文件的相同部分。&lt;/p>
&lt;p>因此文件锁可用于多个进程之间进行同步，防止进程间的竞争状态。&lt;/p>
&lt;p>Linux系统支持两组给文件加锁的不同API，分别是&lt;code>fcntl&lt;/code>与&lt;code>flock&lt;/code>。本节主要记录&lt;code>flock&lt;/code>的实现原理以及使用方式。&lt;/p></summary></item><item><title>I/O多路转接之select函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bselect%E5%87%BD%E6%95%B0/</link><pubDate>Wed, 15 May 2024 21:59:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bselect%E5%87%BD%E6%95%B0/</guid><description>I/O多路转接主要用于一个进程中同时操作多个文件进行I/O，Linux提供了三个函数分别是select、poll以及epoll。本文主要探索了select函数的用法，以及返回值。比较有意思的一点是，select函数会修改传入的参数的值，不止时传入的超时参数timeout，还包括传入的文件描述符集。而修改之后的文件描述符集和函数返回值两者一起被用来判断是否有文件描述符准备好。</description><tags>I/O</tags><summary>&lt;p>当一个进程需要从多个文件描述中读，并写入多个文件描述符中（例如TCP服务器）。&lt;/p>
&lt;ol>
&lt;li>如果采用阻塞I/O，那么前面的描述符中没有数据时就会阻塞，这样即使后面的描述符有数据也无法读取，写描述符同理。&lt;/li>
&lt;li>如果采用非阻I/O，那么就需要不断轮询所有描述符（浪费CPU时间）。&lt;/li>
&lt;/ol>
&lt;p>当一个进程需要对一个文件描述符同时进行读写，两者并没有前后关系。如果采用阻塞I/O，那么没有数据读就会阻塞，进而导致进程无法处理写入，写阻塞时同理。&lt;/p>
&lt;p>上述问题的一个解决方法是采用多线程，每个线程中对一个描述符进行阻塞I/O，缺点是线程实现复杂，同时进程支持的线程数量有限。&lt;/p></summary></item><item><title>I/O多路转接之poll函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bpoll%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 04 Aug 2024 10:26:27 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bpoll%E5%87%BD%E6%95%B0/</guid><description>poll函数是另一种支持I/O多路复用的技术。其和select的区别在于selec是基于事件类型来划分文件描述符，而poll则是针对每个文件描述来指定关注的事件。同时poll函数支持更多的事件类型，以及文件描述符数量仅受系统性能限制。因此poll可以看作是select的一大进步。</description><tags>文件IO I/O 多路转接 Poll</tags><summary>&lt;p>如上节所述，&lt;code>poll&lt;/code>函数是另一个支持I/O多路转接的函数。&lt;/p>
&lt;p>与&lt;code>select&lt;/code>不同的是&lt;code>poll&lt;/code>函数支持更多的条件，而非&lt;code>select&lt;/code>函数仅有的三种条件（可读、可写以及异常）。&lt;/p>
&lt;p>同时&lt;code>poll&lt;/code>函数是以&lt;code>struct pollfd&lt;/code>数组类型保存文件描述符（没有文件描述符的数量限制），并为每个文件描述符指定关注的哪些条件，而&lt;code>select&lt;/code>函数则是另一种角度，为每个条件设置哪些文件描述符。&lt;/p></summary></item><item><title>UNIX域套接字</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</link><pubDate>Sun, 18 Aug 2024 11:15:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</guid><description>UNIX域套接字主要用于进程间通信IPC，创建UNIX域套接字的方法有两种，分别是socket函数和socketpair函数。UNIX域套接字分为匿名和命名套接字，匿名套接字仅用于具有亲缘关系的进程之间，命名套接字需要和其特定地址绑定，绑定后会系统会创建一个文件，其他进程通过该文件建立连接。</description><tags>域套接字 进程间通信 IPC Sockpair Socket</tags><summary>&lt;p>UNIX域套接字是单个主机上&lt;strong>客户端与服务器通信&lt;/strong>的一种方式。允许同一台计算机上&lt;strong>不同进程&lt;/strong>之间通过文件系统中的特殊文件（&lt;strong>套接字文件&lt;/strong>）进行数据交换。&lt;/p>
&lt;p>可以在同一台计算机上运行的两个进程之间传递打开的文件描述符。&lt;/p>
&lt;p>与TCP套接字相比较，UNIX域套接字不涉及网络协议栈，因此传递速度更快，效率更高。&lt;/p></summary></item></channel></rss>