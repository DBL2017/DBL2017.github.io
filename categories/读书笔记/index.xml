<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>读书笔记 on 生如夏花</title><link>https://DBL2017.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link><description>Recent content in 读书笔记 on 生如夏花</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 18 Aug 2024 11:15:51 +0800</lastBuildDate><atom:link href="https://DBL2017.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>UNIX域套接字</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</link><pubDate>Sun, 18 Aug 2024 11:15:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</guid><description>UNIX域套接字主要用于进程间通信IPC，创建UNIX域套接字的方法有两种，分别是socket函数和socketpair函数。UNIX域套接字分为匿名和命名套接字，匿名套接字仅用于具有亲缘关系的进程之间，命名套接字需要和其特定地址绑定，绑定后会系统会创建一个文件，其他进程通过该文件建立连接。</description><tags>域套接字 进程间通信 IPC Sockpair Socket</tags><summary>&lt;p&gt;UNIX域套接字是单个主机上&lt;strong&gt;客户端与服务器通信&lt;/strong&gt;的一种方式。允许同一台计算机上&lt;strong&gt;不同进程&lt;/strong&gt;之间通过文件系统中的特殊文件（&lt;strong&gt;套接字文件&lt;/strong&gt;）进行数据交换。&lt;/p&gt;
&lt;p&gt;可以在同一台计算机上运行的两个进程之间传递打开的文件描述符。&lt;/p&gt;
&lt;p&gt;与TCP套接字相比较，UNIX域套接字不涉及网络协议栈，因此传递速度更快，效率更高。&lt;/p&gt;</summary></item><item><title>I/O多路转接之poll函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bpoll%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 04 Aug 2024 10:26:27 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bpoll%E5%87%BD%E6%95%B0/</guid><description>poll函数是另一种支持I/O多路复用的技术。其和select的区别在于selec是基于事件类型来划分文件描述符，而poll则是针对每个文件描述来指定关注的事件。同时poll函数支持更多的事件类型，以及文件描述符数量仅受系统性能限制。因此poll可以看作是select的一大进步。</description><tags>文件IO I/O 多路转接 Poll</tags><summary>&lt;p&gt;如上节所述，&lt;code&gt;poll&lt;/code&gt;函数是另一个支持I/O多路转接的函数。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;select&lt;/code&gt;不同的是&lt;code&gt;poll&lt;/code&gt;函数支持更多的条件，而非&lt;code&gt;select&lt;/code&gt;函数仅有的三种条件（可读、可写以及异常）。&lt;/p&gt;
&lt;p&gt;同时&lt;code&gt;poll&lt;/code&gt;函数是以&lt;code&gt;struct pollfd&lt;/code&gt;数组类型保存文件描述符（没有文件描述符的数量限制），并为每个文件描述符指定关注的哪些条件，而&lt;code&gt;select&lt;/code&gt;函数则是另一种角度，为每个条件设置哪些文件描述符。&lt;/p&gt;</summary></item><item><title>I/O多路转接之select函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bselect%E5%87%BD%E6%95%B0/</link><pubDate>Wed, 15 May 2024 21:59:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bselect%E5%87%BD%E6%95%B0/</guid><description>I/O多路转接主要用于一个进程中同时操作多个文件进行I/O，Linux提供了三个函数分别是select、poll以及epoll。本文主要探索了select函数的用法，以及返回值。比较有意思的一点是，select函数会修改传入的参数的值，不止时传入的超时参数timeout，还包括传入的文件描述符集。而修改之后的文件描述符集和函数返回值两者一起被用来判断是否有文件描述符准备好。</description><tags>I/O</tags><summary>&lt;p&gt;当一个进程需要从多个文件描述中读，并写入多个文件描述符中（例如TCP服务器）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果采用阻塞I/O，那么前面的描述符中没有数据时就会阻塞，这样即使后面的描述符有数据也无法读取，写描述符同理。&lt;/li&gt;
&lt;li&gt;如果采用非阻I/O，那么就需要不断轮询所有描述符（浪费CPU时间）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当一个进程需要对一个文件描述符同时进行读写，两者并没有前后关系。如果采用阻塞I/O，那么没有数据读就会阻塞，进而导致进程无法处理写入，写阻塞时同理。&lt;/p&gt;
&lt;p&gt;上述问题的一个解决方法是采用多线程，每个线程中对一个描述符进行阻塞I/O，缺点是线程实现复杂，同时进程支持的线程数量有限。&lt;/p&gt;</summary></item><item><title>文件锁之flock</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E9%94%81%E4%B9%8Bflock/</link><pubDate>Thu, 18 Apr 2024 23:35:29 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E9%94%81%E4%B9%8Bflock/</guid><description>flock锁对dup、open、fork等情况的处理，flock锁的继承与实现，flock锁内核实现解析，所有文件描述符关闭时会自动解除flock锁</description><tags>APUE 文件锁 记录锁 建议性锁 强制性锁 Flock</tags><summary>&lt;p&gt;文件锁的作用：当第一个进程正在读或修改文件的某个部分时，使用文件锁可以阻止其他进程修改文件的相同部分。&lt;/p&gt;
&lt;p&gt;因此文件锁可用于多个进程之间进行同步，防止进程间的竞争状态。&lt;/p&gt;
&lt;p&gt;Linux系统支持两组给文件加锁的不同API，分别是&lt;code&gt;fcntl&lt;/code&gt;与&lt;code&gt;flock&lt;/code&gt;。本节主要记录&lt;code&gt;flock&lt;/code&gt;的实现原理以及使用方式。&lt;/p&gt;</summary></item><item><title>文件锁之fcntl</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E9%94%81%E4%B9%8Bfcntl/</link><pubDate>Thu, 18 Apr 2024 20:07:19 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E9%94%81%E4%B9%8Bfcntl/</guid><description>文件锁、fcntl、读写锁、F_SETLK、F_GETLK、F_SETLKW、F_RDLCK、F_WRLCK、F_UNLCK、死锁、TELL_WAIT、锁的继承与释放</description><tags>APUE 建议性锁 强制性锁 文件锁 记录锁 Fcntl</tags><summary>&lt;p&gt;文件锁的作用：当第一个进程正在读或修改文件的某个部分时，使用文件锁可以阻止其他进程修改文件的相同部分。&lt;/p&gt;
&lt;p&gt;因此文件锁可用于多个进程之间进行同步，防止进程间的竞争状态。&lt;/p&gt;
&lt;p&gt;Linux系统支持两组给文件加锁的不同API，分别是&lt;code&gt;fcntl&lt;/code&gt;与&lt;code&gt;flock&lt;/code&gt;。本节主要记录&lt;code&gt;fcntl&lt;/code&gt;的实现原理以及使用方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任意多个进程在同一个给定字节上都可以有一把共享读锁，但一个给定字节上仅能有一个进程持有一把独占写锁&lt;/strong&gt;。&lt;/p&gt;</summary></item><item><title>非阻塞IO</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E9%9D%9E%E9%98%BB%E5%A1%9Eio/</link><pubDate>Wed, 17 Apr 2024 18:39:49 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E9%9D%9E%E9%98%BB%E5%A1%9Eio/</guid><description>系统调用、低速系统调用、非阻塞IO、O_NONBLOCK、fcntl</description><tags>APUE 非阻塞I/O 低速系统调用 O_NONBLOCK Fcntl</tags><summary>&lt;p&gt;系统调用分为两类，“低速”系统调用和其他。&lt;/p&gt;
&lt;p&gt;“低速”系统调用指的是&lt;strong&gt;可能会使进程永远阻塞&lt;/strong&gt;的一类系统调用。&lt;/p&gt;
&lt;p&gt;非阻塞I/O则指的是当进行诸如&lt;code&gt;open, read, write&lt;/code&gt;等I/O操作时，这些操作&lt;strong&gt;不会永远阻塞&lt;/strong&gt;。&lt;strong&gt;如果操作不能完成，则调用立即出错返回，以表示继续该操作将会阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一般非阻塞I/O需要不断轮询判断是否有数据要进行读写，这种情况是比较浪费CPU时间的。&lt;strong&gt;避免非阻塞I/O的两种方式：I/O多路转接或多线程采用阻塞I/O&lt;/strong&gt;。&lt;/p&gt;</summary></item><item><title>守护进程</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</link><pubDate>Sat, 30 Mar 2024 22:26:53 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</guid><description>守护进程（dameon）控制终端，会话首进程，孤儿进程组，后台进程。编写守护进程（daemonize）的7个步骤（umask，fork，setsid，/dev/null），基于文件记录锁的单实例守护进程</description><tags>进程 守护进程 后台进程 出错管理</tags><summary>&lt;p&gt;守护进程是生存期长的一种进程，在系统引导装入时启动，在系统关闭时终止。&lt;/p&gt;
&lt;p&gt;守护进程没有控制终端，通常在后台运行，实际上是在后台的孤儿进程组中运行。&lt;/p&gt;
&lt;p&gt;没有控制终端的原因在于&lt;strong&gt;不与用户交互，避免终端信号影响&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在孤儿进程组中运行的原因在于&lt;strong&gt;防止其获取控制终端（通过每次打开终端设备设置参数&lt;code&gt;O_NOCTTY&lt;/code&gt;的方式不太靠谱）&lt;/strong&gt;。&lt;/p&gt;</summary></item><item><title>线程和fork</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%92%8Cfork/</link><pubDate>Mon, 25 Mar 2024 19:30:47 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%92%8Cfork/</guid><description>本文探索多线程环境下调用fork创建子进程的方式，以及在父进程与子进程之间的数据共享方式。</description><tags>线程 Fork 多线程 写时复制 Pthread_atfork Fork处理程序</tags><summary>&lt;p&gt;多线程环境下，调用&lt;code&gt;fork&lt;/code&gt;函数创建子进程时，子进程完全继承了父进程的整个内存地址空间。&lt;/p&gt;
&lt;p&gt;父进程中的互斥锁、多个线程在子进程中是如何处理的呢？&lt;/p&gt;
&lt;p&gt;由于父子进程之间采用了&lt;strong&gt;写时复制&lt;/strong&gt;技术，在子进程未改变互斥锁之前，父子进程对锁的状态是相同的，此时如何处理同步状态？&lt;/p&gt;</summary></item><item><title>多线程环境下信号处理</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</link><pubDate>Sun, 17 Mar 2024 18:37:49 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</guid><description>本文介绍了线程对信号的处理方式，一是共享信号处理行为，二是信号递送给单个线程。同时介绍了线程对信号处理的函数用法，包括`pthread_sigmask`、`sigwait`以及`pthread_kill`等。</description><tags>信号 多线程 Pthread_sigmask Sigwait Pthread_kill</tags><summary>&lt;p&gt;多线程环境下需要使用互斥量等数据来进行线程间数据同步，然而同时使用同步对象与信号处理很容易造成死锁，本文探索如何在多线程环境下来进行信号处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在多线程环境中，为了防止信号中断线程，通常把信号加到每个线程的信号屏蔽字中。然后安排专用线程来处理信号&lt;/strong&gt;。&lt;/p&gt;</summary></item><item><title>线程特定数据</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE/</link><pubDate>Tue, 05 Mar 2024 22:50:37 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE/</guid><description>线程特定数据（thread-specific data），也称为线程私有数据（thread-private data），是线程单独的数据副本，存储在线程的私有存储空间，不与进程中其他线程共享。</description><tags>线程 线程特定数据 Pthread_key_t 线程键 析构函数 Pthread_once Pthread_setspecific</tags><summary>&lt;p&gt;线程特定数据（thread-specific data），也称为线程私有数据（thread-private data），是线程单独的数据副本，存储在线程的私有存储空间，不与进程中其他线程共享。&lt;/p&gt;
&lt;p&gt;线程键（&lt;code&gt;pthread_key_t&lt;/code&gt;），每个线程用其与自身特定数据地址进行关联。&lt;/p&gt;
&lt;p&gt;析构函数用于线程退出时调用。通常使用&lt;code&gt;malloc&lt;/code&gt;为线程特定数据分配内存，析构函数通常用于释放已分配的内存。&lt;/p&gt;</summary></item><item><title>线程安全、可重入以及异步信号安全函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 02 Mar 2024 23:07:15 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/</guid><description>异步信号安全函数是可重入的，可重入函数是线程安全的。</description><tags>线程 线程安全 可重入函数 异步信号安全</tags><summary>&lt;p&gt;可重入等价于异步信号安全。&lt;/p&gt;
&lt;p&gt;线程安全与可重入以及异步信号安全没有必然联系。&lt;/p&gt;</summary></item><item><title>线程同步之屏障属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C%E5%B1%9E%E6%80%A7/</link><pubDate>Mon, 26 Feb 2024 22:38:16 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C%E5%B1%9E%E6%80%A7/</guid><description>线程同步的相关属性，控制线程同步时的行为</description><tags>同步属性 条件变量 进程共享 屏障</tags><summary>&lt;p&gt;屏障的作用是允许每个线程完成自身任务之后等待，直到所有线程都达到某一点，然后从该点继续执行。&lt;/p&gt;
&lt;p&gt;默认情况下屏障应用于单个进程的多个线程之间。&lt;/p&gt;
&lt;p&gt;屏障的进程共享属性允许将屏障应用于多个进程之间，前提是多个进程能够访问到同一个屏障对象。&lt;/p&gt;</summary></item><item><title>线程同步之条件变量属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7/</link><pubDate>Sun, 25 Feb 2024 10:19:46 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7/</guid><description>条件变量属性</description><tags>同步属性 条件变量 进程共享 时钟属性</tags><summary>&lt;p&gt;线程条件变量可以是线程&lt;strong&gt;以非竞争的方式同步执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;线程条件变量支持两个属性：&lt;strong&gt;进程共享&lt;/strong&gt;与&lt;strong&gt;时钟属性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进程共享属性可以使条件变量被多进程的线程使用。&lt;/p&gt;
&lt;p&gt;时钟属性控制计算&lt;code&gt;pthread_cond_timedwait()&lt;/code&gt;函数的超时参数（&lt;code&gt;tsptr&lt;/code&gt;）时采用哪个时钟。&lt;/p&gt;</summary></item><item><title>线程同步之读写锁属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%B1%9E%E6%80%A7/</link><pubDate>Sat, 24 Feb 2024 17:50:34 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%B1%9E%E6%80%A7/</guid><description>线程的读写锁同步属性，用于控制线程同步时的行为</description><tags>读写锁 同步属性 进程共享</tags><summary>&lt;p&gt;本文介绍了线程的同步对象读写锁的属性，通过读写锁属性可以控制在线程之间使用读写锁同步时的行为。&lt;/p&gt;
&lt;p&gt;线程的读写锁仅支持&lt;strong&gt;进程共享&lt;/strong&gt;属性。&lt;/p&gt;</summary></item><item><title>线程同步之互斥量属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F%E5%B1%9E%E6%80%A7/</link><pubDate>Fri, 23 Feb 2024 23:42:59 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F%E5%B1%9E%E6%80%A7/</guid><description>线程的同步类型属性，通过设置属性来控制线程的同步行为</description><tags>线程属性 互斥量属性 健壮 类型 进程共享</tags><summary>&lt;p&gt;本文主要介绍了线程同步对象互斥量的相关属性，并通过代码验证了这些属性。&lt;/p&gt;
&lt;p&gt;通过这些线程同步对象的属性可以控制不同线程在使用互斥量进行同步时的行为。&lt;/p&gt;</summary></item><item><title>线程属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7/</link><pubDate>Wed, 31 Jan 2024 22:57:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7/</guid><description>系统对线程的限制、通过属性对象控制线程、线程的同步属性</description><tags>APUE 线程 线程属性 线程限制 Pthread_attr_t</tags><summary>&lt;p&gt;SUS定义了一些系统层面上对于线程的限制，比如进程可以创建的最大线程数、线程栈可用的最小字节数等等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pthread&lt;/code&gt;接口允许我们传入&lt;strong&gt;线程或同步对象的属性&lt;/strong&gt;来调节线程或同步对象的行为。&lt;/p&gt;</summary></item><item><title>信号集及相关函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 16 Jan 2024 23:18:13 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程 信号集 Sigset_t</tags><summary>&lt;p&gt;&lt;strong&gt;信号集&lt;/strong&gt;（&lt;code&gt;sigset_t&lt;/code&gt;）是表示多个信号的数据类型。&lt;/p&gt;
&lt;p&gt;不同的信号编号可能会超过一个整型量的位数，所以不能用整型量中的一位代表一个信号。&lt;/p&gt;
&lt;p&gt;POSIX.1定义数据类型&lt;code&gt;sigset_t&lt;/code&gt;用以表示信号集，并定义了信号的操作函数。&lt;/p&gt;</summary></item><item><title>可靠信号</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7/</link><pubDate>Sun, 14 Jan 2024 23:18:50 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程 可靠信号 信号递送 Kill Pause Alarm</tags><summary>&lt;p&gt;可靠信号的处理有两个过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;信号产生&lt;/strong&gt;：当这些事件（&lt;strong&gt;硬件异常（如除以0）、软件条件（如alarm定时器超时）、终端产生的信号或调用&lt;code&gt;kill&lt;/code&gt;函数&lt;/strong&gt;）发生时，内核会为进程产生一个信号，同时在进程表中设置一个标志。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号递送&lt;/strong&gt;：内核使&lt;strong&gt;目标进程对该信号作出反应&lt;/strong&gt;称为信号递送：或是改变目标进程的执行状态（默认动作），或是开始执行信号处理程序，或两者都是。&lt;/li&gt;
&lt;/ol&gt;</summary></item><item><title>不可靠信号的相关问题</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 12 Jan 2024 21:10:43 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程 不可靠信号 信号丢失</tags><summary>&lt;p&gt;不可靠信号指的是信号可能会丢失，不支持信号阻塞，不能控制是否重启中断的系统调用等等。&lt;/p&gt;
&lt;p&gt;下面是不可靠信号可能会出现的问题：&lt;/p&gt;</summary></item><item><title>信号概述</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0/</link><pubDate>Wed, 10 Jan 2024 21:10:43 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程</tags><summary>&lt;p&gt;信号是软件中断。&lt;/p&gt;
&lt;p&gt;信号提供了一种处理异步事件的方法。&lt;/p&gt;
&lt;p&gt;信号用于大多数复杂的应用程序中。&lt;/p&gt;
&lt;p&gt;Unix系统的早期版本就已经提供了信号机制，但不可靠。POSIX.1对可靠信号例程进行了标准化。&lt;/p&gt;</summary></item><item><title>线程同步之屏障</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C/</link><pubDate>Fri, 17 Nov 2023 20:45:04 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C/</guid><description>线程同步的另一种方式，屏障</description><tags>APUE 线程 线程同步 屏障 Pthread</tags><summary>&lt;p&gt;屏障（barrier）是用户协调多个线程并行工作的同步机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pthread_join&lt;/code&gt;是一种特殊的屏障，允许一个线程等待，直到另一个线程退出。&lt;/p&gt;</summary></item><item><title>线程同步之条件变量</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Sun, 22 Oct 2023 21:05:40 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description>线程同步的方式之一，条件变量</description><tags>APUE 线程 线程同步 同步 条件变量 Unix Pthread</tags><summary>&lt;p&gt;&lt;strong&gt;互斥量&lt;/strong&gt;防止多个线程同时访问同一共享变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件变量&lt;/strong&gt;允许一个线程就某个&lt;strong&gt;条件&lt;/strong&gt;（共享变量）的变化状态通知其他线程，并让其他线程等待（阻塞于）该通知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件变量与互斥量一起使用，允许线程以无竞争的方式等待特定的条件发生。&lt;/strong&gt;&lt;/p&gt;</summary></item><item><title>线程同步之读写锁</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Mon, 16 Oct 2023 23:07:02 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>线程同步方式之一，读写锁</description><tags>APUE 线程 线程同步 读写锁 Unix Pthread</tags><summary>&lt;p&gt;读写锁也称为共享互斥锁，具有3种状态：&lt;strong&gt;读模式下的加锁状态&lt;/strong&gt;、&lt;strong&gt;写模式下的加锁状态&lt;/strong&gt;、&lt;strong&gt;不加锁状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一次仅有一个线程可以占有写模式下的读写锁，但是多个线程可以同时占有读模式下的读写锁。&lt;/p&gt;
&lt;p&gt;读写锁非常&lt;strong&gt;适合于对数据结构读的次数远大于写的情况&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;与互斥量相比，读写锁（reader-writer lock）运行更高的并行性。&lt;/p&gt;</summary></item><item><title>线程同步之互斥量</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F/</link><pubDate>Sat, 14 Oct 2023 14:29:41 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F/</guid><description>线程的几种同步方式，包括信号量、互斥量、读写锁、自旋锁、屏障等</description><tags>APUE Unix 线程 线程同步 互斥量 死锁 Pthread</tags><summary>&lt;p&gt;当多个线程共享相同的内存时，需要确保每个线程看到的都是一致的数据视图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当一个线程可以修改的变量，其他线程也可以读取或修改的时候&lt;/strong&gt;，就需要对这些线程进行&lt;strong&gt;同步&lt;/strong&gt;，确保访问变量时不会得到无效的值。&lt;/p&gt;</summary></item><item><title>线程的全生命周期</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Fri, 06 Oct 2023 14:54:11 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>线程的创建、运行、销毁、释放空间等全生命周期</description><tags>APUE Unix 线程 Pthread</tags><summary>&lt;p&gt;多线程与处理器的核心数无关，即使单核处理器也可以运行多线程。&lt;/p&gt;
&lt;p&gt;多线程的设计有很多优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简化处理异步事件&lt;/li&gt;
&lt;li&gt;共享内存和文件描述符&lt;/li&gt;
&lt;li&gt;提高程序吞吐量&lt;/li&gt;
&lt;li&gt;提高交互程序的响应等等&lt;/li&gt;
&lt;/ol&gt;</summary></item><item><title>密码技术总结与比特币</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81/</link><pubDate>Sun, 09 Jul 2023 21:14:06 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81/</guid><description/><tags>图解密码技术 对称密码 公钥密码 单向散列函数 消息认证码 数字签名 伪随机生成器 密码框架 压缩技术 比特币 区块链 挖矿 区块添加</tags><summary>&lt;p&gt;“密码学家的工具箱”中一共包含了6种基本的密码技术。分别是对称密码、公钥密码、单向散列函数、消息认证码、数字签名以及伪随机数生成器。&lt;/p&gt;
&lt;p&gt;比特币是一种虚拟货币，也叫密码学货币。&lt;/p&gt;
&lt;p&gt;比特币可以脱离物理介质，仅通过互联网就可以流通。&lt;/p&gt;</summary></item><item><title>TLS</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/tls/</link><pubDate>Sat, 08 Jul 2023 21:23:44 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/tls/</guid><description/><tags>图解密码技术 SSL TLS SSL/TLS 主密钥 Diffie-Hellman TLS握手 GCM 伪随机函数 PRF Handshake</tags><summary>&lt;p&gt;SSL/TLS是使用最广泛的加密通信方法。&lt;/p&gt;
&lt;p&gt;SSL/TLS中广泛运用了对称密码、消息认证码、公钥密码、数字签名、伪随机数生成器等密码技术。&lt;/p&gt;
&lt;p&gt;SSL（Secure Socket Layer）与TLS（Transport Layer Security）是不同的，TLS相当于是SSL的后续版本。&lt;/p&gt;
&lt;p&gt;SSL/TLS可以通过切换密码套件来使用强度更高的密码算法。&lt;/p&gt;</summary></item><item><title>PGP</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/pgp/</link><pubDate>Tue, 04 Jul 2023 22:45:47 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/pgp/</guid><description/><tags>图解密码技术 PGP OpenGPG GnuPG GnuPGv2 Gpg2 密钥对 信任网 信任级别 消息压缩 数字签名 加解密 混合密码系统</tags><summary>&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;PGP&lt;/th&gt;
 &lt;th&gt;说明&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;时间&lt;/td&gt;
 &lt;td&gt;1990年&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;菲利普·齐默曼&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;全称&lt;/td&gt;
 &lt;td&gt;Pretty Good Privary&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;用途&lt;/td&gt;
 &lt;td&gt;商业密码软件&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;支持平台&lt;/td&gt;
 &lt;td&gt;Windows、Mac OS X、Linux&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;版本&lt;/td&gt;
 &lt;td&gt;商用版、免费版&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;GnuPG&lt;/td&gt;
 &lt;td&gt;GNU Privacy Guard，遵循OpenGPG规范编写的密码软件。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PGP设计目的是在连国家都不可信的情况下仍然能够使用，因此并不关心有没有可信的认证机构，而是采用了“&lt;strong&gt;由用户自己来决定信任谁&lt;/strong&gt;”的设计。&lt;/p&gt;</summary></item><item><title>伪随机生成器</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%99%A8/</link><pubDate>Sun, 02 Jul 2023 21:33:49 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%99%A8/</guid><description/><tags>图解密码技术 伪随机数 随机数 随机性 单向散列函数 密码 线性同余法</tags><summary>&lt;p&gt;在密码技术中，随机数被用来生成密码。&lt;/p&gt;
&lt;p&gt;随机数的性质分为三类：随机性、不可预测性和不可重现性。&lt;/p&gt;
&lt;p&gt;线性同余法是很多库函数所采用的生成伪随机数的方法，但不可以用于密码技术。&lt;/p&gt;
&lt;p&gt;用于密码技术的伪随机数生成器，需要使用单向散列函数和密码技术确保不可预测性。&lt;/p&gt;</summary></item><item><title>证书</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E8%AF%81%E4%B9%A6/</link><pubDate>Tue, 13 Jun 2023 23:32:17 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E8%AF%81%E4%B9%A6/</guid><description/><tags>图解密码技术 CA 证书 签名 数字签名 散列值 X.509 证书作废 PKI PKCS 认证 认证机构</tags><summary>&lt;p&gt;什么是证书？证书的使用场景。&lt;/p&gt;
&lt;p&gt;证书标准规范X.509、颁发证书的认证机构。&lt;/p&gt;
&lt;p&gt;公钥基础设施PKI，对PKI的攻击方法和对策。&lt;/p&gt;
&lt;p&gt;无论是数字签名、证书，还是认证机构的层级结构，都&lt;strong&gt;不可能在完全不可信的状态下创造出信任关系&lt;/strong&gt;。&lt;/p&gt;</summary></item><item><title>数字签名</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</link><pubDate>Mon, 12 Jun 2023 09:44:34 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</guid><description/><tags>图解密码技术 数字签名 密钥 散列值 DSA ECDSA</tags><summary>&lt;p&gt;数字签名的基础知识、如何使用公钥密码实现数字签名。&lt;/p&gt;
&lt;p&gt;使用RSA具体实践数字签名的生成和验证。&lt;/p&gt;
&lt;p&gt;探讨针对数字签名的攻击方法以及数字签名与消息验证码之间的关系。&lt;/p&gt;
&lt;p&gt;数字签名可以识别篡改和伪装，还可以防止否认。&lt;/p&gt;
&lt;p&gt;数字签名是一种非常重要的认证技术，前提&lt;strong&gt;是用于验证签名的发送者的公钥没有被伪造。&lt;/strong&gt;&lt;/p&gt;</summary></item><item><title>消息认证码</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/</link><pubDate>Mon, 05 Jun 2023 22:41:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/</guid><description/><tags>图解密码技术 消息认证码 HMAC 单向散列函数 数字签名 对称密码 GCM 认证</tags><summary>&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th style="text-align: right"&gt;消息认证码&lt;/th&gt;
 &lt;th&gt;说明&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td style="text-align: right"&gt;作用&lt;/td&gt;
 &lt;td&gt;对消息进行认证并确认其完整性的技术，但不能保证消息的机密性&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: right"&gt;原理&lt;/td&gt;
 &lt;td&gt;使用发送者和接收者之间共享的密码，识别是否存在伪装或篡改&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: right"&gt;实用技术&lt;/td&gt;
 &lt;td&gt;单向散列函数和对称加密技术&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: right"&gt;存在问题&lt;/td&gt;
 &lt;td&gt;由于收发双方共享相同密钥，因此无法对第三方证明以及无法防止否认&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;认证加密&lt;/strong&gt;是将消息认证码与对称加密相结合，同时满足消息机密性、完整性以及认证三大功能。&lt;/p&gt;
&lt;p&gt;由于使用对称密码，发送者和接收者均可以生成消息认证码，因此对于第三方来说无法证明消息是由发送者生成的，即&lt;strong&gt;消息认证码无法防止否认&lt;/strong&gt;。&lt;/p&gt;</summary></item><item><title>单向散列函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 16 May 2023 22:46:08 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</guid><description/><tags>图解密码技术 认证 单向散列函数 SHA SHA-256 SHA3 MD5 Keccak</tags><summary>&lt;p&gt;单向散列函数能够根据任意长度的消息计算出固定长度的散列值，通过对比散列值可以判断两条消息是否一致，这种技术可用来辨别篡改。&lt;/p&gt;
&lt;p&gt;SHA-3的具体实现方法。&lt;/p&gt;
&lt;p&gt;针对单向散列函数的工具：暴力破解和生日攻击。&lt;/p&gt;
&lt;p&gt;使用单向散列函数可以辨别篡改，但无法分辨伪装。要解决这个问题，需要使用消息认证码和数字签名。&lt;/p&gt;</summary></item><item><title>混合密码系统</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%B7%B7%E5%90%88%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 15 May 2023 21:55:17 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%B7%B7%E5%90%88%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/</guid><description/><tags>图解密码技术 密码 混合密码 公钥密码 会话密钥</tags><summary>&lt;p&gt;混合密码系统用对称明码加密明文，用公钥密码来加密对称密码中所使用的密钥。&lt;/p&gt;
&lt;p&gt;通过使用混合密码系统，能够在通信中将对称密码和公钥密码的优势结合起来。&lt;/p&gt;</summary></item><item><title>公钥密码</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/</link><pubDate>Fri, 05 May 2023 23:42:48 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/</guid><description/><tags>图解密码技术 密码 密码学 密码技术 公钥密码</tags><summary>&lt;p&gt;&lt;strong&gt;密钥配送问题&lt;/strong&gt;：在对称密码中，由于加密和解密的密钥是相同的，因此必须事先向接收者配送密钥。&lt;/p&gt;
&lt;p&gt;如果使用公钥密码，则无需向接收者配送用于解密的密钥，这就相当于解决了密钥配送问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对称密码通过将明文转换为复杂的形式来保证机密性，公钥密码则是基于数学难题来保证机密性。&lt;/strong&gt; 例如RSA利用了大整数的质因数分解问题的困难度。&lt;/p&gt;
&lt;p&gt;即使已经有了公钥密码，对称密码也不会消失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公钥密码的运行速度远远低于对称密码&lt;/strong&gt;，因此一般通信过程中，往往会配合使用这两种密码，即用对称密码提高处理速度，用公钥密码解决密钥配送问题。这样的方式称为&lt;strong&gt;混合密码系统&lt;/strong&gt;。&lt;/p&gt;</summary></item><item><title>分组密码</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/</link><pubDate>Wed, 03 May 2023 22:14:35 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/</guid><description/><tags>图解密码技术 密码 密码学 密码技术 分组密码</tags><summary>&lt;p&gt;密码算法可以分为分组密码和流密码两种。&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;术语&lt;/th&gt;
 &lt;th&gt;说明&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;分组密码&lt;/td&gt;
 &lt;td&gt;每次只能处理特定长度的一块数据的一类密码算法。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;分组&lt;/td&gt;
 &lt;td&gt;每次处理的数据。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;分组长度&lt;/td&gt;
 &lt;td&gt;每次处理的数据分组的比特数。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;流密码&lt;/td&gt;
 &lt;td&gt;对数据流进行连续处理的一类密码算法。一般以1比特、8比特或32比特等为单位进行加解密。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;DES、三重DES以及AES（Rijndael）等大多数对称密码算法都属于分组密码。&lt;/p&gt;</summary></item><item><title>对称密码之Rijndael和AES</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%B9%8Brijndael%E5%92%8Caes/</link><pubDate>Thu, 20 Apr 2023 20:56:18 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%B9%8Brijndael%E5%92%8Caes/</guid><description/><tags>图解密码技术 密码 密码学 密码技术 AES 对称密码</tags><summary>&lt;p&gt;&lt;strong&gt;AES&lt;/strong&gt;（Advanced Encryption Standard）是取代前任标准（DES）而成为新标准的一种对称密码算法。&lt;/p&gt;
&lt;p&gt;2000年，在多个对称密码候选算法中，选出了一种名为&lt;strong&gt;Rijndael&lt;/strong&gt;的对称密码算法，并将其确定为了AES。&lt;/p&gt;</summary></item><item><title>对称密码之Feistel网络</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%B9%8Bfeistel%E7%BD%91%E7%BB%9C/</link><pubDate>Mon, 17 Apr 2023 20:12:56 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%B9%8Bfeistel%E7%BD%91%E7%BB%9C/</guid><description/><tags>图解密码技术 密码 密码学 密码技术 DES Feistel 对称密码</tags><summary>&lt;p&gt;对称密码指的是用相同的密钥进行加密和解密。&lt;/p&gt;
&lt;p&gt;在Feistel网络中，加密的各个步骤称为&lt;strong&gt;轮&lt;/strong&gt;，整个加密过程就是进行若干次轮的循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DES是一种16轮循环的Feistel网络。&lt;/strong&gt;&lt;/p&gt;</summary></item><item><title>历史上的几种简单密码</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81/</link><pubDate>Thu, 13 Apr 2023 23:14:26 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81/</guid><description/><tags>图解密码技术 密码 密码学 历史密码 凯撒密码 简单替换密码 Enigma</tags><summary>&lt;p&gt;3中历史上著名的密码：凯撒密码、简单替换密码、Enigma。&lt;/p&gt;
&lt;p&gt;两种密码破译方法：暴力攻击和频率分析。&lt;/p&gt;</summary></item><item><title>密码学常识</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%B8%B8%E8%AF%86/</link><pubDate>Thu, 13 Apr 2023 19:45:37 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%B8%B8%E8%AF%86/</guid><description/><tags>图解密码技术 密码学 密码 对称密码 公钥密码 RSA 哈希 数字签名 随机数 伪随机数 消息认证码</tags><summary>&lt;p&gt;&lt;strong&gt;对称密码&lt;/strong&gt;、&lt;strong&gt;公钥密码&lt;/strong&gt;、&lt;strong&gt;单向散列函数&lt;/strong&gt;、&lt;strong&gt;消息认证码&lt;/strong&gt;、&lt;strong&gt;数字签名&lt;/strong&gt;、&lt;strong&gt;伪随机数生成器&lt;/strong&gt;，这六种技术称为密码学家的工具箱。&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;信息安全所面临的威胁&lt;/th&gt;
 &lt;th&gt;受威胁的特性&lt;/th&gt;
 &lt;th&gt;用以应对的密码技术&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;窃听（秘密泄露）&lt;/td&gt;
 &lt;td&gt;机密性&lt;/td&gt;
 &lt;td&gt;对称密码/公钥密码&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;篡改（信息被修改）&lt;/td&gt;
 &lt;td&gt;完整性&lt;/td&gt;
 &lt;td&gt;单向散列函数/消息认证码/数字签名&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;伪装（伪装成真正的发送者）&lt;/td&gt;
 &lt;td&gt;认证&lt;/td&gt;
 &lt;td&gt;消息认证码/数字签名&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;否认（是否称自己没有做过）&lt;/td&gt;
 &lt;td&gt;不可否认性&lt;/td&gt;
 &lt;td&gt;数字签名&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;</summary></item><item><title>进程关系</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/</link><pubDate>Fri, 22 Jul 2022 21:11:24 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/</guid><description>终端简介之物理终端、模拟终端以及伪终端。终端登录以及网路登录的区别。进程组、会话以及控制终端相关概念。孤儿进程组、作业控制、终端驱动程序。fg、bg切换前后台进程。</description><tags>APUE 进程关系 终端 Unix环境高级编程</tags><summary>&lt;p&gt;本文主要介绍了终端，包括物理终端、模拟终端以及伪终端等。&lt;/p&gt;
&lt;p&gt;两种不同的登录方式、即终端登录和网络登录。&lt;/p&gt;
&lt;p&gt;重点是进程组、会话以及控制终端之间的联系。&lt;/p&gt;
&lt;p&gt;最后是作业控制，作业控制是目前很多类Unix系统都支持的功能。&lt;/p&gt;
&lt;p&gt;介绍了shell程序是如何实现作业控制的以及shell运行程序的方式。&lt;/p&gt;</summary></item><item><title>进程控制</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</link><pubDate>Sun, 26 Jun 2022 12:53:53 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid><description/><tags>APUE Unix环境高级编程 进程控制</tags><summary>&lt;p&gt;&lt;code&gt;fork&lt;/code&gt;创建子进程之后资源如何分配？&lt;/p&gt;
&lt;p&gt;运行中的进程的有效用户和程序文件的所属用户的区别？&lt;/p&gt;
&lt;p&gt;运行中的进程都有什么权限？&lt;/p&gt;
&lt;p&gt;函数&lt;code&gt;system&lt;/code&gt;是否成功执行？&lt;/p&gt;
&lt;p&gt;什么是进程会计？&lt;/p&gt;</summary></item><item><title>进程环境</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 23 Apr 2022 16:34:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</guid><description/><tags>APUE Unix 进程 Unix环境高级编程</tags><summary>&lt;p&gt;进程运行时，&lt;code&gt;main&lt;/code&gt;函数如何被调用？&lt;/p&gt;
&lt;p&gt;命令行参数如何传递给进程？&lt;/p&gt;
&lt;p&gt;存储空间的布局以及如何分配？&lt;/p&gt;
&lt;p&gt;进程如何使用环境变量？&lt;/p&gt;
&lt;p&gt;怎么限制进程使用的资源？&lt;/p&gt;</summary></item><item><title>系统数据文件和信息</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/</link><pubDate>Tue, 05 Apr 2022 12:21:20 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/</guid><description>本文主要介绍了口令文件/etc/passwd、阴影口令/etc/shadow、组文件/etc/group等内容格式以及解析方式，还是登录账户标志wtmp、utmp以及时间(timeval_t、)、时钟CLOCK等信息。</description><tags>APUE Unix环境高级编程 阴影口令 Shadow Timeval Time_t 时钟 Group</tags><summary>&lt;p&gt;口令文件&lt;code&gt;/etc/passwd&lt;/code&gt;和组文件&lt;code&gt;/etc/group&lt;/code&gt;经常被多个进程频繁使用。用户每次登录Linux和使用&lt;code&gt;ls&lt;/code&gt;命令都会访问口令文件。&lt;/p&gt;
&lt;p&gt;除了直接访问文件之外，系统通过一些接口来对外提供信息，比如系统标识函数、时间和日期函数。&lt;/p&gt;</summary></item><item><title>标准IO</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%A0%87%E5%87%86io/</link><pubDate>Wed, 23 Mar 2022 20:56:44 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%A0%87%E5%87%86io/</guid><description>标准IO是以流为基本对象的。</description><tags>APUE Unix 文件 标准IO Unix环境高级编程</tags><summary>&lt;p&gt;标准I/O库由ISO C标准制定的。标准I/O库相对于系统I/O处理了很多细节，比如缓冲区分配、以优化的块大小执行I/O（这个数据存储在&lt;code&gt;stat&lt;/code&gt;结构体中的&lt;code&gt;st_blksize&lt;/code&gt;字段）等。&lt;/p&gt;
&lt;p&gt;系统I/O是以文件描述符来作为基础展开的，而标准I/O是围绕流进行的，打开或创建文件时会将流和文件关联起来。&lt;/p&gt;
&lt;p&gt;获取与流相关的文件描述符可以使用函数&lt;code&gt;fileno()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流和文件相关联为文件流，流和内存关联起来为内存流。&lt;/strong&gt;&lt;/p&gt;</summary></item><item><title>文件和目录</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</link><pubDate>Fri, 04 Mar 2022 23:16:53 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</guid><description>描述文件属性的基本结构`struct stat`，文件权限判断，设置用户ID位，设置组ID位以及粘着位等，其次进程的实际用户ID、有效用户ID、有效组ID、附属组ID以及进程访问文件权限检测，其次是文件的相关操作函数，比如access()，chmod()，umask()，chown()等，之后是软链接、硬链接，最后是创建删除以及读写目录及其相关接口mkdir、chdir等。</description><tags>APUE 文件 目录 粘着位 文件权限 有效用户 附属组 访问权限检测 有效组</tags><summary>&lt;p&gt;本文描述了文件的属性，主要是&lt;code&gt;struct stat&lt;/code&gt;结构体中的相关字段，比如文件所有者ID、文件所属组ID、块大小等。&lt;/p&gt;
&lt;p&gt;其次详细描述了文件权限的相关内容，包括文件的基本权限、进程创建、读写文件的权限验证规则以及修改文件权限的相关接口等。&lt;/p&gt;
&lt;p&gt;最后是文件系统简介，包含&lt;code&gt;inode&lt;/code&gt;、目录项等，以及文件时间，创建删除以及读写目录等。&lt;/p&gt;</summary></item><item><title>文件IO</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6io/</link><pubDate>Thu, 24 Feb 2022 22:29:11 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6io/</guid><description>Unix环境下的非缓冲IO</description><tags>APUE Unix 文件IO Unix环境高级编程</tags><summary>&lt;p&gt;本节主要介绍不带缓冲的I/O（unbuffered I/O），不带缓冲指的是每个&lt;code&gt;read&lt;/code&gt;和&lt;code&gt;write&lt;/code&gt;都会调用内核中的一个系统调用。&lt;/p&gt;
&lt;p&gt;不带缓冲的I/O函数不是ISO C的标准函数，但是是符合POSIX的。&lt;/p&gt;
&lt;p&gt;原子操作在多进程之间贡献文件变得相当重要。&lt;/p&gt;
&lt;p&gt;主要涉及的函数有&lt;code&gt;oepn, read, write, lseek, close; dup, fcntl, sync, fsync, ioctl&lt;/code&gt;。&lt;/p&gt;</summary></item><item><title>程序的交流和通信</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%A4%E6%B5%81%E5%92%8C%E9%80%9A%E4%BF%A1/</link><pubDate>Sat, 30 May 2020 22:23:36 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%A4%E6%B5%81%E5%92%8C%E9%80%9A%E4%BF%A1/</guid><description>主要介绍系统级I/O，TCP/IP的socket通信以及进程之间的通信</description><tags>进程通信 网络编程 I/O CSAPP</tags><summary>&lt;p&gt;下图展示了各种I/O包： 
 &lt;a data-fancybox="gallery" href="10-16.png"&gt;
 &lt;img class="mx-auto" alt="" src="10-16.png" /&gt;
 &lt;/a&gt;
 &lt;/p&gt;</summary></item><item><title>虚拟内存</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link><pubDate>Tue, 26 May 2020 14:07:37 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid><description>虚拟内存是系统对物理内存的一种映射，进程的内存分配是基于虚拟内存的</description><tags>虚拟内存 CSAPP</tags><summary>&lt;p&gt;一个系统中的进程与其他进程共享CPU和主存资源的。&lt;/p&gt;
&lt;p&gt;为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做&lt;strong&gt;虚拟内存VM&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;虚拟内存是硬件异常，硬件地址，主存，磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的，一致的和私有的地址空间。&lt;/p&gt;
&lt;p&gt;虚拟内存提供了三个重要的能力：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。&lt;/li&gt;
&lt;li&gt;它为每个进程提供了一致的地址空间，从而简化了内存管理。&lt;/li&gt;
&lt;li&gt;它保护了每个进程的地址空间不被其他进程破坏。&lt;/li&gt;
&lt;/ol&gt;</summary></item><item><title>异常控制流</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</link><pubDate>Sun, 24 May 2020 14:07:37 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</guid><description>异常控制流，创建以及控制进程，信号的发送和接收</description><tags>异常 进程 地址空间 CSAPP</tags><summary>&lt;p&gt;从给处理器加电开始，直到断电为止，程序计数器假设一个值的序列$a_0,a_1,&amp;hellip;,a_{n-1}$，其中，每个$a_k$是某个相应指令$I_k$的地址。每次从$a_k$到$a_{k+1}$的过渡称为&lt;strong&gt;控制转移&lt;/strong&gt;。这样的控制转移序列叫做处理器的控制流。&lt;/p&gt;</summary></item><item><title>链接</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E9%93%BE%E6%8E%A5/</link><pubDate>Sun, 17 May 2020 13:15:19 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E9%93%BE%E6%8E%A5/</guid><description>链接是将各种代码和数据片段收集并组合成一个单一文件的过程</description><tags>链接 CSAPP</tags><summary>&lt;p&gt;&lt;strong&gt;链接&lt;/strong&gt;是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被夹在到内存中运行。链接可以执行于&lt;strong&gt;编译&lt;/strong&gt;时，也就是在源代码被翻译成机器代码时；也可以执行于&lt;strong&gt;加载&lt;/strong&gt;时，也就是在程序被&lt;strong&gt;加载器&lt;/strong&gt;加载到内存并执行时；甚至执行于&lt;strong&gt;运行&lt;/strong&gt;时，也就是由应用程序来执行。&lt;/p&gt;
&lt;p&gt;链接时由&lt;strong&gt;链接器&lt;/strong&gt;程序自动执行的。链接器在软件开发中扮演这一个关键的角色，因为它们使得&lt;strong&gt;分离编译&lt;/strong&gt;称为可能。&lt;/p&gt;
&lt;p&gt;传统静态链接，加载时共享库的动态链接，以及运行时的共享库的动态链接。&lt;/p&gt;</summary></item><item><title>存储器层次结构</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</link><pubDate>Thu, 07 May 2020 21:45:11 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</guid><description>基本存储技术(RAM、ROM以及磁盘)的简介以及存储器山</description><tags>存储器 CSAPP</tags><summary>&lt;p&gt;&lt;strong&gt;存储器系统&lt;/strong&gt;是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU寄存器保存着最常用的数据。靠近CPU的小的、快速的&lt;strong&gt;高速缓存存储器&lt;/strong&gt;（cache memory）作为一部分存储在相对慢速的主存储器中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘通常又作为存储在通过网络连接的其他机器的存盘或磁带上的数据的缓冲区域。&lt;/p&gt;</summary></item><item><title>程序的机器级表示</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</link><pubDate>Sat, 18 Apr 2020 11:53:04 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</guid><description>机器级编码，以及AT&amp;T汇编代码的简要介绍，从C语言转换为汇编代码</description><tags>CSAPP AT&amp;T 汇编 GCC</tags><summary>&lt;p&gt;计算机执行&lt;strong&gt;机器代码&lt;/strong&gt;，用字节序列编码低级的操作，包括数据处理、管理内存、读写存储设备上的数据、以及利用网络通信。编译器基于编程语言的规则、目标及其的指令集和操作系统遵循的管理，经过一系列阶段生成机器代码。GCC C语言编译器以&lt;strong&gt;汇编代码&lt;/strong&gt;的形式产生输出，汇编代码是机器代码的文本表示，给出程序中每一条指令。&lt;/p&gt;</summary></item><item><title>二进制加法和数值加法的对应关系</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%92%8C%E6%95%B0%E5%80%BC%E5%8A%A0%E6%B3%95%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</link><pubDate>Sat, 18 Apr 2020 11:34:00 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%92%8C%E6%95%B0%E5%80%BC%E5%8A%A0%E6%B3%95%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</guid><description>CS-APP中的信息的表示和处理章节的阅读笔记，可以用来回顾</description><tags>CSAPP 二进制加法 数值加法 全加器 半加器</tags><summary>&lt;h2 id="二进制加法"&gt;
 &lt;a href="#%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%8a%a0%e6%b3%95"&gt;
 二进制加法&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;首先，单个位的二进制相加结果如下表所示：&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th style="text-align: left"&gt;A&lt;/th&gt;
 &lt;th style="text-align: center"&gt;B&lt;/th&gt;
 &lt;th style="text-align: right"&gt;SUM&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td style="text-align: left"&gt;0&lt;/td&gt;
 &lt;td style="text-align: center"&gt;0&lt;/td&gt;
 &lt;td style="text-align: right"&gt;0&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: left"&gt;0&lt;/td&gt;
 &lt;td style="text-align: center"&gt;1&lt;/td&gt;
 &lt;td style="text-align: right"&gt;1&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: left"&gt;1&lt;/td&gt;
 &lt;td style="text-align: center"&gt;0&lt;/td&gt;
 &lt;td style="text-align: right"&gt;1&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: left"&gt;1&lt;/td&gt;
 &lt;td style="text-align: center"&gt;1&lt;/td&gt;
 &lt;td style="text-align: right"&gt;0&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通过这个结果表，明显可以看出这是一个单个位的&lt;strong&gt;异或运算&lt;/strong&gt;，所以说不考虑进位的情况下，二进制加法就是异或运算。&lt;/p&gt;</summary></item><item><title>关于IEEE754浮点数的一点思考</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%85%B3%E4%BA%8Eieee754%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</link><pubDate>Sat, 18 Apr 2020 11:23:50 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%85%B3%E4%BA%8Eieee754%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</guid><description>IEEE754定义的浮点数的详细介绍，以及自己的一些理解</description><tags>CSAPP IEEE754 浮点数</tags><summary/></item><item><title>信息的表示和处理</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link><pubDate>Fri, 17 Apr 2020 00:04:10 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid><description>CS-APP中的信息的表示和处理章节的阅读笔记，可以用来回顾</description><tags>CSAPP 整数编码 浮点数 IEEE754</tags><summary/></item></channel></rss>