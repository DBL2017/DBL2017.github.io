<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>操作系统 on 生如夏花</title><link>https://DBL2017.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><description>Recent content in 操作系统 on 生如夏花</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 01 Jul 2025 14:36:21 +0800</lastBuildDate><atom:link href="https://DBL2017.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>uloop源码剖析</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/libubox/uloop%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link><pubDate>Tue, 01 Jul 2025 14:36:21 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/libubox/uloop%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid><description>uloop是OpenWrt基础库libubox的核心模块，提供事件驱动功能。其主体框架由uloop_init、uloop_run_timeout和uloop_done三个函数构成，分别完成初始化、事件处理循环和清理工作。uloop支持五大核心功能：文件描述符监控基于epoll实现，通过epoll_wait处理就绪事件；定时器事件在循环中检测超时；子进程管理响应SIGCHLD信号；信号处理通过管道实现；间隔定时器依赖文件描述符机制。</description><tags>OpenWrt Libubox Uloop</tags><summary>&lt;p>uloop是OpenWrt基础库libubox的核心模块，提供事件驱动功能。&lt;/p>
&lt;p>其主体框架由uloop_init、uloop_run_timeout和uloop_done三个函数构成，分别完成初始化、事件处理循环和清理工作。&lt;/p>
&lt;p>uloop支持五大核心功能：&lt;/p>
&lt;ol>
&lt;li>文件描述符监控基于epoll实现，通过epoll_wait处理就绪事件；&lt;/li>
&lt;li>定时器事件在循环中检测超时；&lt;/li>
&lt;li>子进程管理响应SIGCHLD信号；&lt;/li>
&lt;li>信号处理通过管道实现；&lt;/li>
&lt;li>间隔定时器依赖文件描述符机制。&lt;/li>
&lt;/ol></summary></item><item><title>内核数据结构之container_of</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bcontainer_of/</link><pubDate>Sun, 27 Apr 2025 22:11:59 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bcontainer_of/</guid><description>container_of宏用于**根据结构体某个成员的地址来获取结构体自身的地址**，获得结构体自身地址之后可以访问该结构其他字段。offsetof宏可以获取结构体中成员相对于结构体的偏移量。pragma pack预定义指令用于限制结构体成员的最大对齐数，结构体的对齐数取决于结构体成员的最大对齐数，结构体成员的对齐数取决于其自身大小和编译器设置的参数。__attribute__((packed))和__attribute__((aligned(n)))仅用于GCC</description><tags>数据结构 Offsetof Container_of 结构体对齐 Pragma Pack Attribute</tags><summary>&lt;p>&lt;code>container_of&lt;/code>宏用于&lt;strong>根据结构体某个成员的地址来获取结构体自身的地址&lt;/strong>，获得结构体自身地址之后可以访问该结构其他字段，定义在&lt;code>&amp;lt;linux/kernel.h&amp;gt;&lt;/code>中。&lt;/p>
&lt;p>&lt;code>offsetof&lt;/code>宏用于&lt;strong>计算结构体成员到结构体自身地址之间的偏移&lt;/strong>，定义在&lt;code>&amp;lt;linux/stddef.h&amp;gt;&lt;/code>中。&lt;/p>
&lt;p>pragma pack预定义指令用于限制结构体成员的最大对齐数，结构体的对齐数取决于结构体成员的最大对齐数，结构体成员的对齐数取决于其自身大小和编译器设置的参数。&lt;/p>
&lt;p>&lt;code>__attribute__((packed))&lt;/code>和&lt;code>__attribute__((aligned(n)))&lt;/code>分别用于GCC不设置对齐和设置以&lt;code>n&lt;/code>字节对齐。&lt;/p></summary></item><item><title>iptables四表五链</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/iptables%E5%9B%9B%E8%A1%A8%E4%BA%94%E9%93%BE/</link><pubDate>Mon, 13 Jan 2025 10:54:52 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/iptables%E5%9B%9B%E8%A1%A8%E4%BA%94%E9%93%BE/</guid><description>在iptables中，"4表5链"是指filter 表、nat 表、mangle 表、raw 表，以及 INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING 链，它们共同作用于数据包的过滤和处理。如果数据包在二层（数据链路层）进行转发，例如通过网桥（bridge）或交换机进行转发，这些数据包不会经过 iptables 的这些链。在iptables规则中，`target`（目标）指定了当数据包匹配规则时应执行的动作。`target`可以是**内置的动作**，也可以是**用户自定义的链**。</description><tags>Iptables Chain 防火墙 Filter Nat Mangle Raw INPUT OUTPUT FORWARD PREROUTING POSTROUTING</tags><summary>&lt;p>在iptables中，”4表5链“是指iptables的四个表和五个链，它们共同作用于数据包的过滤和处理。&lt;/p>
&lt;p>iptables 的四表五链（filter 表、nat 表、mangle 表、raw 表，以及 INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING 链）都属于三层协议（网络层）处理。&lt;/p>
&lt;p>如果数据包在二层（数据链路层）进行转发，例如通过网桥（bridge）或交换机进行转发，这些数据包不会经过 iptables 的这些链。&lt;/p></summary></item><item><title>Windows中通过配置跃点数和永久路由选择上网方式</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows%E4%B8%AD%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E8%B7%83%E7%82%B9%E6%95%B0%E5%92%8C%E6%B0%B8%E4%B9%85%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F/</link><pubDate>Thu, 09 Jan 2025 15:09:12 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows%E4%B8%AD%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E8%B7%83%E7%82%B9%E6%95%B0%E5%92%8C%E6%B0%B8%E4%B9%85%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F/</guid><description>在Windows系统中，通过配置跃点数和永久路由可以控制多网卡上网方式。跃点数越小，路由优先级越高。活动路由是动态生成的，而永久路由是手动配置并持久保存的。通过命令行或界面修改跃点数，可以解决多网卡导致的上网问题，优先使用指定网卡的默认路由。</description><tags>路由表 跃点数 永久路由 多网卡上网</tags><summary>&lt;p>在多网卡的Windows系统中，可以通过配置路由表（永久路由和跃点数）来选择上网方式。&lt;/p>
&lt;p>在Windows路由表中，跃点数（Metric）是一个整数值，用于确定路由的优先级。跃点数越小，优先级越高。它主要用于在多个路由中选择最优的路径。&lt;/p></summary></item><item><title>OpenWrt之shell脚本处理UCI配置</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/uci/openwrt%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%A4%84%E7%90%86uci%E9%85%8D%E7%BD%AE/</link><pubDate>Thu, 26 Dec 2024 09:12:52 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/uci/openwrt%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%A4%84%E7%90%86uci%E9%85%8D%E7%BD%AE/</guid><description>OpenWRT在`/lib/functions.sh`中提供了一些列shell标准接口（`config_load, config_get, config_get_bool, config_cb, option_cb, list_cb, config_foreach, config_list_foreach`），以便在shell脚本中高效地读取和处理uci配置。当然这主要用于在`/etc/init.d`中写启动脚本。</description><tags>UCI OpenWrt Config_load Config_cb Option_cb List_cb</tags><summary>&lt;p>OpenWRT提供了一些列shell标准接口（&lt;code>config_load, config_get, config_get_bool, config_cb, option_cb, list_cb, config_foreach, config_list_foreach&lt;/code>，以便在shell脚本中高效地读取和处理uci配置。&lt;/p>
&lt;p>这主要用于在&lt;code>/etc/init.d&lt;/code>中写启动脚本。&lt;/p>
&lt;p>OpenWRT在&lt;code>/lib/functions.sh&lt;/code>文件中提供了访问uci配置的shell接口，因此在使用这些接口之间需要直接或间接（包含&lt;code>rc.common&lt;/code>）的方式包含该文件。&lt;/p></summary></item><item><title>OpenWrt之uci.sh中uci_load的工作原理</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/uci/openwrt%E4%B9%8Buci.sh%E4%B8%ADuci_load%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</link><pubDate>Wed, 25 Dec 2024 09:29:50 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/uci/openwrt%E4%B9%8Buci.sh%E4%B8%ADuci_load%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</guid><description>OpenWrt在`/lib/functions.sh`和`/lib/config/uci.sh`脚本中提供了操作UCI配置的校准接口，可以在Shell脚本中操作UCI配置。这样就可以在启动脚本中来根据UCI配置来进行选择启动。</description><tags>UCI OpenWrt Uci.sh Uci_load Config_cb Option_cb List_cb</tags><summary>&lt;p>OpenWrt在&lt;code>/lib/functions.sh&lt;/code>和&lt;code>/lib/config/uci.sh&lt;/code>提供了一组标准的shell接口来操作UCI配置，这样可以在Shell脚本中处理UCI配置。尤其是在&lt;code>/etc/init.d&lt;/code>目录下的配置文件中。&lt;/p>
&lt;p>本文主要探索&lt;code>/lib/config/uci.sh&lt;/code>脚本中的&lt;code>uci_load&lt;/code>接口是如何将UCI配置加载到内存中的。&lt;/p></summary></item><item><title>OpenWrt下载编译以及在VMWare上运行</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/openwrt%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E5%9C%A8vmware%E4%B8%8A%E8%BF%90%E8%A1%8C/</link><pubDate>Thu, 21 Nov 2024 23:11:53 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/openwrt%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E5%9C%A8vmware%E4%B8%8A%E8%BF%90%E8%A1%8C/</guid><description>本文描述了OpenWrt源码下载、编译过程以及产物，并在VMWare上运行配置IP，并远程连接到OpenWrt系统中。</description><tags>OpenWrt</tags><summary>&lt;p>本文记录以下OpenWrt的入门知识，包括源码编译，&lt;code>make menuconfig&lt;/code>配置，&lt;code>feeds&lt;/code>包下载以及生成可以运行在VMWare上的镜像。&lt;/p>
&lt;p>然后在VMWare上运行，并配置静态IP，然后可以使用SSH工具远程连接到OpenWrt系统中。&lt;/p></summary></item><item><title>OpenWrt之Feeds</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/openwrt%E4%B9%8Bfeeds/</link><pubDate>Thu, 21 Nov 2024 22:38:01 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/openwrt%E4%B9%8Bfeeds/</guid><description>Feed是OpenWRT中的软件包集合，这些软件包可以使用一个统一的地址来获取。软件包可以分布在远程服务器、版本控制系统、本地文件系统以及其他可以通过feed方法使用单个名称（路径/URL）寻址的位置。这样用户可以不必关心软件包的存储位置，减少软件包与核心代码的耦合。</description><tags>OpenWrt Feeds</tags><summary>&lt;p>Feeds在OpenWrt中扮演着至关重要的角色，它们允许用户根据自己的需求定制和扩展路由器的功能。通过安装不同的Feed，用户可以添加新的软件包、更新现有软件包或删除不再需要的软件包。&lt;/p></summary></item><item><title>Linux内核编译</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</link><pubDate>Tue, 07 May 2024 16:17:30 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</guid><description>Linux内核6.8.9，Linux内核编译，Linux内核编译相关问题解决，基于Ubuntu23.04编译最新版Linux内核（6.8.9）.</description><tags>Linux内核 内核编译</tags><summary>&lt;p>基于Ubuntu23.04编译最新版Linux内核（6.8.9），并解决编译过程中的相关问题。&lt;/p>
&lt;p>根据出现的问题，需要安装一下软件：&lt;code>sudo apt install flex bc libelf-dev&lt;/code>，并禁用系统相关证书：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-txt" data-lang="txt">&lt;span class="line">&lt;span class="cl">scripts/config --disable SYSTEM_TRUSTED_KEYS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">scripts/config --disable SYSTEM_REVOCATION_KEYS
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></summary></item><item><title>UCI system</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/uci/uci-system/</link><pubDate>Thu, 03 Aug 2023 22:38:57 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/uci/uci-system/</guid><description/><tags>OpenWrt UCI Config Section Option Libuci</tags><summary>&lt;p>UCI，Unified Configuration Interface，统一配置接口，是一个集中配置OpenWrt服务的系统。&lt;/p>
&lt;p>UCI是OpenWrt中基于NVRAM配置的继承者，是OpenWrt主要系统功能配置的用户接口，包括网络、无线、日志以及远程访问等等。&lt;/p></summary></item><item><title>Linux路由表</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E8%B7%AF%E7%94%B1%E8%A1%A8/</link><pubDate>Sat, 01 Jul 2023 12:27:43 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E8%B7%AF%E7%94%B1%E8%A1%A8/</guid><description/><tags>Linux 路由表 路由 Route GW IP 路由选择 静态路由 Netmask 网关 路由标志 路由种类 主机路由 网络路由 默认路由 IP选路</tags><summary>&lt;p>主机和网关（路由器）的本质区别在于&lt;strong>主机从不把数据报从一个接口转发到另一个接口，而网关（路由器）则要转发数据报&lt;/strong>。&lt;/p>
&lt;p>当今大多数用户系统，IP层既可以配置为网关（路由器）的功能，也可以配置为主机的功能。&lt;/p></summary></item><item><title>resolv.conf配置说明</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/resolv.conf%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</link><pubDate>Thu, 29 Jun 2023 23:19:54 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/resolv.conf%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</guid><description>本文介绍了Linux中用于域名解析的配置文件/etc/resolv.conf。该文件包含nameserver、search、sortlist和options四个部分，分别用于指定DNS服务器IP、搜索域列表、IP地址优先顺序和DNS查询机制调整。nameserver按顺序查询DNS，search将域名与搜索域结合形成FQDN，sortlist确定多个IP地址的优先顺序，options包含timeout、ndots、attempt和rotate等参数，用于调整DNS查询的超时时间、完全限定域名条件、轮询次数和负载均衡。配置时应将最可靠的DNS放在顶部，以减少解析延迟。</description><tags>DNS 域名解析 配置文件 Linux</tags><summary>&lt;p>在Linux中，&lt;strong>resolver&lt;/strong>（域名解析器）是一组进行域名转换函数组成的库。&lt;/p>
&lt;p>具体来说，就是通过&lt;strong>查询DNS（Domain Name Server）将域名转换为IP地址&lt;/strong>。&lt;/p>
&lt;p>/etc/resolv.conf是域名解析器的配置文件。&lt;/p></summary></item><item><title>Linux下手动配置网络</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E4%B8%8B%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C/</link><pubDate>Mon, 26 Jun 2023 10:19:40 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E4%B8%8B%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C/</guid><description/><tags>DNS Linux 域名 域名解析 配置文件 Hosts Resolv.conf Ifconfig 静态路由 默认路由 DNS服务器 Nameserver GW 主机路由 广播地址 Route</tags><summary>&lt;p>当一个设备加入到网络中时，通常需要&lt;strong>获得一个IP地址、设置一条正确的默认路由以及一个可以连上的DNS服务器&lt;/strong>。&lt;/p>
&lt;p>当网络采用了DHCP时，那么大部分的配置工作都会在DHCP服务器上完成，设备中的DHCP客户端只需要从服务器上获取到参数，然后配置到设备中即可。&lt;/p>
&lt;p>如果没有采用DHCP或者设备中没有DHCP客户端，就需要手动来配置网络（配置IP、配置静态路由、配置DNS）。&lt;/p></summary></item><item><title>ubus接口调用解析时遇到的一点问题</title><link>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/ubus%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E8%A7%A3%E6%9E%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 07 Aug 2021 22:06:38 +0800</pubDate><guid>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/ubus%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E8%A7%A3%E6%9E%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%AE%E9%A2%98/</guid><description/><tags>OpenWrt Ubus BLOBMSG_TYPE_TABLE TABLE_TYPE_ARRAY BLOBMSG_TYPE_INT32 BLOBMSG_TYPE_INT64</tags><summary>&lt;p>本文主要描述在openwrt环境下，使用&lt;code>blobmsg_parse&lt;/code>接口解析双层&lt;code>BLOBMSG_TYPE_TABLE&lt;/code>出现的Segmentation fault问题。带解析的数据来源于&lt;code>ubus call system info&lt;/code>返回的值。&lt;/p></summary></item></channel></rss>