<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>I/O on 生如夏花</title><link>https://DBL2017.github.io/tags/i/o/</link><description>Recent content in I/O on 生如夏花</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 04 Aug 2024 10:26:27 +0800</lastBuildDate><atom:link href="https://DBL2017.github.io/tags/i/o/index.xml" rel="self" type="application/rss+xml"/><item><title>I/O多路转接之poll函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bpoll%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 04 Aug 2024 10:26:27 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bpoll%E5%87%BD%E6%95%B0/</guid><description>poll函数是另一种支持I/O多路复用的技术。其和select的区别在于selec是基于事件类型来划分文件描述符，而poll则是针对每个文件描述来指定关注的事件。同时poll函数支持更多的事件类型，以及文件描述符数量仅受系统性能限制。因此poll可以看作是select的一大进步。</description><tags>文件IO I/O 多路转接 Poll</tags><summary>&lt;p>如上节所述，&lt;code>poll&lt;/code>函数是另一个支持I/O多路转接的函数。&lt;/p>
&lt;p>与&lt;code>select&lt;/code>不同的是&lt;code>poll&lt;/code>函数支持更多的条件，而非&lt;code>select&lt;/code>函数仅有的三种条件（可读、可写以及异常）。&lt;/p>
&lt;p>同时&lt;code>poll&lt;/code>函数是以&lt;code>struct pollfd&lt;/code>数组类型保存文件描述符（没有文件描述符的数量限制），并为每个文件描述符指定关注的哪些条件，而&lt;code>select&lt;/code>函数则是另一种角度，为每个条件设置哪些文件描述符。&lt;/p></summary></item><item><title>I/O多路转接之select函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bselect%E5%87%BD%E6%95%B0/</link><pubDate>Wed, 15 May 2024 21:59:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bselect%E5%87%BD%E6%95%B0/</guid><description>I/O多路转接主要用于一个进程中同时操作多个文件进行I/O，Linux提供了三个函数分别是select、poll以及epoll。本文主要探索了select函数的用法，以及返回值。比较有意思的一点是，select函数会修改传入的参数的值，不止时传入的超时参数timeout，还包括传入的文件描述符集。而修改之后的文件描述符集和函数返回值两者一起被用来判断是否有文件描述符准备好。</description><tags>I/O</tags><summary>&lt;p>当一个进程需要从多个文件描述中读，并写入多个文件描述符中（例如TCP服务器）。&lt;/p>
&lt;ol>
&lt;li>如果采用阻塞I/O，那么前面的描述符中没有数据时就会阻塞，这样即使后面的描述符有数据也无法读取，写描述符同理。&lt;/li>
&lt;li>如果采用非阻I/O，那么就需要不断轮询所有描述符（浪费CPU时间）。&lt;/li>
&lt;/ol>
&lt;p>当一个进程需要对一个文件描述符同时进行读写，两者并没有前后关系。如果采用阻塞I/O，那么没有数据读就会阻塞，进而导致进程无法处理写入，写阻塞时同理。&lt;/p>
&lt;p>上述问题的一个解决方法是采用多线程，每个线程中对一个描述符进行阻塞I/O，缺点是线程实现复杂，同时进程支持的线程数量有限。&lt;/p></summary></item><item><title>程序的交流和通信</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%A4%E6%B5%81%E5%92%8C%E9%80%9A%E4%BF%A1/</link><pubDate>Sat, 30 May 2020 22:23:36 +0000</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%A4%E6%B5%81%E5%92%8C%E9%80%9A%E4%BF%A1/</guid><description>主要介绍系统级I/O，TCP/IP的socket通信以及进程之间的通信</description><tags>进程通信 网络编程 I/O CSAPP</tags><summary>&lt;p>下图展示了各种I/O包： 
 &lt;a data-fancybox="gallery" href="10-16.png">
 &lt;img class="mx-auto" alt="" src="10-16.png" />
 &lt;/a>
 &lt;/p></summary></item></channel></rss>