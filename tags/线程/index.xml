<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>线程 on 生如夏花</title><link>https://DBL2017.github.io/tags/%E7%BA%BF%E7%A8%8B/</link><description>Recent content in 线程 on 生如夏花</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 25 Mar 2024 19:30:47 +0800</lastBuildDate><atom:link href="https://DBL2017.github.io/tags/%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>线程和fork</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%92%8Cfork/</link><pubDate>Mon, 25 Mar 2024 19:30:47 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%92%8Cfork/</guid><description>本文探索多线程环境下调用fork创建子进程的方式，以及在父进程与子进程之间的数据共享方式。</description><tags>线程 Fork 多线程 写时复制 Pthread_atfork Fork处理程序</tags><summary>&lt;p&gt;多线程环境下，调用&lt;code&gt;fork&lt;/code&gt;函数创建子进程时，子进程完全继承了父进程的整个内存地址空间。&lt;/p&gt;
&lt;p&gt;父进程中的互斥锁、多个线程在子进程中是如何处理的呢？&lt;/p&gt;
&lt;p&gt;由于父子进程之间采用了&lt;strong&gt;写时复制&lt;/strong&gt;技术，在子进程未改变互斥锁之前，父子进程对锁的状态是相同的，此时如何处理同步状态？&lt;/p&gt;</summary></item><item><title>线程特定数据</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE/</link><pubDate>Tue, 05 Mar 2024 22:50:37 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE/</guid><description>线程特定数据（thread-specific data），也称为线程私有数据（thread-private data），是线程单独的数据副本，存储在线程的私有存储空间，不与进程中其他线程共享。</description><tags>线程 线程特定数据 Pthread_key_t 线程键 析构函数 Pthread_once Pthread_setspecific</tags><summary>&lt;p&gt;线程特定数据（thread-specific data），也称为线程私有数据（thread-private data），是线程单独的数据副本，存储在线程的私有存储空间，不与进程中其他线程共享。&lt;/p&gt;
&lt;p&gt;线程键（&lt;code&gt;pthread_key_t&lt;/code&gt;），每个线程用其与自身特定数据地址进行关联。&lt;/p&gt;
&lt;p&gt;析构函数用于线程退出时调用。通常使用&lt;code&gt;malloc&lt;/code&gt;为线程特定数据分配内存，析构函数通常用于释放已分配的内存。&lt;/p&gt;</summary></item><item><title>线程安全、可重入以及异步信号安全函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 02 Mar 2024 23:07:15 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/</guid><description>异步信号安全函数是可重入的，可重入函数是线程安全的。</description><tags>线程 线程安全 可重入函数 异步信号安全</tags><summary>&lt;p&gt;可重入等价于异步信号安全。&lt;/p&gt;
&lt;p&gt;线程安全与可重入以及异步信号安全没有必然联系。&lt;/p&gt;</summary></item><item><title>线程属性</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7/</link><pubDate>Wed, 31 Jan 2024 22:57:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7/</guid><description>系统对线程的限制、通过属性对象控制线程、线程的同步属性</description><tags>APUE 线程 线程属性 线程限制 Pthread_attr_t</tags><summary>&lt;p&gt;SUS定义了一些系统层面上对于线程的限制，比如进程可以创建的最大线程数、线程栈可用的最小字节数等等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pthread&lt;/code&gt;接口允许我们传入&lt;strong&gt;线程或同步对象的属性&lt;/strong&gt;来调节线程或同步对象的行为。&lt;/p&gt;</summary></item><item><title>线程同步之屏障</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C/</link><pubDate>Fri, 17 Nov 2023 20:45:04 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%B1%8F%E9%9A%9C/</guid><description>线程同步的另一种方式，屏障</description><tags>APUE 线程 线程同步 屏障 Pthread</tags><summary>&lt;p&gt;屏障（barrier）是用户协调多个线程并行工作的同步机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pthread_join&lt;/code&gt;是一种特殊的屏障，允许一个线程等待，直到另一个线程退出。&lt;/p&gt;</summary></item><item><title>线程同步之条件变量</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Sun, 22 Oct 2023 21:05:40 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description>线程同步的方式之一，条件变量</description><tags>APUE 线程 线程同步 同步 条件变量 Unix Pthread</tags><summary>&lt;p&gt;&lt;strong&gt;互斥量&lt;/strong&gt;防止多个线程同时访问同一共享变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件变量&lt;/strong&gt;允许一个线程就某个&lt;strong&gt;条件&lt;/strong&gt;（共享变量）的变化状态通知其他线程，并让其他线程等待（阻塞于）该通知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件变量与互斥量一起使用，允许线程以无竞争的方式等待特定的条件发生。&lt;/strong&gt;&lt;/p&gt;</summary></item><item><title>线程同步之读写锁</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Mon, 16 Oct 2023 23:07:02 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>线程同步方式之一，读写锁</description><tags>APUE 线程 线程同步 读写锁 Unix Pthread</tags><summary>&lt;p&gt;读写锁也称为共享互斥锁，具有3种状态：&lt;strong&gt;读模式下的加锁状态&lt;/strong&gt;、&lt;strong&gt;写模式下的加锁状态&lt;/strong&gt;、&lt;strong&gt;不加锁状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一次仅有一个线程可以占有写模式下的读写锁，但是多个线程可以同时占有读模式下的读写锁。&lt;/p&gt;
&lt;p&gt;读写锁非常&lt;strong&gt;适合于对数据结构读的次数远大于写的情况&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;与互斥量相比，读写锁（reader-writer lock）运行更高的并行性。&lt;/p&gt;</summary></item><item><title>线程同步之互斥量</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F/</link><pubDate>Sat, 14 Oct 2023 14:29:41 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F/</guid><description>线程的几种同步方式，包括信号量、互斥量、读写锁、自旋锁、屏障等</description><tags>APUE Unix 线程 线程同步 互斥量 死锁 Pthread</tags><summary>&lt;p&gt;当多个线程共享相同的内存时，需要确保每个线程看到的都是一致的数据视图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当一个线程可以修改的变量，其他线程也可以读取或修改的时候&lt;/strong&gt;，就需要对这些线程进行&lt;strong&gt;同步&lt;/strong&gt;，确保访问变量时不会得到无效的值。&lt;/p&gt;</summary></item><item><title>线程的全生命周期</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Fri, 06 Oct 2023 14:54:11 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>线程的创建、运行、销毁、释放空间等全生命周期</description><tags>APUE Unix 线程 Pthread</tags><summary>&lt;p&gt;多线程与处理器的核心数无关，即使单核处理器也可以运行多线程。&lt;/p&gt;
&lt;p&gt;多线程的设计有很多优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简化处理异步事件&lt;/li&gt;
&lt;li&gt;共享内存和文件描述符&lt;/li&gt;
&lt;li&gt;提高程序吞吐量&lt;/li&gt;
&lt;li&gt;提高交互程序的响应等等&lt;/li&gt;
&lt;/ol&gt;</summary></item></channel></rss>