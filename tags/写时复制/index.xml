<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>写时复制 on 生如夏花</title><link>https://DBL2017.github.io/tags/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/</link><description>Recent content in 写时复制 on 生如夏花</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 25 Mar 2024 19:30:47 +0800</lastBuildDate><atom:link href="https://DBL2017.github.io/tags/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>线程和fork</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%92%8Cfork/</link><pubDate>Mon, 25 Mar 2024 19:30:47 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%92%8Cfork/</guid><description>本文探索多线程环境下调用fork创建子进程的方式，以及在父进程与子进程之间的数据共享方式。</description><tags>线程 Fork 多线程 写时复制 Pthread_atfork Fork处理程序</tags><summary>&lt;p>多线程环境下，调用&lt;code>fork&lt;/code>函数创建子进程时，子进程完全继承了父进程的整个内存地址空间。&lt;/p>
&lt;p>父进程中的互斥锁、多个线程在子进程中是如何处理的呢？&lt;/p>
&lt;p>由于父子进程之间采用了&lt;strong>写时复制&lt;/strong>技术，在子进程未改变互斥锁之前，父子进程对锁的状态是相同的，此时如何处理同步状态？&lt;/p></summary></item></channel></rss>