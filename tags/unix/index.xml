<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Unix on 生如夏花</title><link>https://DBL2017.github.io/tags/unix/</link><description>Recent content in Unix on 生如夏花</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 16 Jan 2024 23:18:13 +0800</lastBuildDate><atom:link href="https://DBL2017.github.io/tags/unix/index.xml" rel="self" type="application/rss+xml"/><item><title>信号集及相关函数</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 16 Jan 2024 23:18:13 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程 信号集 Sigset_t</tags><summary>&lt;p>&lt;strong>信号集&lt;/strong>（&lt;code>sigset_t&lt;/code>）是表示多个信号的数据类型。&lt;/p>
&lt;p>不同的信号编号可能会超过一个整型量的位数，所以不能用整型量中的一位代表一个信号。&lt;/p>
&lt;p>POSIX.1定义数据类型&lt;code>sigset_t&lt;/code>用以表示信号集，并定义了信号的操作函数。&lt;/p></summary></item><item><title>可靠信号</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7/</link><pubDate>Sun, 14 Jan 2024 23:18:50 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程 可靠信号 信号递送 Kill Pause Alarm</tags><summary>&lt;p>可靠信号的处理有两个过程如下：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>信号产生&lt;/strong>：当这些事件（&lt;strong>硬件异常（如除以0）、软件条件（如alarm定时器超时）、终端产生的信号或调用&lt;code>kill&lt;/code>函数&lt;/strong>）发生时，内核会为进程产生一个信号，同时在进程表中设置一个标志。&lt;/li>
&lt;li>&lt;strong>信号递送&lt;/strong>：内核使&lt;strong>目标进程对该信号作出反应&lt;/strong>称为信号递送：或是改变目标进程的执行状态（默认动作），或是开始执行信号处理程序，或两者都是。&lt;/li>
&lt;/ol></summary></item><item><title>不可靠信号的相关问题</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 12 Jan 2024 21:10:43 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程 不可靠信号 信号丢失</tags><summary>&lt;p>不可靠信号指的是信号可能会丢失，不支持信号阻塞，不能控制是否重启中断的系统调用等等。&lt;/p>
&lt;p>下面是不可靠信号可能会出现的问题：&lt;/p></summary></item><item><title>信号概述</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0/</link><pubDate>Wed, 10 Jan 2024 21:10:43 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0/</guid><description/><tags>APUE Unix 信号 Unix环境高级编程</tags><summary>&lt;p>信号是软件中断。&lt;/p>
&lt;p>信号提供了一种处理异步事件的方法。&lt;/p>
&lt;p>信号用于大多数复杂的应用程序中。&lt;/p>
&lt;p>Unix系统的早期版本就已经提供了信号机制，但不可靠。POSIX.1对可靠信号例程进行了标准化。&lt;/p></summary></item><item><title>线程同步之条件变量</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Sun, 22 Oct 2023 21:05:40 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description>线程同步的方式之一，条件变量</description><tags>APUE 线程 线程同步 同步 条件变量 Unix Pthread</tags><summary>&lt;p>&lt;strong>互斥量&lt;/strong>防止多个线程同时访问同一共享变量。&lt;/p>
&lt;p>&lt;strong>条件变量&lt;/strong>允许一个线程就某个&lt;strong>条件&lt;/strong>（共享变量）的变化状态通知其他线程，并让其他线程等待（阻塞于）该通知。&lt;/p>
&lt;p>&lt;strong>条件变量与互斥量一起使用，允许线程以无竞争的方式等待特定的条件发生。&lt;/strong>&lt;/p></summary></item><item><title>线程同步之读写锁</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Mon, 16 Oct 2023 23:07:02 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>线程同步方式之一，读写锁</description><tags>APUE 线程 线程同步 读写锁 Unix Pthread</tags><summary>&lt;p>读写锁也称为共享互斥锁，具有3种状态：&lt;strong>读模式下的加锁状态&lt;/strong>、&lt;strong>写模式下的加锁状态&lt;/strong>、&lt;strong>不加锁状态&lt;/strong>。&lt;/p>
&lt;p>一次仅有一个线程可以占有写模式下的读写锁，但是多个线程可以同时占有读模式下的读写锁。&lt;/p>
&lt;p>读写锁非常&lt;strong>适合于对数据结构读的次数远大于写的情况&lt;/strong>。&lt;/p>
&lt;p>与互斥量相比，读写锁（reader-writer lock）运行更高的并行性。&lt;/p></summary></item><item><title>线程同步之互斥量</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F/</link><pubDate>Sat, 14 Oct 2023 14:29:41 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F/</guid><description>线程的几种同步方式，包括信号量、互斥量、读写锁、自旋锁、屏障等</description><tags>APUE Unix 线程 线程同步 互斥量 死锁 Pthread</tags><summary>&lt;p>当多个线程共享相同的内存时，需要确保每个线程看到的都是一致的数据视图。&lt;/p>
&lt;p>&lt;strong>当一个线程可以修改的变量，其他线程也可以读取或修改的时候&lt;/strong>，就需要对这些线程进行&lt;strong>同步&lt;/strong>，确保访问变量时不会得到无效的值。&lt;/p></summary></item><item><title>线程的全生命周期</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Fri, 06 Oct 2023 14:54:11 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>线程的创建、运行、销毁、释放空间等全生命周期</description><tags>APUE Unix 线程 Pthread</tags><summary>&lt;p>多线程与处理器的核心数无关，即使单核处理器也可以运行多线程。&lt;/p>
&lt;p>多线程的设计有很多优点：&lt;/p>
&lt;ol>
&lt;li>简化处理异步事件&lt;/li>
&lt;li>共享内存和文件描述符&lt;/li>
&lt;li>提高程序吞吐量&lt;/li>
&lt;li>提高交互程序的响应等等&lt;/li>
&lt;/ol></summary></item><item><title>进程环境</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 23 Apr 2022 16:34:51 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</guid><description/><tags>APUE Unix 进程 Unix环境高级编程</tags><summary>&lt;p>进程运行时，&lt;code>main&lt;/code>函数如何被调用？&lt;/p>
&lt;p>命令行参数如何传递给进程？&lt;/p>
&lt;p>存储空间的布局以及如何分配？&lt;/p>
&lt;p>进程如何使用环境变量？&lt;/p>
&lt;p>怎么限制进程使用的资源？&lt;/p></summary></item><item><title>标准IO</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%A0%87%E5%87%86io/</link><pubDate>Wed, 23 Mar 2022 20:56:44 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%A0%87%E5%87%86io/</guid><description>标准IO是以流为基本对象的。</description><tags>APUE Unix 文件 标准IO Unix环境高级编程</tags><summary>&lt;p>标准I/O库由ISO C标准制定的。标准I/O库相对于系统I/O处理了很多细节，比如缓冲区分配、以优化的块大小执行I/O（这个数据存储在&lt;code>stat&lt;/code>结构体中的&lt;code>st_blksize&lt;/code>字段）等。&lt;/p>
&lt;p>系统I/O是以文件描述符来作为基础展开的，而标准I/O是围绕流进行的，打开或创建文件时会将流和文件关联起来。&lt;/p>
&lt;p>获取与流相关的文件描述符可以使用函数&lt;code>fileno()&lt;/code>。&lt;/p>
&lt;p>&lt;strong>流和文件相关联为文件流，流和内存关联起来为内存流。&lt;/strong>&lt;/p></summary></item><item><title>文件IO</title><link>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6io/</link><pubDate>Thu, 24 Feb 2022 22:29:11 +0800</pubDate><guid>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6io/</guid><description>Unix环境下的非缓冲IO</description><tags>APUE Unix 文件IO Unix环境高级编程</tags><summary>&lt;p>本节主要介绍不带缓冲的I/O（unbuffered I/O），不带缓冲指的是每个&lt;code>read&lt;/code>和&lt;code>write&lt;/code>都会调用内核中的一个系统调用。&lt;/p>
&lt;p>不带缓冲的I/O函数不是ISO C的标准函数，但是是符合POSIX的。&lt;/p>
&lt;p>原子操作在多进程之间贡献文件变得相当重要。&lt;/p>
&lt;p>主要涉及的函数有&lt;code>oepn, read, write, lseek, close; dup, fcntl, sync, fsync, ioctl&lt;/code>。&lt;/p></summary></item></channel></rss>