<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Makefile规则 | 生如夏花</title><meta property="og:title" content="Makefile规则 - 生如夏花"><meta property="og:type" content="article"><meta property="article:published_time" content='2022-01-27T23:10:05+08:00'><meta property="article:modified_time" content='2022-01-27T23:10:05+08:00'><meta name=Keywords content="C语言,Linux系统开发,物联网,博客,项目管理,软件架构"><meta name=description content="编写规则"><meta name=author content><meta property="og:url" content="https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/makefile%E8%A7%84%E5%88%99/"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css><link rel=stylesheet href=/css/badge.min.dc57f0a9d275742b1e2d17f204ae0b829361b5dd0df99d3d356615830fb223936c054d31a888c5f369975da90586601e2666ddbbbb36e98510b814a70826e874.css integrity="sha512-3FfwqdJ1dCseLRfyBK4LgpNhtd0N+Z09NWYVgw+yI5NsBU0xqIjF82mXXakFhmAeJmbdu7s26YUQuBSnCCbodA==" crossorigin=anonymous><link rel=stylesheet href=/css/header.min.9e74ad2f7e23fb54e2da3ef2f1eb6498897cd4139d181133b5e641f107980364ccfbcea731badb693b4a50819c388b6f8cab037346daf142114f86f14faa8766.css integrity="sha512-nnStL34j+1Ti2j7y8etkmIl81BOdGBEzteZB8QeYA2TM+86nMbrbaTtKUIGcOItvjKsDc0ba8UIRT4bxT6qHZg==" crossorigin=anonymous><link rel=stylesheet href=/css/table.min.c193c9134b7b9c6f88c84f2b6e189f1783056a6c6a7eab574e1ec8f1537bbbb4b3c44e130004fbb98e9e2f260c7485a74e96db4bd156e1f49a20013ab811e874.css integrity="sha512-wZPJE0t7nG+IyE8rbhifF4MFamxqfqtXTh7I8VN7u7SzxE4TAAT7uY6eLyYMdIWnTpbbS9FW4fSaIAE6uBHodA==" crossorigin=anonymous><link rel=stylesheet href=/css/baseof.min.5e04a6c8338c3c57aedaaae91320971e148651ac160d51bb58ebfec7757346a177331ac5646bbb1b2664b1c8cc405939125785c138935bc0d29a805b11791691.css integrity="sha512-XgSmyDOMPFeu2qrpEyCXHhSGUawWDVG7WOv+x3VzRqF3MxrFZGu7GyZkscjMQFk5EleFwTiTW8DSmoBbEXkWkQ==" crossorigin=anonymous><link rel=stylesheet href=/css/rocket.min.96a6be31cd3df9dcd4e7e131e9fcb0e63149da1da6a23df5ed8c8e0ccf0436f4c95aad5ded6a69e7fba5c051f8cc00466fcedaa07e4c7f59492d4a15aba2e936.css integrity="sha512-lqa+Mc09+dzU5+Ex6fyw5jFJ2h2moj317YyODM8ENvTJWq1d7Wpp5/ulwFH4zABGb87aoH5Mf1lJLUoVq6LpNg==" crossorigin=anonymous><link rel=stylesheet href=/css/toc.min.d258716c8e1217faa5525b82fb1a32c1980ba7419cb92684a219afc52bd8eb1034c9281e43ccd7bff11764339c91a03777eaa6d36e863f1c69a45fd05fbeaf7f.css integrity="sha512-0lhxbI4SF/qlUluC+xoywZgLp0GcuSaEohmvxSvY6xA0ySgeQ8zXv/EXZDOckaA3d+qm026GPxxppF/QX76vfw==" crossorigin=anonymous><link rel=stylesheet href=/css/clipboard.min.5e6a0198e50c850ced7dc2ba6f282ecaab21a8daad9eee626b990120818361b4b0007128d73957d5682346c88a6f9831f5872051e5f12da830cc29ca75676403.css integrity="sha512-XmoBmOUMhQztfcK6byguyqshqNqtnu5ia5kBIIGDYbSwAHEo1zlX1WgjRsiKb5gx9YcgUeXxLagwzCnKdWdkAw==" crossorigin=anonymous><link rel=stylesheet href=/css/style.min.578ca33085c2a1fbdbaa4560d60ba2988a35469db6220306455f1d0e84bece0a661501e6536fc84ccbf5b6cb795d5e9c177595804d5aa204861f80ff4003bd73.css integrity="sha512-V4yjMIXCofvbqkVg1guimIo1Rp22IgMGRV8dDoS+zgpmFQHmU2/ITMv1tst5XV6cF3WVgE1aogSGH4D/QAO9cw==" crossorigin=anonymous><link rel="shortcut icon" href=/img/favicon.png type=image/x-icon><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/vim.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/latex.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/dos.min.js></script><script src=/js/gumshoe.min.min.9dec1df0371d73b03324ed4bb78a6d5b2e84af6a37b11ce799808a26d70dfd156595f8d23c42db9e4866f12b4c0de664cfd032fa6f95bdaaada1bacdb235e79e.js integrity="sha512-newd8Dcdc7AzJO1Lt4ptWy6Er2o3sRznmYCKJtcN/RVllfjSPELbnkhm8StMDeZkz9Ay+m+VvaqtobrNsjXnng==" crossorigin=anonymous></script></head><body><div class=container><div class=container-header><header><div class=header-main><div class=header-site-name><a id=header-title href=https://DBL2017.github.io/>生如夏花</a><p class=description>专注于工业物联网行业数据采集，嵌入式Linux系统裁剪，5G智慧网关软件开发等</p></div><div class=header-menu><nav id=header-nav-menu><a href=https://DBL2017.github.io/>首页</a>
<a href=https://DBL2017.github.io/series/ title=系列>系列</a>
<a href=https://DBL2017.github.io/categories/ title=分类>分类</a>
<a href=https://DBL2017.github.io/tags/ title=标签>标签</a>
<a href=https://DBL2017.github.io/archives/ title=归档>归档</a>
<a href=https://DBL2017.github.io/about/ title=关于>关于</a></nav></div></div></header></div><div class=container-content><div class=content-center><div class=main-single><div class=single-toc><div class=post-toc><h2 class=post-toc-title><a href=#>目录</a></h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#规则示例>规则示例</a></li><li><a href=#规则语法>规则语法</a></li><li><a href=#prerequisites的类型>Prerequisites的类型</a></li><li><a href=#文件名中使用通配符>文件名中使用通配符</a></li><li><a href=#在目录中查找prerequisites>在目录中查找<code>prerequisites</code></a></li><li><a href=#伪target>伪target</a></li><li><a href=#多target规则>多<code>target</code>规则</a><ul><li><a href=#具有独立target的规则>具有独立<code>target</code>的规则</a></li><li><a href=#具有分组target的规则>具有分组<code>target</code>的规则</a></li></ul></li><li><a href=#具有多条规则的target>具有多条规则的<code>target</code></a></li><li><a href=#静态模式规则>静态模式规则</a><ul><li><a href=#静态模式规则语法>静态模式规则语法</a></li><li><a href=#静态模式规则和隐式规则>静态模式规则和隐式规则</a></li></ul></li></ul></nav></div></div></div><div class=single-article><article class=post><header><h1 class=post-title>Makefile规则</h1></header><date class="post-meta meta-date"><span class=meta-category><a href=/archives/#2022>2022年1月27日</a></span></date><div class=post-meta><span>|</span>
<span class=meta-category><a href=/categories/#%e5%b7%a5%e5%85%b7%e4%bd%bf%e7%94%a8>工具使用</a></span></div><div class=post-meta><span>|</span>
<span class=meta-category><a href=/series/#Make>Make</a></span></div><div class=post-meta><span>|</span>
<span>共4876字</span></div><div class=post-meta><span>|</span>
<span>阅读时长(10分钟)</span></div><div class=clear style=display:none><div class=toc-article><div class=toc-title>文章目录</div></div></div><div class=post-content><p><code>Makefile</code>中的规则是为了说明何时以及如何生成<code>target</code>，规则列出了<code>target</code>的<code>prerequisites</code>和<code>recipe</code>。</p><p>除了第一条规则作为默认规则，其他规则的顺序并不重要。如果第一条规则有多个<code>target</code>，那仅有第一个<code>target</code>作为默认<code>target</code>。以“.”开头的<code>target</code>一定不会是默认<code>target</code>。</p><p>因此当<code>Makefile</code>编译多个程序时，会使第一条规则的默认<code>target</code>为<code>all</code>，<code>prerequsities</code>为依赖的多个程序。</p><h2 id=规则示例><a href=#%e8%a7%84%e5%88%99%e7%a4%ba%e4%be%8b>规则示例</a></h2><p>下面是一个规则示例</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=nf>foo.o </span><span class=o>:</span> <span class=n>foo</span>.<span class=n>c</span> <span class=n>defs</span>.<span class=n>h</span>       <span class=c># module for twiddling the frobs
</span></span></span><span class=line><span class=cl>        cc -c -g foo.c
</span></span></code></pre></div><p><code>target</code>是<code>foo.o</code>，<code>prerequisites</code>是<code>foo.c def.c</code>，<code>recipe</code>中有一条命令<code>cc -c -g foo.c</code>。 <code>recipe</code>是以<code>tab</code>开头的。</p><p>这条规则说明两件事，一是如何判断<code>foo.o</code>是否过期；二是如果更新<code>foo.o</code>。</p><h2 id=规则语法><a href=#%e8%a7%84%e5%88%99%e8%af%ad%e6%b3%95>规则语法</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=nf>targets </span><span class=o>:</span> <span class=n>prerequisites</span>
</span></span><span class=line><span class=cl>        recipe
</span></span><span class=line><span class=cl>        …
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>targets </span><span class=o>:</span> <span class=n>prerequisites</span> ; <span class=n>recipe</span>
</span></span><span class=line><span class=cl>        recipe
</span></span><span class=line><span class=cl>        …
</span></span></code></pre></div><p><code>targets</code>是以空格分隔的文件名，也可以是通配符表示的文件名。正常情况下，<code>targes</code>唯一。</p><p><code>recipe</code>默认以<code>tab</code>开头，但是也可以使用<code>.RECIPEPREFIX</code>变量指定。第一行<code>recipe</code>可以以<code>;</code>跟在<code>prerequisites</code>后，也可以以<code>tab</code>开头另起一行。</p><p><code>$</code>被用于变量引用，需要使用<code>$</code>本身，语法<code>$$</code>。</p><p><strong>规格告诉<code>make</code>两件事情：<code>targets</code>何时过期；如果更新<code>targets</code>。</strong></p><h2 id=prerequisites的类型><a href=#prerequisites%e7%9a%84%e7%b1%bb%e5%9e%8b>Prerequisites的类型</a></h2><p><code>prerequisites</code>有两种类型，一是<code>normal prerequisites</code>，另一种时<code>order-only prerequisites</code>。</p><p><code>normal prerequisites</code>有两个功能，分别是：</p><ol><li>规定了<code>prerequisites</code>的<code>recipe</code>必须在<code>target</code>之前执行。</li><li>当<code>prerequisites</code>发生变化时，<code>target</code>必须更新。</li></ol><p><code>order-only prerequisites</code>和<code>normal prerequisites</code>的不同点在于，不执行第2条，也就是说<code>order-only prerequisites</code>发生变化时，<code>target</code>不会更新。</p><p>使用<code>order-only prerequisites</code>的语法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=nf>targets</span><span class=o>:</span> <span class=n>normal</span>-<span class=n>prerequisites</span> <span class=p>|</span> <span class=n>order</span>-<span class=n>only</span>-<span class=n>prerequisites</span>
</span></span></code></pre></div><p>示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=nv>objdir</span> <span class=o>:=</span> objdir
</span></span><span class=line><span class=cl><span class=c># 规则1
</span></span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>test</span>.<span class=n>c</span> <span class=p>|</span> <span class=k>$(</span><span class=nv>objdir</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    @echo <span class=s2>&#34;excute recipe&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 规则2
</span></span></span><span class=line><span class=cl><span class=nf>$(objdir)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    @echo <span class=s2>&#34;mkdir objdir&#34;</span>
</span></span><span class=line><span class=cl>    mkdir <span class=k>$(</span>objdir<span class=k>)</span>
</span></span></code></pre></div><p>在这个例子中，第一次<code>make</code>时会先执行规则2->规则1，但是修改<code>objdir</code>文件夹中的内容后再次<code>make</code>时仅会执行规则1，而不会执行规则2。因为<code>order-only prerequisites</code>发生变化时，<code>targets</code>是不会更新的。</p><h2 id=文件名中使用通配符><a href=#%e6%96%87%e4%bb%b6%e5%90%8d%e4%b8%ad%e4%bd%bf%e7%94%a8%e9%80%9a%e9%85%8d%e7%ac%a6>文件名中使用通配符</a></h2><p>使用通配符的单个文件名可以指定多个文件。<code>make</code>中的通配符有<code>*</code>、<code>?</code>、<code>[...]</code>。<code>*.c</code>指代一系列以<code>.c</code>结尾的文件名。</p><p>以<code>~</code>开头的文件名具有特殊含义，如果后面直接跟<code>/</code>则表示当前用户目录。如果后面跟单词则代表该单词所表示的用户目录，例如<code>~john/bin</code>表示<code>/home/john/bin</code>。和环境变量<code>HOME</code>含义一致。</p><p><code>targets</code>和<code>prerequisites</code>中的通配符会被<code>make</code>扩展，<code>recipes</code>中的通配符由<code>shell</code>来扩展。其他情况下只有使用通配符函数才会被扩展。</p><p>要使用通配符自身，需要使用<code>\</code>转移。</p><p>下面是在<code>recipes</code>中使用通配符，由<code>shell</code>扩展。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -rf *.o
</span></span></code></pre></div><p>下面是在<code>prerequisites</code>中使用通配符，由<code>make</code>进行扩展。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=nf>print</span><span class=o>:</span> *.<span class=n>c</span>
</span></span><span class=line><span class=cl>    lpr -p <span class=nv>$?</span>
</span></span><span class=line><span class=cl>    touch print
</span></span></code></pre></div><p>该条规则会打印更新的所有<code>.c</code>文件。</p><p>在变量中直接使用通配符不会被扩展，例如<code>objects=*.o</code>。但是如果该变量用到<code>prerequisites</code>或<code>recipes</code>时或使用通配符函数会被扩展，例如<code>objects:=$(wildcard *.c)</code>。</p><p><strong><code>wildcard</code>函数</strong></p><p>规则中的通配符会自动扩展，但是定义变量或函数参数中的通配符不会自动替换。如果需要在这些扩展通配符，需要<code>wildcard</code>函数。函数原型如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=k>$(</span><span class=nv>wildcard</span> <span class=nv>pattern</span>...<span class=k>)</span>
</span></span></code></pre></div><p>这个函数可以用在<code>makefile</code>的任何地方，会被模式规则匹配的一系列文件进行替代。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=c># 当前目录下所有.c文件
</span></span></span><span class=line><span class=cl><span class=k>$(</span><span class=nv>wildcard</span> *.<span class=nv>c</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c># 所有.c文件对应的.o文件
</span></span></span><span class=line><span class=cl><span class=k>$(</span><span class=nv>patsubst</span> %.<span class=nv>c</span>, %.<span class=nv>o</span>, <span class=k>$(</span><span class=nv>wildcard</span> *.<span class=nv>c</span><span class=k>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 编译所有源文件并链接如下所示（采用隐含规则）
</span></span></span><span class=line><span class=cl><span class=nv>objects</span> <span class=o>:=</span> <span class=k>$(</span>patsubst %.c, %.o, <span class=k>$(</span>wildcard *.c<span class=k>))</span>
</span></span><span class=line><span class=cl><span class=nf>foo</span><span class=o>:</span> <span class=k>$(</span><span class=nv>objects</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    cc -o foo <span class=k>$(</span>objects<span class=k>)</span>
</span></span></code></pre></div><h2 id=在目录中查找prerequisites><a href=#%e5%9c%a8%e7%9b%ae%e5%bd%95%e4%b8%ad%e6%9f%a5%e6%89%beprerequisites>在目录中查找<code>prerequisites</code></a></h2><p>在大型过程中，通常会将源码和二进制文件放在不同目录。<code>make</code>可以自动搜索多个目录来查找<code>prerequisites</code>来支持这一点。</p><p><strong><code>VPATH</code>变量为所有<code>prerequisites</code>指定搜索目录。</strong><code>make</code>会在<code>VPATH</code>指定的目录中查找当前目录中不存在<code>prerequisites</code>和<code>targets</code>。</p><p><code>VPATH</code>变量中，目录名称由冒号或空格分隔。列出的目录顺序是<code>make</code>的搜索顺序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=c># 列出了两个目录，src和../headers， make查找的顺序一致
</span></span></span><span class=line><span class=cl><span class=nv>VPATH</span> <span class=o>=</span> src:../headers
</span></span></code></pre></div><p><strong><code>vpath</code>指令</strong></p><ul><li>类似于<code>VPATH</code>变量，但是更具选择性，因为它可以为模式匹配的文件指定搜索路径。</li><li>使用语法如下：</li></ul><p><code>vpath pattern directories</code>为<code>pattern</code>匹配的文件查找指定的<code>directories</code>。</p><p><code>vpath pattern</code>清除与<code>pattern</code>关联的目录。</p><p><code>vpath</code>清除之前使用的所有目录。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=c># 在../headers目录中查找头文件
</span></span></span><span class=line><span class=cl><span class=err>vpath</span> <span class=err>%.h</span> <span class=err>../headers</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>vpath</span> <span class=err>%.c</span> <span class=err>foo</span>
</span></span><span class=line><span class=cl><span class=err>vpath</span> <span class=err>%</span> <span class=err>blish</span>
</span></span><span class=line><span class=cl><span class=err>vpath</span> <span class=err>%.c</span> <span class=err>bar</span>
</span></span></code></pre></div><p><strong>目录搜索执行规则</strong>：</p><ol><li>如果在<code>makefile</code>指定的路径中不存在<code>target</code>文件时，则执行目录搜索。</li><li>如果目录搜索成功，则保留该路径，并将此文件暂时作为目标。</li><li>该<code>target</code>的<code>prerequisites</code>搜索方法同上。</li><li>如果<code>target</code>不用更新，则使用目录搜索的路径；如果<code>target</code>需要更新，那么<code>target</code>会在当前目录生成而不是在目录搜索产生的路径中。</li></ol><p><strong>使用目录搜索时写<code>recipe</code></strong></p><p>当通过目录搜索在另一个目录中找到<code>prerequisites</code>时，写<code>recipe</code>务必细心，要保证<code>make</code>能够找到<code>prerequisites</code>。</p><p>自动变量：<code>$^</code>表示列出的所有<code>prerequisites</code>（包括从目录搜索中找到文件）；<code>$@</code>表示<code>target</code>；<code>$&lt;</code>表示第一个<code>prerequisites</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=c># CFLAGS变量能够指定C编译参数。
</span></span></span><span class=line><span class=cl><span class=nf>foo.o </span><span class=o>:</span> <span class=n>foo</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl>    cc -c <span class=k>$(</span>CFLAGS<span class=k>)</span> $^ -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># $&lt;表示第一个prerequisites，不会包含头文件
</span></span></span><span class=line><span class=cl><span class=nv>VPATH</span> <span class=o>=</span> src:../headers
</span></span><span class=line><span class=cl><span class=nf>foo.o </span><span class=o>:</span> <span class=n>foo</span>.<span class=n>c</span> <span class=n>defs</span>.<span class=n>h</span> <span class=n>hack</span>.<span class=n>h</span>
</span></span><span class=line><span class=cl>        cc -c <span class=k>$(</span>CFLAGS<span class=k>)</span> $&lt; -o <span class=nv>$@</span>
</span></span></code></pre></div><h2 id=伪target><a href=#%e4%bc%aatarget>伪target</a></h2><p>伪<code>target</code>不是一个文件名，而是要执行的<code>recipe</code>的名称。使用伪<code>target</code>有两个原因：1是避免和同名文件冲突；2是提高性能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=c># 该规则不会创建clean文件，所有每次执行make clean时rm命令都会被执行。并且如果目录中存在clean文件时，这条规则不会正常执行。
</span></span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm *.o temp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 下面这条规则，无论当前目录中是否存在clean，都会被执行
</span></span></span><span class=line><span class=cl><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>clean</span>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm *.o temp
</span></span></code></pre></div><p><strong>将伪<code>target</code>和<code>make</code>递归调用结合使用是很有用的。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=c># 在这个例子中，SUBDIRS变量列出所有要构建的目录。
</span></span></span><span class=line><span class=cl><span class=c># 并且采用循环遍历子目录的方式构建子目录
</span></span></span><span class=line><span class=cl><span class=nv>SUBDIRS</span> <span class=o>=</span> foo bar baz
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>subdirs</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> dir in <span class=k>$(</span>SUBDIRS<span class=k>)</span><span class=p>;</span> <span class=k>do</span> <span class=se>\
</span></span></span><span class=line><span class=cl>        <span class=k>$(</span>MAKE<span class=k>)</span> -C <span class=nv>$$</span>dir<span class=p>;</span> <span class=se>\
</span></span></span><span class=line><span class=cl>    <span class=k>done</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 这种方式存在两个问题：
</span></span></span><span class=line><span class=cl><span class=c># 一是如果其中一个子目录编译出现问题，其他子目录会继续编译。
</span></span></span><span class=line><span class=cl><span class=c># 二是不能使用make的并行构建方式。
</span></span></span><span class=line><span class=cl><span class=c># 为了解决上述问题，可以采用下面的构建方式
</span></span></span><span class=line><span class=cl><span class=nv>SUBDIRS</span> <span class=o>=</span> foo bar baz
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>subdirs</span> <span class=k>$(</span><span class=nv>SUBDIRS</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>subdirs</span><span class=o>:</span> <span class=k>$(</span><span class=nv>SUBDIRS</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>$(SUBDIRS)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>MAKE<span class=k>)</span> -C <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 定义foo必须在baz构建之后
</span></span></span><span class=line><span class=cl><span class=nf>foo</span><span class=o>:</span> <span class=n>baz</span>
</span></span></code></pre></div><p>**伪<code>target</code>会自动跳过隐式规则搜索。**这也是伪<code>target</code>性能高的原因。</p><p>伪<code>target</code>不应该是<code>target</code>的<code>prerequisites</code>，否则的话每次运行<code>make</code>都会更新<code>target</code>。</p><p>伪<code>target</code>也可以拥有<code>prerequisites</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=c># 如果Makefile同时生成多个程序时，通常采用如下形式。
</span></span></span><span class=line><span class=cl><span class=c># 将第一个target定义为伪target，依赖其他所有需要生成的程序。
</span></span></span><span class=line><span class=cl><span class=nf>all </span><span class=o>:</span> <span class=n>prog</span>1 <span class=n>prog</span>2 <span class=n>prog</span>3
</span></span><span class=line><span class=cl><span class=nf>.PHONY </span><span class=o>:</span> <span class=n>all</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>prog1 </span><span class=o>:</span> <span class=n>prog</span>1.<span class=n>o</span> <span class=n>utils</span>.<span class=n>o</span>
</span></span><span class=line><span class=cl>        cc -o prog1 prog1.o utils.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>prog2 </span><span class=o>:</span> <span class=n>prog</span>2.<span class=n>o</span>
</span></span><span class=line><span class=cl>        cc -o prog2 prog2.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>prog3 </span><span class=o>:</span> <span class=n>prog</span>3.<span class=n>o</span> <span class=n>sort</span>.<span class=n>o</span> <span class=n>utils</span>.<span class=n>o</span>
</span></span><span class=line><span class=cl>        cc -o prog3 prog3.o sort.o utils.o
</span></span></code></pre></div><p><strong>如果一个规则没有<code>prerequisites</code>或<code>recipe</code>，并且<code>target</code>是一个不存在的文件，那么这条规则无论何时运行都会更新<code>target</code>，因此所有依赖这个<code>target</code>的规则<code>recipe</code>总是会被执行。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=c># FORCE没有prerequisites和recipe，依赖于FORCE的clean的recipe总是会被执行
</span></span></span><span class=line><span class=cl><span class=c># 这种方式和.PHONY异曲同工。
</span></span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span> <span class=n>FORCE</span>
</span></span><span class=line><span class=cl>        rm <span class=k>$(</span>objects<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nf>FORCE</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># ECHO没有prerequisites，依赖于ECHO的$(SUBDIRS)的recipe每次都会被执行。
</span></span></span><span class=line><span class=cl><span class=nf>$(SUBDIRS)</span><span class=o>:</span><span class=n>ECHO</span>
</span></span><span class=line><span class=cl>    make -C <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>ECHO</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>SUBDIRS<span class=k>)</span>
</span></span></code></pre></div><h2 id=多target规则><a href=#%e5%a4%9atarget%e8%a7%84%e5%88%99>多<code>target</code>规则</a></h2><p>当规则中拥有多个<code>target</code>时，<code>target</code>会分为两类：独立<code>target</code>和分组<code>target</code>。具体是哪种<code>target</code>，由<code>target</code>后面的分隔符决定。</p><h3 id=具有独立target的规则><a href=#%e5%85%b7%e6%9c%89%e7%8b%ac%e7%ab%8btarget%e7%9a%84%e8%a7%84%e5%88%99>具有独立<code>target</code>的规则</a></h3><p>使用标准<code>target</code>分隔符（“:”）的规则为独立<code>target</code>的规则，“:”用来定义独立<code>targets</code>。这等价于为每个<code>target</code>编写具有相同<code>prerequisites</code>和<code>recipe</code>的规则。<strong><code>recipe</code>能够使用自动变量<code>$@</code>来指定正在构建的<code>target</code>。</strong></p><p>具有独立<code>target</code>的规则有两个使用场景：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=c># 1、所有target仅有prerequisites，没有recipe
</span></span></span><span class=line><span class=cl><span class=nf>kbd.o command.o files.o</span><span class=o>:</span> <span class=n>command</span>.<span class=n>h</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 上面这条规则等价于
</span></span></span><span class=line><span class=cl><span class=nf>kbd.o</span><span class=o>:</span> <span class=n>command</span>.<span class=n>h</span>
</span></span><span class=line><span class=cl><span class=nf>command.o</span><span class=o>:</span> <span class=n>command</span>.<span class=n>h</span>
</span></span><span class=line><span class=cl><span class=nf>files.o</span><span class=o>:</span> <span class=n>command</span>.<span class=n>h</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 2、所有target具有相似的recipes，通过$@变量来指定将要构建的target
</span></span></span><span class=line><span class=cl><span class=nf>bigoutput littleoutput </span><span class=o>:</span> <span class=n>text</span>.<span class=n>g</span>
</span></span><span class=line><span class=cl>    generate text.g -<span class=k>$(</span>subst output,,<span class=nv>$@</span><span class=k>)</span> &gt; <span class=nv>$@</span>
</span></span><span class=line><span class=cl><span class=c># 等价于
</span></span></span><span class=line><span class=cl><span class=nf>bigoutput </span><span class=o>:</span> <span class=n>text</span>.<span class=n>g</span>
</span></span><span class=line><span class=cl>    generate text.g -big &gt; bigoutput
</span></span><span class=line><span class=cl><span class=nf>littleoutput </span><span class=o>:</span> <span class=n>text</span>.<span class=n>g</span>
</span></span><span class=line><span class=cl>    generate text.g -little &gt; littleoutput
</span></span></code></pre></div><p>上面的示例展示如果对不同的<code>target</code>使用相同的<code>prerequisites</code>和<code>recipes</code>，如果想要对不同的<code>target</code>使用不同的<code>prerequisites</code>，可以采用静态模式规则。</p><h3 id=具有分组target的规则><a href=#%e5%85%b7%e6%9c%89%e5%88%86%e7%bb%84target%e7%9a%84%e8%a7%84%e5%88%99>具有分组<code>target</code>的规则</a></h3><p>多个<code>target</code>和<code>prerequisites</code>使用<code>&:</code>分隔则是具有分组<code>target</code>的目标。</p><p>分组<code>target</code>的规则的使用场景是组内的每个<code>target</code>都是由规则中的<code>recipe</code>生成。</p><p>当<code>make</code>构建任何一个分组<code>target</code>时，他知道组内的其他<code>target</code>也是由<code>recipe</code>构建的，因此当其他目标不存在或过时，会自动进行更新。</p><h2 id=具有多条规则的target><a href=#%e5%85%b7%e6%9c%89%e5%a4%9a%e6%9d%a1%e8%a7%84%e5%88%99%e7%9a%84target>具有多条规则的<code>target</code></a></h2><p>单个文件可以是多个规则的<code>target</code>。make生成该<code>target</code>，所有这些规则的<code>prerequisites</code>会进行合并。如果任何一个<code>prerequisites</code>比<code>target</code>新，则会重新生成<code>target</code>。</p><p>单个文件尽可以使用一个<code>recipe</code>生成，如果多条规则具有多个<code>recipe</code>，则会执行最后一个并打印错误。</p><h2 id=静态模式规则><a href=#%e9%9d%99%e6%80%81%e6%a8%a1%e5%bc%8f%e8%a7%84%e5%88%99>静态模式规则</a></h2><p>静态模式规则是指定<strong>多个<code>target</code>并根据<code>target</code>名称为每个<code>target</code>构造<code>prerequisites</code>的规则</strong>。这比具有多个<code>target</code>的规则更通用，因为<code>prerequisites</code>不要求相同，相似即可。</p><h3 id=静态模式规则语法><a href=#%e9%9d%99%e6%80%81%e6%a8%a1%e5%bc%8f%e8%a7%84%e5%88%99%e8%af%ad%e6%b3%95>静态模式规则语法</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=nf>targets...</span><span class=o>:</span> <span class=n>target</span>-<span class=n>pattern</span>: <span class=n>prereq</span>-<span class=n>patterns</span>...
</span></span><span class=line><span class=cl>    recipe
</span></span><span class=line><span class=cl>    ...
</span></span></code></pre></div><p><code>targets</code>列表指定规则适用的<code>target</code>。可以和普通规则的<code>target</code>一致包含通配符。</p><p><code>target-pattern</code>和<code>prereq-pattern</code>说明了如何生成每个<code>target</code>的<code>prerequisites</code>。每个<code>target</code>都与<code>target-pattern</code>进行匹配用来提取<code>target</code>匹配的部分作为词干，这个词干替换到<code>prereq-pattern</code>用以生成每个<code>target</code>的<code>prerequisites</code>。</p><p>每个模式通常仅会包含一个<code>%</code>。当<code>target-pattern</code>匹配<code>target</code>时，<code>%</code>会匹配<code>target</code>名称的一部分，这部分成为词干。剩余的部分也必须完全匹配。例如<code>foo.o</code>匹配<code>%.o</code>而<code>foo.c</code>不匹配<code>%.o</code>。</p><p>每个<code>target</code>的<code>prerequisites</code>都是将名称中<code>%</code>替换为词干。例如如果词干是<code>foo</code>，而<code>prereq-pattern</code>是<code>%.c</code>，则<code>prerequisites</code>是<code>foo.c</code>。</p><p><code>prerequisites</code>中可以不包含<code>%</code>，那么这个<code>prerequisites</code>对每个<code>target</code>都是一致的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=c># 从对应的.c文件生成foo.o和bar.o
</span></span></span><span class=line><span class=cl><span class=nv>objects</span> <span class=o>=</span> foo.o bar.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=k>$(</span><span class=nv>objects</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>$(objects)</span><span class=o>:</span> %.<span class=n>o</span>: %.<span class=n>c</span>
</span></span><span class=line><span class=cl>        <span class=k>$(</span>CC<span class=k>)</span> -c <span class=k>$(</span>CFLAGS<span class=k>)</span> $&lt; -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl><span class=c># $&lt;是自动变量表示prerequisites，$@表示target。
</span></span></span></code></pre></div><p>**每个<code>target</code>必须匹配<code>target-pattern</code>，否则会提示警告。**如果由多个文件，其中由部分文件不匹配<code>target-pattern</code>，可以使用<code>filter</code>函数进行过滤。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=nv>files</span> <span class=o>=</span> foo.elc bar.o lose.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>$(filter %.o,$(files))</span><span class=o>:</span> %.<span class=n>o</span>: %.<span class=n>c</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> -c <span class=k>$(</span>CFLAGS<span class=k>)</span> $&lt; -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl><span class=nf>$(filter %.elc,$(files))</span><span class=o>:</span> %.<span class=n>elc</span>: %.<span class=n>el</span>
</span></span><span class=line><span class=cl>    emacs -f batch-byte-compile $&lt;
</span></span></code></pre></div><h3 id=静态模式规则和隐式规则><a href=#%e9%9d%99%e6%80%81%e6%a8%a1%e5%bc%8f%e8%a7%84%e5%88%99%e5%92%8c%e9%9a%90%e5%bc%8f%e8%a7%84%e5%88%99>静态模式规则和隐式规则</a></h3></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://DBL2017.github.io/>生如夏花</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/makefile%E8%A7%84%E5%88%99/>https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/makefile%E8%A7%84%E5%88%99/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br><div class=post-archive><h2>相关文章</h2><ul class=listing><li><a href=/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/%E7%BC%96%E5%86%99makefile/>编写Makefile</a></li><li><a href=/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/makefile%E7%AE%80%E4%BB%8B/>Makefile简介</a></li><li><a href=/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/makefile/gnu-make%E7%AE%80%E4%BB%8B/>GNU Make简介</a></li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a href=/tags/makefile>Makefile</a></li></ul></div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=DBL2017/DBL2017.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></div></div></div><div class=content-right><div class=sidebar><section class=widget><form id=form-search action=https://DBL2017.github.io/search/ method=get accept-charset=utf-8 _lpchecked=1><input type=text name=q maxlength=20 placeholder=请输入查找关键字 required>
<button type=submit class=submit title=提交>
<svg t="1714448321870" class="icon" style="width:22px;height:22px" viewBox="0 0 1024 1024" p-id="1771" width="200" height="200"><path d="M781.9264 691.1232l236.928 236.9216-90.816 90.8032-236.9152-236.9216c-72.032 53.3568-161.184 84.9088-257.7088 84.9088C194.048 866.8352.0 672.7872.0 433.408.0 194.048 194.048.0 433.4144.0c239.3728.0 433.4208 194.048 433.4208 433.4144.0 96.5248-31.552 185.6768-84.9088 257.7088zm-348.512 47.2896c168.448.0 304.9984-136.5504 304.9984-304.9984s-136.5504-304.992-304.9984-304.992-304.992 136.5504-304.992 304.9856c0 168.448 136.5504 304.9984 304.992 304.9984z" fill="#4A4A4A" p-id="1772"/></svg></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/unp/tcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/ title=TCP套接字编程>TCP套接字编程</a></li><li><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/unp/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E7%A1%80/ title=套接字基础>套接字基础</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/windowsterminal%E9%85%8D%E7%BD%AE/ title=WindowsTerminal配置>WindowsTerminal配置</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%BF%98%E8%AE%B0ubuntu14.04%E7%9A%84%E7%99%BB%E5%BD%95%E8%B4%A6%E5%AF%86%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/ title=记录一次忘记Ubuntu14.04的登录账密的处理方式>记录一次忘记Ubuntu14.04的登录账密的处理方式</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/neovim/diagnostic/ title=Diagnostic>Diagnostic</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/libubox/uloop%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/ title=uloop源码剖析>uloop源码剖析</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/tikz%E7%BB%98%E5%88%B6%E6%8A%98%E7%BA%BF%E5%9B%BE/ title=TiKZ绘制折线图>TiKZ绘制折线图</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ubuntu18%E6%B0%B8%E4%B9%85%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%90%8D%E7%A7%B0/ title=Ubuntu18永久修改网络接口名称>Ubuntu18永久修改网络接口名称</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8Bdocumentclass/ title=LaTeX之documentclass>LaTeX之documentclass</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8Bctex%E5%AE%8F%E9%9B%86%E4%B9%8B%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%E7%B1%BB/ title=LaTeX之CTeX宏集之中文文档类>LaTeX之CTeX宏集之中文文档类</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=https://DBL2017.github.io/categories/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/>传输协议 (17)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/>工具使用 (25)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/>开源三方 (2)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统 (14)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/>数字安全 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/>数据结构和算法 (5)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言 (14)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/>网络工程师 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记 (58)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/>问题排查 (6)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%BB%98%E8%AE%A4/>默认 (2)</a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://mermaid.live/ title=Mermaid>Mermaid 编辑</a></li><li><a target=_blank href=https://excalidraw.com/ title=EXCALIDRAW>Excalidraw 绘图</a></li><li><a target=_blank href=https://git-scm.com/docs title=Git命令参考手册>Git命令参考手册</a></li><li><a target=_blank href=https://www.gnu.org/software/make/manual/make.html title="GNU make官方文档">GNU make官方文档</a></li><li><a target=_blank href=https://www.emojiall.com/ title=Emojiall表情网站>Emojiall表情网站</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/index.xml>文章 RSS</a></li></ul></section></div></div></div><div class=container-footer><footer id=footer><div>&copy; 2026 <a href=https://DBL2017.github.io/>生如夏花 By
生如夏花</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>广电总局</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered
by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://DBL2017.github.io/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">生如夏花</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script src=/js/jquery.fancybox.min.min.65c12100ca45d31006ad262cbdfa339fe0849703b18dfd74dd0156de627f0a1dc42eba3364e03876562117d2fa7722d8153cee03bdf747264c3c029102e154f6.js integrity="sha512-ZcEhAMpF0xAGrSYsvfozn+CElwOxjf103QFW3mJ/Ch3ELrozZOA4dlYhF9L6dyLYFTzuA733RyZMPAKRAuFU9g==" crossorigin=anonymous></script><a id=rocket href=#top></a><script src=/js/totop.min.8c7573186baa30f09c49b5cf3176c3b105785324d961b3d5c2f7f099d14673160a29aeebdec25909d046aa14936cd43451e17664662d518550d5e8998dbec670.js integrity="sha512-jHVzGGuqMPCcSbXPMXbDsQV4UyTZYbPVwvfwmdFGcxYKKa7r3sJZCdBGqhSTbNQ0UeF2ZGYtUYVQ1eiZjb7GcA==" crossorigin=anonymous></script><script src=/js/clipboard.min.0765794be1674926c1a3810afcf039f605f367cb11cef727ad49e6aa70f9fca0a37d329d64c55822896869eb0960763e73e085ee7675cbc497e4d3256a6e6a67.js integrity="sha512-B2V5S+FnSSbBo4EK/PA59gXzZ8sRzvcnrUnmqnD5/KCjfTKdZMVYIoloaesJYHY+c+CF7nZ1y8SX5NMlam5qZw==" crossorigin=anonymous></script><script>var spy=new Gumshoe("#TableOfContents a",{nested:!0,nestedClass:"active"})</script><script>hljs.highlightAll()</script></div></div></body></html>