<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>uloop源码剖析 | 生如夏花</title><meta property="og:title" content="uloop源码剖析 - 生如夏花"><meta property="og:type" content="article"><meta property="article:published_time" content='2025-07-01T14:36:21+08:00'><meta property="article:modified_time" content='2025-07-01T14:36:21+08:00'><meta name=Keywords content="C语言,Linux系统开发,物联网,博客,项目管理,软件架构"><meta name=description content="uloop是OpenWrt基础库libubox的核心模块，提供事件驱动功能。其主体框架由uloop_init、uloop_run_timeout和uloop_done三个函数构成，分别完成初始化、事件处理循环和清理工作。uloop支持五大核心功能：文件描述符监控基于epoll实现，通过epoll_wait处理就绪事件；定时器事件在循环中检测超时；子进程管理响应SIGCHLD信号；信号处理通过管道实现；间隔定时器依赖文件描述符机制。"><meta name=author content><meta property="og:url" content="https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/libubox/uloop%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css><link rel=stylesheet href=/css/badge.min.dc57f0a9d275742b1e2d17f204ae0b829361b5dd0df99d3d356615830fb223936c054d31a888c5f369975da90586601e2666ddbbbb36e98510b814a70826e874.css integrity="sha512-3FfwqdJ1dCseLRfyBK4LgpNhtd0N+Z09NWYVgw+yI5NsBU0xqIjF82mXXakFhmAeJmbdu7s26YUQuBSnCCbodA==" crossorigin=anonymous><link rel=stylesheet href=/css/header.min.9e74ad2f7e23fb54e2da3ef2f1eb6498897cd4139d181133b5e641f107980364ccfbcea731badb693b4a50819c388b6f8cab037346daf142114f86f14faa8766.css integrity="sha512-nnStL34j+1Ti2j7y8etkmIl81BOdGBEzteZB8QeYA2TM+86nMbrbaTtKUIGcOItvjKsDc0ba8UIRT4bxT6qHZg==" crossorigin=anonymous><link rel=stylesheet href=/css/table.min.c193c9134b7b9c6f88c84f2b6e189f1783056a6c6a7eab574e1ec8f1537bbbb4b3c44e130004fbb98e9e2f260c7485a74e96db4bd156e1f49a20013ab811e874.css integrity="sha512-wZPJE0t7nG+IyE8rbhifF4MFamxqfqtXTh7I8VN7u7SzxE4TAAT7uY6eLyYMdIWnTpbbS9FW4fSaIAE6uBHodA==" crossorigin=anonymous><link rel=stylesheet href=/css/baseof.min.5e04a6c8338c3c57aedaaae91320971e148651ac160d51bb58ebfec7757346a177331ac5646bbb1b2664b1c8cc405939125785c138935bc0d29a805b11791691.css integrity="sha512-XgSmyDOMPFeu2qrpEyCXHhSGUawWDVG7WOv+x3VzRqF3MxrFZGu7GyZkscjMQFk5EleFwTiTW8DSmoBbEXkWkQ==" crossorigin=anonymous><link rel=stylesheet href=/css/rocket.min.96a6be31cd3df9dcd4e7e131e9fcb0e63149da1da6a23df5ed8c8e0ccf0436f4c95aad5ded6a69e7fba5c051f8cc00466fcedaa07e4c7f59492d4a15aba2e936.css integrity="sha512-lqa+Mc09+dzU5+Ex6fyw5jFJ2h2moj317YyODM8ENvTJWq1d7Wpp5/ulwFH4zABGb87aoH5Mf1lJLUoVq6LpNg==" crossorigin=anonymous><link rel=stylesheet href=/css/toc.min.37fe0fbda85f18e890be33d1e0a82b29b78f1266bfe17e63679d86b84af41b0124616f83d28227783c214e26bd8d70223d405128cc355d865d7016623a163068.css integrity="sha512-N/4PvahfGOiQvjPR4KgrKbePEma/4X5jZ52GuEr0GwEkYW+D0oIneDwhTia9jXAiPUBRKMw1XYZdcBZiOhYwaA==" crossorigin=anonymous><link rel=stylesheet href=/css/clipboard.min.5e6a0198e50c850ced7dc2ba6f282ecaab21a8daad9eee626b990120818361b4b0007128d73957d5682346c88a6f9831f5872051e5f12da830cc29ca75676403.css integrity="sha512-XmoBmOUMhQztfcK6byguyqshqNqtnu5ia5kBIIGDYbSwAHEo1zlX1WgjRsiKb5gx9YcgUeXxLagwzCnKdWdkAw==" crossorigin=anonymous><link rel=stylesheet href=/css/style.min.578ca33085c2a1fbdbaa4560d60ba2988a35469db6220306455f1d0e84bece0a661501e6536fc84ccbf5b6cb795d5e9c177595804d5aa204861f80ff4003bd73.css integrity="sha512-V4yjMIXCofvbqkVg1guimIo1Rp22IgMGRV8dDoS+zgpmFQHmU2/ITMv1tst5XV6cF3WVgE1aogSGH4D/QAO9cw==" crossorigin=anonymous><link rel="shortcut icon" href=/img/favicon.png type=image/x-icon><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/vim.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/latex.min.js></script><script src=/js/gumshoe.min.min.9dec1df0371d73b03324ed4bb78a6d5b2e84af6a37b11ce799808a26d70dfd156595f8d23c42db9e4866f12b4c0de664cfd032fa6f95bdaaada1bacdb235e79e.js integrity="sha512-newd8Dcdc7AzJO1Lt4ptWy6Er2o3sRznmYCKJtcN/RVllfjSPELbnkhm8StMDeZkz9Ay+m+VvaqtobrNsjXnng==" crossorigin=anonymous></script></head><body><div class=container><div class=container-header><header><div class=header-main><div class=header-site-name><a id=header-title href=https://DBL2017.github.io/>生如夏花</a><p class=description>专注于工业物联网行业数据采集，嵌入式Linux系统裁剪，5G智慧网关软件开发等</p></div><div class=header-menu><nav id=header-nav-menu><a href=https://DBL2017.github.io/>首页</a>
<a href=https://DBL2017.github.io/series/ title=系列>系列</a>
<a href=https://DBL2017.github.io/categories/ title=分类>分类</a>
<a href=https://DBL2017.github.io/tags/ title=标签>标签</a>
<a href=https://DBL2017.github.io/archives/ title=归档>归档</a>
<a href=https://DBL2017.github.io/about/ title=关于>关于</a></nav></div></div></header></div><div class=container-content><div class=content-center><div class=main-single><div class=single-toc><div class=post-toc><h2 class=post-toc-title><a href=#>目录</a></h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#主体框架>主体框架</a></li><li><a href=#文件描述符事件>文件描述符事件</a><ul><li><a href=#初始化>初始化</a></li><li><a href=#添加描述符事件>添加描述符事件</a></li><li><a href=#执行逻辑>执行逻辑</a></li><li><a href=#uloop_fd_stack_event函数机制>uloop_fd_stack_event函数机制</a></li><li><a href=#销毁>销毁</a></li></ul></li><li><a href=#定时器事件>定时器事件</a><ul><li><a href=#超时定时器>超时定时器</a></li><li><a href=#执行流程>执行流程</a></li><li><a href=#间隔定时器>间隔定时器</a></li></ul></li><li><a href=#子进程事件>子进程事件</a><ul><li><a href=#处理逻辑>处理逻辑</a></li></ul></li><li><a href=#信号事件>信号事件</a></li></ul></nav></div></div></div><div class=single-article><article class=post><header><h1 class=post-title>uloop源码剖析</h1></header><date class="post-meta meta-date"><span class=meta-category><a href=/archives/#2025>2025年7月1日</a></span></date><div class=post-meta><span>|</span>
<span class=meta-category><a href=/categories/#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f>操作系统</a></span></div><div class=post-meta><span>|</span>
<span class=meta-category><a href=/series/#OpenWrt>OpenWrt</a></span></div><div class=post-meta><span>|</span>
<span>共12709字</span></div><div class=post-meta><span>|</span>
<span>阅读时长(26分钟)</span></div><div class=clear style=display:none><div class=toc-article><div class=toc-title>文章目录</div></div></div><div class=post-content><p>uloop是OpenWrt基础库libubox的核心模块，提供事件驱动功能。</p><p>其主体框架由uloop_init、uloop_run_timeout和uloop_done三个函数构成，分别完成初始化、事件处理循环和清理工作。</p><p>uloop支持五大核心功能：</p><ol><li>文件描述符监控基于epoll实现，通过epoll_wait处理就绪事件；</li><li>定时器事件在循环中检测超时；</li><li>子进程管理响应SIGCHLD信号；</li><li>信号处理通过管道实现；</li><li>间隔定时器依赖文件描述符机制。</li></ol><h2 id=主体框架><a href=#%e4%b8%bb%e4%bd%93%e6%a1%86%e6%9e%b6>主体框架</a></h2><p>uloop循环的主体框架有三个函数构成，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_init</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_run_timeout</span><span class=p>(</span><span class=kt>int</span> <span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>int</span> <span class=nf>uloop_run</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>uloop_run_timeout</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>uloop_done</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>在这个框架中，文件描述符事件、定时器事件以及子进程管理事件均在<code>uloop_run_timeout</code>函数中处理，而信号处理事件、间隔定时器事件依赖于文件描述符事件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nf>uloop_init_pollfd</span><span class=p>()</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nf>waker_init</span><span class=p>()</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>uloop_done</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>uloop_setup_signals</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>从实现上看，<code>uloop_init</code>函数主要实现了三点功能：</p><ol><li><code>epoll</code>的初始化</li><li>信号处理管道的初始化</li><li>设置<code>SIGINT</code>、<code>SIGTERM</code>、<code>SIGCHLD</code>等内置处理</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_run_timeout</span><span class=p>(</span><span class=kt>int</span> <span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>next_time</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>uloop_run_depth</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 收到SIGINT或SIGTERM信号时会设置uloop_status=signo uloop_cancelled=true
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>uloop_status</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uloop_cancelled</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 处理定时器事件
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 每次都会检测是否有定时器事件超时
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>uloop_process_timeouts</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// do_sigchld表示是否收到SIGCHLD信号，然后处理进程事件
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>do_sigchld</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 只有收到SIGCHLD信号才会处理进程事件
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>uloop_handle_processes</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>uloop_cancelled</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>next_time</span> <span class=o>=</span> <span class=nf>uloop_get_next_timeout</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>timeout</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>next_time</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>timeout</span> <span class=o>&lt;</span> <span class=n>next_time</span><span class=p>))</span>
</span></span><span class=line><span class=cl>				<span class=n>next_time</span> <span class=o>=</span> <span class=n>timeout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 处理文件描述符事件
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 依靠定时器事件中的所需的事件作为epoll_wait的等待事件，如果没有定时器事件则会传入-1永远等待，而不是一直循环消耗CPU
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>uloop_run_events</span><span class=p>(</span><span class=n>next_time</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>uloop_cancelled</span> <span class=o>&amp;&amp;</span> <span class=n>timeout</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=o>--</span><span class=n>uloop_run_depth</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>uloop_status</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在<code>uloop_run_timeout</code>函数中可以看到该函数是在<code>do while</code>循环中依次处理超时定时器事件、子进程管理事件以及文件描述符事件。</p><p><code>uloop_run_depth</code>用于表示循环是否在执行中，<code>uloop_status</code>会在收到<code>SIGINT</code>或<code>SIGTERM</code>信号时被设置为<code>signo</code>，与此同时<code>uloop_cancelled</code>会被设置为<code>true</code>，表示要终止循环。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>uloop_done</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>uloop_setup_signals</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>poll_fd</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>close</span><span class=p>(</span><span class=n>poll_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>poll_fd</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>waker_pipe</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>uloop_fd_delete</span><span class=p>(</span><span class=o>&amp;</span><span class=n>waker_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=nf>close</span><span class=p>(</span><span class=n>waker_pipe</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=nf>close</span><span class=p>(</span><span class=n>waker_fd</span><span class=p>.</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>waker_pipe</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>uloop_clear_timeouts</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=nf>uloop_clear_processes</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在<code>uloop_done</code>函数中，则是进行一些清理动作</p><ol><li>给<code>uloop_setup_signals</code>函数传入<code>false</code>，恢复原来的信号处理逻辑</li><li>删除信号处理管道</li><li>清理超时定时器事件、子进程处理事件链表。</li></ol><h2 id=文件描述符事件><a href=#%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6%e4%ba%8b%e4%bb%b6>文件描述符事件</a></h2><p>uloop的文件描述符事件是基于<code>epoll</code>的，通过<code>epoll_wait</code>返回就绪的文件描述符数目和事件，然后在进行遍历处理。</p><p>文件描述符事件相关的接口如下:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>uloop_fd</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>uloop_fd_handler</span> <span class=n>cb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=n>eof</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// registered字段用来标识是否已经注册到poll中
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>bool</span> <span class=n>registered</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 回调函数原型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=n>uloop_fd_handler</span><span class=p>)(</span><span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>u</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>events</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 添加或删除文件描述符事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>uloop_fd_add</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>sock</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_fd_delete</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>sock</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=初始化><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96>初始化</a></h3><p>首先是在<code>uloop_init</code>中初始化<code>epoll</code>，函数实现如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>uloop_init_pollfd</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>poll_fd</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>poll_fd</span> <span class=o>=</span> <span class=nf>epoll_create</span><span class=p>(</span><span class=mi>32</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>poll_fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>fcntl</span><span class=p>(</span><span class=n>poll_fd</span><span class=p>,</span> <span class=n>F_SETFD</span><span class=p>,</span> <span class=nf>fcntl</span><span class=p>(</span><span class=n>poll_fd</span><span class=p>,</span> <span class=n>F_GETFD</span><span class=p>)</span> <span class=o>|</span> <span class=n>FD_CLOEXEC</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在<code>uloop_init_pollfd</code>中执行了两个操作</p><ol><li>创建<code>epoll</code>文件描述符，最多监控32个文件描述符</li><li>设置close-on-exec标志</li></ol><h3 id=添加描述符事件><a href=#%e6%b7%bb%e5%8a%a0%e6%8f%8f%e8%bf%b0%e7%ac%a6%e4%ba%8b%e4%bb%b6>添加描述符事件</a></h3><p>在<code>epoll</code>初始化完成之后，接下来就是用户添加文件描述符事件了，uloop对外暴露的函数是<code>uloop_fd_add</code>，其实现逻辑如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_fd_add</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>sock</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>fl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>ULOOP_READ</span> <span class=o>|</span> <span class=n>ULOOP_WRITE</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 非读非写，删除描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=nf>uloop_fd_delete</span><span class=p>(</span><span class=n>sock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>sock</span><span class=o>-&gt;</span><span class=n>registered</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ULOOP_BLOCKING</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 未注册并且非阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>fl</span> <span class=o>=</span> <span class=nf>fcntl</span><span class=p>(</span><span class=n>sock</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_GETFL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>fl</span> <span class=o>|=</span> <span class=n>O_NONBLOCK</span><span class=p>;</span> <span class=c1>// 设置非阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>fcntl</span><span class=p>(</span><span class=n>sock</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_SETFL</span><span class=p>,</span> <span class=n>fl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// register_poll中使用epoll_ctl将文件描述符加入到epoll等待队列
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>ret</span> <span class=o>=</span> <span class=nf>register_poll</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 设置用于添加、删除文件描述事件的回调
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>uloop_fd_set_cb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>uloop_fd_set_cb</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>sock</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>sock</span><span class=o>-&gt;</span><span class=n>registered</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>sock</span><span class=o>-&gt;</span><span class=n>eof</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>sock</span><span class=o>-&gt;</span><span class=n>error</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>out</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>register_poll</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>fd</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>ev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>op</span> <span class=o>=</span> <span class=n>fd</span><span class=o>-&gt;</span><span class=n>registered</span> <span class=o>?</span> <span class=nl>EPOLL_CTL_MOD</span> <span class=p>:</span> <span class=n>EPOLL_CTL_ADD</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ev</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>epoll_event</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// EPOLLRDHUP用于接收对端关闭的事件通知
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ULOOP_READ</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>ev</span><span class=p>.</span><span class=n>events</span> <span class=o>|=</span> <span class=n>EPOLLIN</span> <span class=o>|</span> <span class=n>EPOLLRDHUP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ULOOP_WRITE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>ev</span><span class=p>.</span><span class=n>events</span> <span class=o>|=</span> <span class=n>EPOLLOUT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 是否设置边沿触发
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 设置边沿触发，收到事件但是未处理，之后事件不会再进行通知
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 水平触发则是收到事件但是未处理，则会反复通知
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ULOOP_EDGE_TRIGGER</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>ev</span><span class=p>.</span><span class=n>events</span> <span class=o>|=</span> <span class=n>EPOLLET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>ev</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>epoll_ctl</span><span class=p>(</span><span class=n>poll_fd</span><span class=p>,</span> <span class=n>op</span><span class=p>,</span> <span class=n>fd</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ev</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在<code>uloop_fd_add</code>函数中，首先会判断添加文件描述符的标志是否为<code>ULOOP_READ|ULOOP_WRITE</code>，如果不是则会调用<code>uloop_fd_delete</code>删除该文件描述符事件。</p><p>其次改变文件描述符的默认阻塞状态，如果文件描述符未注册，并且也未传入阻塞标志，则设置为非阻塞状态。正常情况下，系统创建的文件描述符是阻塞的。</p><p>接下来调用<code>register_poll</code>将文件描述符注册到<code>epoll</code>事件中，如果之前已经注册，则对其进行修改。</p><p>最后判断是否有设置文件描述符事件添加、删除回调（通过接口<code>uloop_fd_set_cb</code>），如果有设置，则执行该回调。</p><h3 id=执行逻辑><a href=#%e6%89%a7%e8%a1%8c%e9%80%bb%e8%be%91>执行逻辑</a></h3><p>文件描述符事件和定时器超时事件、子进程管理事件均是在<code>uloop_run_timeout</code>函数中进行处理的。</p><p>下面是<code>uloop_run_timeout</code>函数的实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_run_timeout</span><span class=p>(</span><span class=kt>int</span> <span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>next_time</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>uloop_run_depth</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 收到SIGINT或SIGTERM信号时会设置uloop_status=signo uloop_cancelled=true
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>uloop_status</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uloop_cancelled</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 处理定时器事件
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 每次都会检测是否有定时器事件超时
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>uloop_process_timeouts</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// do_sigchld表示是否收到SIGCHLD信号，然后处理进程事件
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>do_sigchld</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 只有收到SIGCHLD信号才会处理进程事件
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>uloop_handle_processes</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>uloop_cancelled</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>next_time</span> <span class=o>=</span> <span class=nf>uloop_get_next_timeout</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>timeout</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>next_time</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>timeout</span> <span class=o>&lt;</span> <span class=n>next_time</span><span class=p>))</span>
</span></span><span class=line><span class=cl>				<span class=n>next_time</span> <span class=o>=</span> <span class=n>timeout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 处理文件描述符事件
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 依靠定时器事件中的所需的事件作为epoll_wait的等待事件，如果没有定时器事件则会传入-1永远等待，而不是一直循环消耗CPU
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>uloop_run_events</span><span class=p>(</span><span class=n>next_time</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>uloop_cancelled</span> <span class=o>&amp;&amp;</span> <span class=n>timeout</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=o>--</span><span class=n>uloop_run_depth</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>uloop_status</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 该函数用于确定epoll_wait的等待时间
</span></span></span><span class=line><span class=cl><span class=c1>// 如果超时事件链表timeouts为空，则返回-1，会使epoll_wait阻塞，持续等待
</span></span></span><span class=line><span class=cl><span class=c1>// 如果超时事件链表不为空，则去获取第一个超时事件，判断是否超时：
</span></span></span><span class=line><span class=cl><span class=c1>// 1. 如果超时，则返回0，epoll_wait不阻塞直接返回
</span></span></span><span class=line><span class=cl><span class=c1>// 2. 如果未超时，则返回INT_MAX，用来设置epoll_wait的等待时间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>uloop_get_next_timeout</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_timeout</span> <span class=o>*</span><span class=n>timeout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>timeval</span> <span class=n>tv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int64_t</span> <span class=n>diff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nf>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>timeouts</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 如果没有超时事件，则返回-1，导致epoll_wait持续等待
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>uloop_gettime</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 如果有超时事件，并且已经超时，则返回0，如果没有超时则返回INT_MAX
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>timeout</span> <span class=o>=</span> <span class=nf>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=n>timeouts</span><span class=p>,</span> <span class=k>struct</span> <span class=n>uloop_timeout</span><span class=p>,</span> <span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>diff</span> <span class=o>=</span> <span class=nf>tv_diff</span><span class=p>(</span><span class=o>&amp;</span><span class=n>timeout</span><span class=o>-&gt;</span><span class=n>time</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>diff</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 当前时间大于定时器中设置的时间，定时器事件已经超时
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>diff</span> <span class=o>&gt;</span> <span class=n>INT_MAX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>INT_MAX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>diff</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在<code>uloop_run_timeout</code>函数中有两个和文件描述符事件相关的操作：</p><ol><li>通过<code>uloop_get_next_timeout</code>函数获取等待时间，该时间用于<code>epoll_wait</code>等待。</li><li>通过<code>uloop_run_events</code>函数具体获取就绪的文件描述符状态并处理执行回调。</li></ol><p>在<code>uloop_get_next_timeout</code>函数中执行以下操作：</p><ol><li>判断超时定时器事件链表是否为空，如果为空则返回-1。</li><li>获取超时定时器链表中的第一个定时器事件的剩余时间，如果已超时则返回0，否则返回剩余时间。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 保存文件描述符和对应的事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>uloop_fd_event</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 用来保存所有描述符事件的链表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>uloop_fd_stack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_fd_stack</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>uloop_fd_stack</span> <span class=o>*</span><span class=n>fd_stack</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define ULOOP_MAX_EVENTS 10
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// cur_fds中记录epoll返回的就绪的文件描述符事件
</span></span></span><span class=line><span class=cl><span class=c1>// cur_nfds记录就绪的文件描述符状态
</span></span></span><span class=line><span class=cl><span class=c1>// cur_fd记录正在处理的文件描述符索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=k>struct</span> <span class=n>uloop_fd_event</span> <span class=n>cur_fds</span><span class=p>[</span><span class=n>ULOOP_MAX_EVENTS</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>cur_fd</span><span class=p>,</span> <span class=n>cur_nfds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 使用cur_nfds判断是否有上次未处理完的已就绪的文件描述符，如果有未处理完的则会继续处理，而非获取新的
</span></span></span><span class=line><span class=cl><span class=c1>// 调用uloop_fetch_events获取新的已就绪的文件描述符，cur_nfds用来标识已就绪的文件描述符数
</span></span></span><span class=line><span class=cl><span class=c1>// uloop_fetch_events中对于每个已就绪的文件描述符，其对应的事件保存在cur_fds[]数组中，最大能够保存10个就绪事件
</span></span></span><span class=line><span class=cl><span class=c1>// cur_fd是已就绪文件描述cur_fds[]索引，每次获取到已就绪文件描述符，会将其重置为0
</span></span></span><span class=line><span class=cl><span class=c1>// 在while循环中从cur_fds中以此取出就绪的文件描述符，在do while循环中以此取出文件描述符对应的每个事件，执行对应的fd-&gt;cb()
</span></span></span><span class=line><span class=cl><span class=c1>// uloop_fd_stack_event函数的作用在于避免递归调用过程中多次执行fd-&gt;cb()，当第一次调用之后就会将文件描述符的事件信息入栈，如果fd-&gt;cb()中再次调用uloop_run_events，第二次就会返回true然后跳过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>uloop_run_events</span><span class=p>(</span><span class=kt>int64_t</span> <span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_fd_event</span> <span class=o>*</span><span class=n>cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>cur_nfds</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>cur_fd</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 获取就绪的文件描述符，timeout用于表示epoll_wait的阻塞事件,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 从该参数的来源可以看到，如果没有定时器事件就取-1，表示永远阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 如果有定时器事件，就判断定时器事件列表中的第一个事件，是否超时，如果已超时就取0，表示立即返回不等待。如果未超时，就取所需时间作为epoll_wait的等待时间
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>cur_nfds</span> <span class=o>=</span> <span class=nf>uloop_fetch_events</span><span class=p>(</span><span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>cur_nfds</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>cur_nfds</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=p>(</span><span class=n>cur_nfds</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>struct</span> <span class=n>uloop_fd_stack</span> <span class=n>stack_cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>cur</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>cur_fds</span><span class=p>[</span><span class=n>cur_fd</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=n>cur_nfds</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>fd</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>events</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>fd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>fd</span><span class=o>-&gt;</span><span class=n>cb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// 第一次进入之后这个函数发现栈为空，返回false，然后下面将fd事件入栈
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 如果在fd-&gt;cb()中再次调用uloop_run_events，第二次执行到uloop_fd_stack_event，会保留第二次的新事件（通过传入的cur-&gt;events）并标记事件为缓存状态，返回true，然后跳过下面的部分，使fd-&gt;cb()退出。
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 但是如果第二次的事件中包含ULOOP_EVENT_MASK，那么在fd-&gt;cb()退出之后，会发现还存在待处理的events，会在do while中再次循环处理
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 如果没有这个处理，则会再次执行fd-&gt;cb()
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=nf>uloop_fd_stack_event</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>events</span><span class=p>))</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// fd_stack 入栈（链表头部插入）
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>stack_cur</span><span class=p>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>fd_stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>stack_cur</span><span class=p>.</span><span class=n>fd</span> <span class=o>=</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>fd_stack</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>stack_cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>stack_cur</span><span class=p>.</span><span class=n>events</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>fd</span><span class=o>-&gt;</span><span class=nf>cb</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>events</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 如果第二次触发的事件中包含ULOOP_READ或ULOOP_WRITE，那么stack_cur.events则为ULOOP_READ|ULOOP_WRITE|ULOOP_EVENT_BUFFERED，
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 这将会导致再次进入循环执行一次回调
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 如果没有ULOOP_EVENT_MASK时则不会再次执行回调，满足避免递归执行的要求
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>events</span> <span class=o>=</span> <span class=n>stack_cur</span><span class=p>.</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>ULOOP_EVENT_MASK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>stack_cur</span><span class=p>.</span><span class=n>fd</span> <span class=o>&amp;&amp;</span> <span class=n>events</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 出栈
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>fd_stack</span> <span class=o>=</span> <span class=n>stack_cur</span><span class=p>.</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>uloop_fetch_events</span><span class=p>(</span><span class=kt>int</span> <span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=n>nfds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 返回就绪的文件描述符数，超时返回0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// timeout -1无限期阻塞，0立即返回
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>nfds</span> <span class=o>=</span> <span class=nf>epoll_wait</span><span class=p>(</span><span class=n>poll_fd</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=nf>ARRAY_SIZE</span><span class=p>(</span><span class=n>events</span><span class=p>),</span> <span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>n</span> <span class=o>&lt;</span> <span class=n>nfds</span><span class=p>;</span> <span class=o>++</span><span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>struct</span> <span class=n>uloop_fd_event</span> <span class=o>*</span><span class=n>cur</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>cur_fds</span><span class=p>[</span><span class=n>n</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>u</span> <span class=o>=</span> <span class=n>events</span><span class=p>[</span><span class=n>n</span><span class=p>].</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>ev</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>cur</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>n</span><span class=p>].</span><span class=n>events</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>EPOLLERR</span><span class=o>|</span><span class=n>EPOLLHUP</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>u</span><span class=o>-&gt;</span><span class=n>error</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ULOOP_ERROR_CB</span><span class=p>))</span>
</span></span><span class=line><span class=cl>				<span class=nf>uloop_fd_delete</span><span class=p>(</span><span class=n>u</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>n</span><span class=p>].</span><span class=n>events</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>EPOLLRDHUP</span><span class=o>|</span><span class=n>EPOLLIN</span><span class=o>|</span><span class=n>EPOLLOUT</span><span class=o>|</span><span class=n>EPOLLERR</span><span class=o>|</span><span class=n>EPOLLHUP</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>cur</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>n</span><span class=p>].</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>EPOLLRDHUP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>u</span><span class=o>-&gt;</span><span class=n>eof</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>n</span><span class=p>].</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>EPOLLIN</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>ev</span> <span class=o>|=</span> <span class=n>ULOOP_READ</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>n</span><span class=p>].</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>EPOLLOUT</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>ev</span> <span class=o>|=</span> <span class=n>ULOOP_WRITE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>cur</span><span class=o>-&gt;</span><span class=n>events</span> <span class=o>=</span> <span class=n>ev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>nfds</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>uloop_fd_stack_event</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>fd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>events</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_fd_stack</span> <span class=o>*</span><span class=n>cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	 * Do not buffer events for level-triggered fds, they will keep firing.
</span></span></span><span class=line><span class=cl><span class=cm>	 * Caller needs to take care of recursion issues.
</span></span></span><span class=line><span class=cl><span class=cm>	 */</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1>// 如果是水平触发，则返回false，因为事件反复通知是正常情况
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 如果是边沿触发，则需要缓存事件，防止多次调用事件描述符回调函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>fd</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ULOOP_EDGE_TRIGGER</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 从栈顶往下遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=n>cur</span> <span class=o>=</span> <span class=n>fd_stack</span><span class=p>;</span> <span class=n>cur</span><span class=p>;</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>cur</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>!=</span> <span class=n>fd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>events</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>cur</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 和传入的fd相等，标记事件为缓存状态
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 保存触发的事件和缓存标志
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 如果触发的事件events中包含读写事件(ULOOP_EVENT_MASK)，则仍旧会执行回调
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>cur</span><span class=o>-&gt;</span><span class=n>events</span> <span class=o>|=</span> <span class=n>events</span> <span class=o>|</span> <span class=n>ULOOP_EVENT_BUFFERED</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在<code>uloop_run_events</code>函数中接收一个<code>timeout</code>参数，该参数被用来传递给<code>uloop_fetch_events</code>函数，最终传递给<code>epoll_wait</code>函数，用于指示<code>epoll_wait</code>函数的动作。</p><p>从<code>uloop_get_next_timeout</code>函数的执行逻辑可以看到</p><ol><li>当<code>timeout</code>为-1时，表示超时定时器事件链表为空，此时<code>epoll_wait</code>就会永远等待，此时<code>uloop_run_timeout</code>中的循环就会阻塞，不会浪费CPU资源。</li><li>而当超时定时器事件列表不为空时，就会等待指定时间（这里的指定时间指的是超时定时器链表中第一个定时器事件的剩余时间）以便在<code>uloop_run_timeout</code>函数的循环中及时处理超时定时器事件。</li></ol><p>在<code>uloop_run_events</code>函数中可以看到</p><ol><li>首先通过<code>cur_nfds</code>变量判断是否还有未处理的已就绪的文件描述符时间，如果有则直接执行循环先进行处理，否则就调用<code>uloop_fetch_events</code>函数获取新的就绪的文件描述符，并将其保存在<code>cur_fds</code>数组中，就绪的文件描述符数量则保存在<code>cur_nfds</code>变量中。</li><li>然后在<code>while</code>循环中逐个处理文件描述符事件，其中<code>cur_fd</code>表示文件描述符事件数组<code>cur_fds</code>数组的索引。</li><li>最后会调用<code>fd->cb()</code>执行文件描述符事件回调。</li><li>至于<code>uloop_fd_stack</code>结构体和<code>uloop_fd_stack_event</code>函数则是一个很有意思的操作，下面详细解释其作用。</li></ol><h3 id=uloop_fd_stack_event函数机制><a href=#uloop_fd_stack_event%e5%87%bd%e6%95%b0%e6%9c%ba%e5%88%b6>uloop_fd_stack_event函数机制</a></h3><p>下面是<code>uloop_fd_stack</code>结构体和<code>uloop_fd_stack_event</code>函数的相关提交：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>commit</span> <span class=n>b9ebdbcc648274cc630b6349374f9fb21e53f396</span>
</span></span><span class=line><span class=cl><span class=nl>Author</span><span class=p>:</span> <span class=n>Felix</span> <span class=n>Fietkau</span> <span class=o>&lt;</span><span class=n>nbd</span><span class=err>@</span><span class=n>openwrt</span><span class=p>.</span><span class=n>org</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=nl>Date</span><span class=p>:</span>   <span class=n>Tue</span> <span class=n>Jun</span> <span class=mi>18</span> <span class=mi>12</span><span class=o>:</span><span class=mo>01</span><span class=o>:</span><span class=mi>08</span> <span class=mi>2013</span> <span class=o>+</span><span class=mo>0200</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nl>uloop</span><span class=p>:</span> <span class=n>fix</span> <span class=n>corner</span> <span class=n>cases</span> <span class=n>with</span> <span class=n>recursive</span> <span class=n>uloop_run</span> <span class=n>calls</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>With</span> <span class=n>multiple</span> <span class=n>recursive</span> <span class=n>calls</span> <span class=n>to</span> <span class=n>uloop_run</span><span class=p>,</span> <span class=n>the</span> <span class=n>callback</span> <span class=k>for</span> <span class=n>the</span> <span class=n>same</span> <span class=n>fd</span>
</span></span><span class=line><span class=cl>    <span class=n>can</span> <span class=n>be</span> <span class=n>run</span> <span class=n>multiple</span> <span class=n>times</span> <span class=n>from</span> <span class=n>different</span> <span class=n>levels</span> <span class=n>in</span> <span class=n>the</span> <span class=n>stack</span><span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=n>Prevent</span> <span class=n>this</span> <span class=n>by</span> <span class=n>tracking</span> <span class=n>the</span> <span class=n>stack</span> <span class=n>of</span> <span class=n>uloop_fd</span> <span class=n>callbacks</span> <span class=n>and</span> <span class=n>buffering</span> <span class=n>new</span>
</span></span><span class=line><span class=cl>    <span class=n>incoming</span> <span class=n>events</span> <span class=k>for</span> <span class=n>fds</span> <span class=n>already</span> <span class=n>on</span> <span class=n>the</span> <span class=n>stack</span><span class=p>.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Signed</span><span class=o>-</span><span class=n>off</span><span class=o>-</span><span class=nl>by</span><span class=p>:</span> <span class=n>Felix</span> <span class=n>Fietkau</span> <span class=o>&lt;</span><span class=n>nbd</span><span class=err>@</span><span class=n>openwrt</span><span class=p>.</span><span class=n>org</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>diff</span> <span class=o>--</span><span class=n>git</span> <span class=n>a</span><span class=o>/</span><span class=n>uloop</span><span class=p>.</span><span class=n>c</span> <span class=n>b</span><span class=o>/</span><span class=n>uloop</span><span class=p>.</span><span class=n>c</span>
</span></span><span class=line><span class=cl><span class=n>index</span> <span class=n>bf13199</span><span class=p>.</span><span class=mf>.54</span><span class=n>ebe8d</span> <span class=mi>100644</span>
</span></span><span class=line><span class=cl><span class=o>---</span> <span class=n>a</span><span class=o>/</span><span class=n>uloop</span><span class=p>.</span><span class=n>c</span>
</span></span><span class=line><span class=cl><span class=o>+++</span> <span class=n>b</span><span class=o>/</span><span class=n>uloop</span><span class=p>.</span><span class=n>c</span>
</span></span><span class=line><span class=cl><span class=err>@@</span> <span class=o>-</span><span class=mi>43</span><span class=p>,</span><span class=mi>6</span> <span class=o>+</span><span class=mi>43</span><span class=p>,</span><span class=mi>14</span> <span class=err>@@</span> <span class=k>struct</span> <span class=n>uloop_fd_event</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=k>struct</span> <span class=n>uloop_fd_stack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span>       <span class=k>struct</span> <span class=n>uloop_fd_stack</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>       <span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>       <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=k>static</span> <span class=k>struct</span> <span class=n>uloop_fd_stack</span> <span class=o>*</span><span class=n>fd_stack</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl> <span class=cp>#define ULOOP_MAX_EVENTS 10
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl> <span class=k>static</span> <span class=k>struct</span> <span class=n>list_head</span> <span class=n>timeouts</span> <span class=o>=</span> <span class=nf>LIST_HEAD_INIT</span><span class=p>(</span><span class=n>timeouts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=err>@@</span> <span class=o>-</span><span class=mi>285</span><span class=p>,</span><span class=mi>6</span> <span class=o>+</span><span class=mi>293</span><span class=p>,</span><span class=mi>32</span> <span class=err>@@</span> <span class=k>static</span> <span class=kt>int</span> <span class=nf>uloop_fetch_events</span><span class=p>(</span><span class=kt>int</span> <span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=k>static</span> <span class=kt>bool</span> <span class=nf>uloop_fd_stack_event</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>fd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>events</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span>       <span class=k>struct</span> <span class=n>uloop_fd_stack</span> <span class=o>*</span><span class=n>cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl><span class=o>+</span>       <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>+        * Do not buffer events for level-triggered fds, they will keep firing.
</span></span></span><span class=line><span class=cl><span class=cm>+        * Caller needs to take care of recursion issues.
</span></span></span><span class=line><span class=cl><span class=cm>+        */</span>
</span></span><span class=line><span class=cl><span class=o>+</span>       <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>fd</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ULOOP_EDGE_TRIGGER</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl><span class=o>+</span>       <span class=k>for</span> <span class=p>(</span><span class=n>cur</span> <span class=o>=</span> <span class=n>fd_stack</span><span class=p>;</span> <span class=n>cur</span><span class=p>;</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=k>if</span> <span class=p>(</span><span class=n>cur</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>!=</span> <span class=n>fd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>+</span>                       <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=k>if</span> <span class=p>(</span><span class=n>events</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>+</span>                       <span class=n>cur</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=k>else</span>
</span></span><span class=line><span class=cl><span class=o>+</span>                       <span class=n>cur</span><span class=o>-&gt;</span><span class=n>events</span> <span class=o>|=</span> <span class=n>events</span> <span class=o>|</span> <span class=n>ULOOP_EVENT_BUFFERED</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>       <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl><span class=o>+</span>       <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl> <span class=k>static</span> <span class=kt>void</span> <span class=nf>uloop_run_events</span><span class=p>(</span><span class=kt>int</span> <span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>uloop_fd_event</span> <span class=o>*</span><span class=n>cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=err>@@</span> <span class=o>-</span><span class=mi>298</span><span class=p>,</span><span class=mi>17</span> <span class=o>+</span><span class=mi>332</span><span class=p>,</span><span class=mi>33</span> <span class=err>@@</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>uloop_run_events</span><span class=p>(</span><span class=kt>int</span> <span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>cur_nfds</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=k>struct</span> <span class=n>uloop_fd_stack</span> <span class=n>stack_cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl>                <span class=n>cur</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>cur_fds</span><span class=p>[</span><span class=n>cur_fd</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>cur_nfds</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>fd</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=n>events</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>fd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>fd</span><span class=o>-&gt;</span><span class=n>cb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>-</span>               <span class=n>fd</span><span class=o>-&gt;</span><span class=nf>cb</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>events</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=k>if</span> <span class=p>(</span><span class=nf>uloop_fd_stack_event</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>events</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=o>+</span>                       <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=n>stack_cur</span><span class=p>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>fd_stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=n>stack_cur</span><span class=p>.</span><span class=n>fd</span> <span class=o>=</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=n>fd_stack</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>stack_cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span>                       <span class=n>stack_cur</span><span class=p>.</span><span class=n>events</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>                       <span class=n>fd</span><span class=o>-&gt;</span><span class=nf>cb</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>events</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>+</span>                       <span class=n>events</span> <span class=o>=</span> <span class=n>stack_cur</span><span class=p>.</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>ULOOP_EVENT_MASK</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>stack_cur</span><span class=p>.</span><span class=n>fd</span> <span class=o>&amp;&amp;</span> <span class=n>events</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>+</span>               <span class=n>fd_stack</span> <span class=o>=</span> <span class=n>stack_cur</span><span class=p>.</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=err>@@</span> <span class=o>-</span><span class=mi>352</span><span class=p>,</span><span class=mi>6</span> <span class=o>+</span><span class=mi>402</span><span class=p>,</span><span class=mi>7</span> <span class=err>@@</span> <span class=kt>int</span> <span class=nf>uloop_fd_delete</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>fd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>cur_fds</span><span class=p>[</span><span class=n>cur_fd</span> <span class=o>+</span> <span class=n>i</span><span class=p>].</span><span class=n>fd</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>fd</span><span class=o>-&gt;</span><span class=n>registered</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>       <span class=nf>uloop_fd_stack_event</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>__uloop_fd_delete</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>diff</span> <span class=o>--</span><span class=n>git</span> <span class=n>a</span><span class=o>/</span><span class=n>uloop</span><span class=p>.</span><span class=n>h</span> <span class=n>b</span><span class=o>/</span><span class=n>uloop</span><span class=p>.</span><span class=n>h</span>
</span></span><span class=line><span class=cl><span class=n>index</span> <span class=mi>39</span><span class=n>b9b58</span><span class=p>.</span><span class=mf>.98</span><span class=n>dd818</span> <span class=mi>100644</span>
</span></span><span class=line><span class=cl><span class=o>---</span> <span class=n>a</span><span class=o>/</span><span class=n>uloop</span><span class=p>.</span><span class=n>h</span>
</span></span><span class=line><span class=cl><span class=o>+++</span> <span class=n>b</span><span class=o>/</span><span class=n>uloop</span><span class=p>.</span><span class=n>h</span>
</span></span><span class=line><span class=cl><span class=err>@@</span> <span class=o>-</span><span class=mi>44</span><span class=p>,</span><span class=mi>8</span> <span class=o>+</span><span class=mi>44</span><span class=p>,</span><span class=mi>13</span> <span class=err>@@</span> <span class=k>typedef</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>uloop_process_handler</span><span class=p>)(</span><span class=k>struct</span> <span class=n>uloop_process</span> <span class=o>*</span><span class=n>c</span><span class=p>,</span> <span class=kt>int</span> <span class=n>ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=cp>#define ULOOP_WRITE            (1 &lt;&lt; 1)
</span></span></span><span class=line><span class=cl><span class=cp></span> <span class=cp>#define ULOOP_EDGE_TRIGGER     (1 &lt;&lt; 2)
</span></span></span><span class=line><span class=cl><span class=cp></span> <span class=cp>#define ULOOP_BLOCKING         (1 &lt;&lt; 3)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=o>+</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=err>#</span><span class=n>define</span> <span class=nf>ULOOP_EVENT_MASK</span>       <span class=p>(</span><span class=n>ULOOP_READ</span> <span class=o>|</span> <span class=n>ULOOP_WRITE</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=cm>/* internal flags */</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=err>#</span><span class=n>define</span> <span class=nf>ULOOP_EVENT_BUFFERED</span>   <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=cp>#ifdef USE_KQUEUE
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=o>-</span><span class=err>#</span><span class=n>define</span> <span class=nf>ULOOP_EDGE_DEFER</span>       <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=err>#</span><span class=n>define</span> <span class=nf>ULOOP_EDGE_DEFER</span>       <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl> <span class=k>struct</span> <span class=n>uloop_fd</span>
</span></span></code></pre></div><p>考虑一下这种场景，在没有引入这次提交之前，在<code>uloop_run_events</code>函数中会直接执行文件描述符事件的回调。如果仅注册了一个文件描述符事件并且该描述符事件回调中调用了<code>uloop_run</code>函数，假设该文件描述符已就绪（<code>cur_nfds</code>为1），在<code>while</code>循环中调用回调之前会执行<code>cur_nfds--</code>，此时<code>cur_nfds</code>为0（满足接收该文件描述符新就绪事件的条件），在执行的该文件描述符事件回调的过程中又执行到<code>uloop_run_events</code>函数，此时存在两种情况，一是收到该文件描述符上的新就绪事件，二是没有收到该文件描述符上的就绪事件。</p><ol><li>对于情况一，在上次文件描述符事件的回调还没有执行完，这次又进入到回调中，很可能造成问题（取决于回调函数的处理逻辑）。</li><li>对于情况二，<code>uloop_run_envents</code>函数会直接返回，影响不大。</li></ol><p>从提交记录中可以看到，引入的这个操作就是用来解决<strong>在递归调用<code>uloop_run</code>函数（例如在回调函数中调用）时，文件描述符事件回调会被多次调用</strong>的情况。</p><p>对于上面的情况一，由于第一次收到就绪事件时已经将该文件描述符入栈（不包含该文件描述符就绪状态的事件，并且在执行回调之前也已清空<code>stack_cur.events = 0;</code>），因此此次可以从栈中查询到并返回<code>true</code>，跳过这次循环。那么问题来了，如果这次收到的就绪事件是正常的需要处理的读写事件呢，跳过之后可能就会发生遗漏（例如EPOLL的边沿触发，无论是否处理事件，仅会通知一次）。</p><p>对于这种情况的处理方式则是在跳过这次循环，在当前文件描述符回调执行结束之后，再次判断该文件描述符的就绪状态中是否有待处理的读写事件（因为第二次执行<code>uloop_fd_stack_event</code>时将新的就绪事件<code>events</code>和缓存标志<code>ULOOP_EVENT_BUFFERED</code>均赋值给当前文件描述符，即<code>cur->events |= events | ULOOP_EVENT_BUFFERED;</code>），如果有则在<code>do while</code>循环中再次调用回调，并且在调用回调之前将栈中该文件描述符的事件清空，用来接收下次就绪状态的事件。</p><p>在<code>uloop_fd_stack_event</code>函数中</p><ol><li>判断文件描述符标志是否为水平触发，如果是水平触发则不能阻止执行回调，因为有正常的未处理的就绪文件描述符事件。<code>epoll</code>的水平触发逻辑是如果收到就绪的文件描述符事件但未处理，那么后续会一直进行事件通知。</li><li>接下来从栈中查找是否有正在执行的文件描述符事件，如果有则设置标志<code>ULOOP_EVENT_BUFFERED</code>，并返回<code>true</code>。</li></ol><h3 id=销毁><a href=#%e9%94%80%e6%af%81>销毁</a></h3><p>文件描述符事件的销毁则容易的多，是通过<code>uloop_fd_delete</code>函数来执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_fd_delete</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>fd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 从描述符事件数组中删除对应的描述符指向的事件
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>cur_nfds</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>cur_fds</span><span class=p>[</span><span class=n>cur_fd</span> <span class=o>+</span> <span class=n>i</span><span class=p>].</span><span class=n>fd</span> <span class=o>!=</span> <span class=n>fd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>cur_fds</span><span class=p>[</span><span class=n>cur_fd</span> <span class=o>+</span> <span class=n>i</span><span class=p>].</span><span class=n>fd</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>fd</span><span class=o>-&gt;</span><span class=n>registered</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 未注册的话直接返回
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>uloop_fd_set_cb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>uloop_fd_set_cb</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fd</span><span class=o>-&gt;</span><span class=n>registered</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 从栈中清除文件描述符事件
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>uloop_fd_stack_event</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 从epoll表中清除
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>ret</span> <span class=o>=</span> <span class=nf>__uloop_fd_delete</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fd</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>__uloop_fd_delete</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>sock</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>sock</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>epoll_ctl</span><span class=p>(</span><span class=n>poll_fd</span><span class=p>,</span> <span class=n>EPOLL_CTL_DEL</span><span class=p>,</span> <span class=n>sock</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>该函数的处理逻辑如下：</p><ol><li>判断当前文件描述符是否处于就绪状态，如果是则从保存处于就绪状态的文件描述符事件数组<code>cur_fds[]</code>中删除。</li><li>如果该文件描述符没有注册到<code>epoll</code>中则直接返回，如果已经注册到<code>epoll</code>中，则下面通过<code>__uloop_fd_delete</code>函数从<code>epoll</code>中删除。</li><li>如果有设置文件描述符事件添加、删除回调，则执行回调。</li><li>通过向<code>uloop_fd_stack_event</code>函数传入-1参数，从保存文件描述符事件的栈中删除对应的条目。</li></ol><h2 id=定时器事件><a href=#%e5%ae%9a%e6%97%b6%e5%99%a8%e4%ba%8b%e4%bb%b6>定时器事件</a></h2><p>现在uloop支持两种定时器事件，分别是超时定时器和间隔定时器，以下是这两种定时器事件的接口</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>uloop_timeout</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// pending表示是否已经在等待中
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>bool</span> <span class=n>pending</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>uloop_timeout_handler</span> <span class=n>cb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 超时时间，会使用当前时间与这个时间对比，判断是否超时
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>timeval</span> <span class=n>time</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// 获取最近的定时器事件的剩余时间，如果不存在定时器事件则返回-1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>uloop_get_next_timeout</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_timeout_add</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_timeout</span> <span class=o>*</span><span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_timeout_set</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_timeout</span> <span class=o>*</span><span class=n>timeout</span><span class=p>,</span> <span class=kt>int</span> <span class=n>msecs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_timeout_cancel</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_timeout</span> <span class=o>*</span><span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_timeout_remaining</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_timeout</span> <span class=o>*</span><span class=n>timeout</span><span class=p>)</span> <span class=nf>__attribute__</span><span class=p>((</span><span class=nf>deprecated</span><span class=p>(</span><span class=s>&#34;use uloop_timeout_remaining64&#34;</span><span class=p>)));</span>
</span></span><span class=line><span class=cl><span class=c1>// 获取指定定时器事件的剩余时间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int64_t</span> <span class=nf>uloop_timeout_remaining64</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_timeout</span> <span class=o>*</span><span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 间隔定时器事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>uloop_interval</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>uloop_interval_handler</span> <span class=n>cb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 表示定时器的累计超时次数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>uint64_t</span> <span class=n>expirations</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>struct</span> <span class=n>uloop_fd</span> <span class=n>ufd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=kt>int64_t</span> <span class=n>fired</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msecs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=n>time</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=n>priv</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_interval_set</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_interval</span> <span class=o>*</span><span class=n>timer</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msecs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_interval_cancel</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_interval</span> <span class=o>*</span><span class=n>timer</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 获取定时器距离下次超时的剩余时间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int64_t</span> <span class=nf>uloop_interval_remaining</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_interval</span> <span class=o>*</span><span class=n>timer</span><span class=p>);</span>
</span></span></code></pre></div><p>这两种定时器的实现方式很不一样，下面分别介绍一下这两种定时器。</p><h3 id=超时定时器><a href=#%e8%b6%85%e6%97%b6%e5%ae%9a%e6%97%b6%e5%99%a8>超时定时器</a></h3><p>这种定时器的描述结构为<code>struct uloop_timeout</code>，从结构中基本就可以看出，这种定时器是保存在一个全局链表<code>static struct list_head timeouts = LIST_HEAD_INIT(timeouts);</code>中。</p><p>下面给出添加、设置以及取消定时器事件的处理代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int64_t</span> <span class=nf>tv_diff</span><span class=p>(</span><span class=k>struct</span> <span class=n>timeval</span> <span class=o>*</span><span class=n>t1</span><span class=p>,</span> <span class=k>struct</span> <span class=n>timeval</span> <span class=o>*</span><span class=n>t2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>(</span><span class=n>t1</span><span class=o>-&gt;</span><span class=n>tv_sec</span> <span class=o>-</span> <span class=n>t2</span><span class=o>-&gt;</span><span class=n>tv_sec</span><span class=p>)</span> <span class=o>*</span> <span class=mi>1000</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>		<span class=p>(</span><span class=n>t1</span><span class=o>-&gt;</span><span class=n>tv_usec</span> <span class=o>-</span> <span class=n>t2</span><span class=o>-&gt;</span><span class=n>tv_usec</span><span class=p>)</span> <span class=o>/</span> <span class=mi>1000</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_timeout_add</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_timeout</span> <span class=o>*</span><span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_timeout</span> <span class=o>*</span><span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span><span class=n>h</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>timeouts</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>timeout</span><span class=o>-&gt;</span><span class=n>pending</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>list_for_each_entry</span><span class=p>(</span><span class=n>tmp</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>timeouts</span><span class=p>,</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 链表的超时时间按照从小到达排列，找出插入当前超时事件的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 当前节点的超时时间大于新插入超时事件的时间时退出循环
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=nf>tv_diff</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmp</span><span class=o>-&gt;</span><span class=n>time</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>timeout</span><span class=o>-&gt;</span><span class=n>time</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>h</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>tmp</span><span class=o>-&gt;</span><span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 将timeout事件插入到h指向节点的前面
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>timeout</span><span class=o>-&gt;</span><span class=n>list</span><span class=p>,</span> <span class=n>h</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>timeout</span><span class=o>-&gt;</span><span class=n>pending</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>uloop_gettime</span><span class=p>(</span><span class=k>struct</span> <span class=n>timeval</span> <span class=o>*</span><span class=n>tv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>timespec</span> <span class=n>ts</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>clock_gettime</span><span class=p>(</span><span class=n>CLOCK_MONOTONIC</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ts</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>tv</span><span class=o>-&gt;</span><span class=n>tv_sec</span> <span class=o>=</span> <span class=n>ts</span><span class=p>.</span><span class=n>tv_sec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>tv</span><span class=o>-&gt;</span><span class=n>tv_usec</span> <span class=o>=</span> <span class=n>ts</span><span class=p>.</span><span class=n>tv_nsec</span> <span class=o>/</span> <span class=mi>1000</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_timeout_set</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_timeout</span> <span class=o>*</span><span class=n>timeout</span><span class=p>,</span> <span class=kt>int</span> <span class=n>msecs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>timeval</span> <span class=o>*</span><span class=n>time</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>timeout</span><span class=o>-&gt;</span><span class=n>time</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>timeout</span><span class=o>-&gt;</span><span class=n>pending</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>uloop_timeout_cancel</span><span class=p>(</span><span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 获取当前时间
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>uloop_gettime</span><span class=p>(</span><span class=n>time</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 设置超时时间
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>time</span><span class=o>-&gt;</span><span class=n>tv_sec</span> <span class=o>+=</span> <span class=n>msecs</span> <span class=o>/</span> <span class=mi>1000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>time</span><span class=o>-&gt;</span><span class=n>tv_usec</span> <span class=o>+=</span> <span class=p>(</span><span class=n>msecs</span> <span class=o>%</span> <span class=mi>1000</span><span class=p>)</span> <span class=o>*</span> <span class=mi>1000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>time</span><span class=o>-&gt;</span><span class=n>tv_usec</span> <span class=o>&gt;</span> <span class=mi>1000000</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>time</span><span class=o>-&gt;</span><span class=n>tv_sec</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>time</span><span class=o>-&gt;</span><span class=n>tv_usec</span> <span class=o>-=</span> <span class=mi>1000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 添加超时事件
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nf>uloop_timeout_add</span><span class=p>(</span><span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_timeout_cancel</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_timeout</span> <span class=o>*</span><span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>timeout</span><span class=o>-&gt;</span><span class=n>pending</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 双向链表移除只需要当前节点即可
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>timeout</span><span class=o>-&gt;</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>timeout</span><span class=o>-&gt;</span><span class=n>pending</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>uloop_timeout_add</code>函数用来添加定时器，其中定时器的超时时间已经保存在<code>struct uloop_timeout</code>结构体中并随参数传入，然后在定时器链表中按照剩余事件从小到大的顺序找到第一个大于新定时器事件的位置，并在该位置插入新定时器事件。</p><p><code>uloop_timeout_set</code>函数也用于设置定时器，但是由于传入的是超时的毫秒数，因此需要先计算出超时时间，然后再调用<code>uloop_timeout_add</code>插入到定时器链表中。</p><p><code>uloop_timeout_cancel</code>函数用于从定时器链表中删除指定的定时器事件。</p><p><code>uloop_timeout_remaining64</code>函数用于获取指定定时器事件的剩余时间：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int64_t</span> <span class=nf>uloop_timeout_remaining64</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_timeout</span> <span class=o>*</span><span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>timeval</span> <span class=n>now</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>timeout</span><span class=o>-&gt;</span><span class=n>pending</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>uloop_gettime</span><span class=p>(</span><span class=o>&amp;</span><span class=n>now</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>tv_diff</span><span class=p>(</span><span class=o>&amp;</span><span class=n>timeout</span><span class=o>-&gt;</span><span class=n>time</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>now</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=执行流程><a href=#%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b>执行流程</a></h3><p>超时定时器事件是在<code>uloop_run_timeout</code>函数的<code>do while</code>函数中通过调用<code>uloop_process_timeouts</code>函数来执行的，下面是<code>uloop_process_timeouts</code>函数的处理逻辑：</p><ol><li>判断定时器事件链表是否为空，如果为空则直接返回。</li><li>从定时器事件链表中取出第一个定时器事件，并判断是否超时，如果超时则通过<code>uloop_timeout_cancel</code>函数从该链表中删除（这里可以看出如果需要再次调用定时器，则需要在回调中再次进行设置），并执行回调；如果未超时则直接返回，因为定时器链表是按照超时时间从小到大的顺序排列。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 处理超时事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>uloop_process_timeouts</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_timeout</span> <span class=o>*</span><span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>timeval</span> <span class=n>tv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 判断超时事件列表是否为空
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=nf>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>timeouts</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 获取当前事件
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>uloop_gettime</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=nf>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>timeouts</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>t</span> <span class=o>=</span> <span class=nf>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=n>timeouts</span><span class=p>,</span> <span class=k>struct</span> <span class=n>uloop_timeout</span><span class=p>,</span> <span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// 判断第一个超时事件的时间是否已到达
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=nf>tv_diff</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>time</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tv</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// 如果已到达，则取消该事件
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>uloop_timeout_cancel</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 如果已设置回调，则调用回调
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>cb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>t</span><span class=o>-&gt;</span><span class=nf>cb</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=间隔定时器><a href=#%e9%97%b4%e9%9a%94%e5%ae%9a%e6%97%b6%e5%99%a8>间隔定时器</a></h3><p>间隔定时器使用<code>struct uloop_interval</code>来描述，该定时器主要使用标准C提供的定时器接口。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/timerfd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>timerfd_create</span><span class=p>(</span><span class=kt>int</span> <span class=n>clockid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>timerfd_settime</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>const</span> <span class=k>struct</span> <span class=n>itimerspec</span> <span class=o>*</span><span class=n>new_value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>struct</span> <span class=n>itimerspec</span> <span class=o>*</span><span class=n>_Nullable</span> <span class=n>old_value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>timerfd_gettime</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>itimerspec</span> <span class=o>*</span><span class=n>curr_value</span><span class=p>);</span>
</span></span></code></pre></div><p>该定时器的设置、取消以及获取指定定时器事件的剩余时间接口实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_interval_set</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_interval</span> <span class=o>*</span><span class=n>timer</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msecs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>timer_register</span><span class=p>(</span><span class=n>timer</span><span class=p>,</span> <span class=n>msecs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_interval_cancel</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_interval</span> <span class=o>*</span><span class=n>timer</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>timer_remove</span><span class=p>(</span><span class=n>timer</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int64_t</span> <span class=nf>uloop_interval_remaining</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_interval</span> <span class=o>*</span><span class=n>timer</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>timer_next</span><span class=p>(</span><span class=n>timer</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>timer_register</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_interval</span> <span class=o>*</span><span class=n>tm</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>msecs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 判断是否已经注册在文件描述符事件中
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>.</span><span class=n>registered</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// TFD_CLOEXEC和TFD_NONBLOCK用于对定时器文件描述符设置close-on-exec和非阻塞标志
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 创建定时器文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>timerfd_create</span><span class=p>(</span><span class=n>CLOCK_MONOTONIC</span><span class=p>,</span> <span class=n>TFD_CLOEXEC</span><span class=o>|</span><span class=n>TFD_NONBLOCK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>.</span><span class=n>fd</span> <span class=o>=</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>.</span><span class=n>cb</span> <span class=o>=</span> <span class=n>dispatch_timer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// itmerspec用于定时器的结构体
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 用于指定定时器的第一次启动时间和后续的周期触发间隔
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>itimerspec</span> <span class=n>spec</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 第一次执行时间，为msec指定的时间，表示msec毫秒之后执行
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>.</span><span class=n>it_value</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=p>.</span><span class=n>tv_sec</span> <span class=o>=</span> <span class=n>msecs</span> <span class=o>/</span> <span class=mi>1000</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=p>.</span><span class=n>tv_nsec</span> <span class=o>=</span> <span class=p>(</span><span class=n>msecs</span> <span class=o>%</span> <span class=mi>1000</span><span class=p>)</span> <span class=o>*</span> <span class=mi>1000000</span>
</span></span><span class=line><span class=cl>		<span class=p>},</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 周期触发间隔，也为msec指定的时间，表示每隔msec毫秒执行一次
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>.</span><span class=n>it_interval</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=p>.</span><span class=n>tv_sec</span> <span class=o>=</span> <span class=n>msecs</span> <span class=o>/</span> <span class=mi>1000</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=p>.</span><span class=n>tv_nsec</span> <span class=o>=</span> <span class=p>(</span><span class=n>msecs</span> <span class=o>%</span> <span class=mi>1000</span><span class=p>)</span> <span class=o>*</span> <span class=mi>1000000</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// timerfd_settime函数用于创建定时器，会在指定的时间之后通过文件描述符通知
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 参数如下:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// fd：使用timerfd_create创建的文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// flag：0表示相对时间，1表示绝对时间
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// new_value：上面的itemrspec结构体，用于指定定时器的第一次启动时间和后续的周期触发间隔
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// old_value：如果不为NULL，则返回定时器之前设置的超时时间
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 定时器超时后会向文件描述符中写入一个超时次数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=nf>timerfd_settime</span><span class=p>(</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>.</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>spec</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 将该定时器事件添加到文件描述符事件中
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=nf>uloop_fd_add</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>,</span> <span class=n>ULOOP_READ</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>err</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nf>uloop_fd_delete</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>close</span><span class=p>(</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>.</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>timer_remove</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_interval</span> <span class=o>*</span><span class=n>tm</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 先从epoll_wail等待文件描述中去除
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>__uloop_fd_delete</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>close</span><span class=p>(</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>.</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 获取间隔定时器设置的超时时间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>int64_t</span> <span class=nf>timer_next</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_interval</span> <span class=o>*</span><span class=n>tm</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>itimerspec</span> <span class=n>spec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>.</span><span class=n>registered</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// timerfd_gettime用来获取定时器距离下次超时的剩余时间
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=nf>timerfd_gettime</span><span class=p>(</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>.</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>spec</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>spec</span><span class=p>.</span><span class=n>it_value</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>*</span> <span class=mi>1000</span> <span class=o>+</span> <span class=n>spec</span><span class=p>.</span><span class=n>it_value</span><span class=p>.</span><span class=n>tv_nsec</span> <span class=o>/</span> <span class=mi>1000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在上面的<code>uloop_interval_set</code>函数中调用了<code>timer_register</code>函数，该函数中通过标准C提供的<code>timerfd_create</code>创建文件描述符，并将其与<code>dispatch_timer</code>函数一起赋值给文件描述符事件结构体（<code>dispatch_timer</code>作为文件描述符事件回调），随后通过<code>timerfd_settime</code>设置间隔提醒事件，最后添加到文件描述符事件处理流程中。</p><p><code>timer_remove</code>函数在删除该间隔定时器事件是先从epoll中取消，随后关闭文件描述符。</p><p><code>time_next</code>函数返回指定间隔定时器的剩余事件。</p><p>接下来了解以下，当间隔定时器超时被触发之后的处理逻辑：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 通过文件描述符事件通知该定时器文件描述符是否准备就绪，如果就绪就会调用该回调
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>dispatch_timer</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>u</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>events</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>ULOOP_READ</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>uint64_t</span> <span class=n>fired</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 定时器超时后会向对应文件描述符中写入超时次数，这里可以读取出来
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=nf>read</span><span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fired</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>fired</span><span class=p>))</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>fired</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 通过传入的定时器结构体的元素u获取到结构体指针
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>uloop_interval</span> <span class=o>*</span><span class=n>tm</span> <span class=o>=</span> <span class=nf>container_of</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=k>struct</span> <span class=n>uloop_interval</span><span class=p>,</span> <span class=n>priv</span><span class=p>.</span><span class=n>ufd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>tm</span><span class=o>-&gt;</span><span class=n>expirations</span> <span class=o>+=</span> <span class=n>fired</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 定时器超时执行回调
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>tm</span><span class=o>-&gt;</span><span class=nf>cb</span><span class=p>(</span><span class=n>tm</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当间隔定时器超时之后，内核会向<code>timerfd_settime</code>传入的文件描述符中写入自上一次读取该文件描述符以来，定时器发生超时的总次数。而由于<code>dispatch_timer</code>是注册为文件描述符事件的回调中，因此触发之后则会被调用。</p><p>在该函数中，读取到数据是该间隔定时器的触发次数，并将其赋值叠加给<code>expirations</code>参数，用以表示定时器超时的总次数。然后执行注册该定时器事件时设置的回调。</p><h2 id=子进程事件><a href=#%e5%ad%90%e8%bf%9b%e7%a8%8b%e4%ba%8b%e4%bb%b6>子进程事件</a></h2><p>子进程事件的处理方式与超时定时器的处理方式大同小异，均是在保存在一个链表中，但子进程事件的处理是由条件的，该条件就是收到<code>SIGCHLD</code>信号。</p><p>下面是子进程事件的相关数据结构</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>uloop_process</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 表示进程事件是否插入到对应的链表中，插入到链表之后收到SIGCHLD信号才会调用回调函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>bool</span> <span class=n>pending</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>uloop_process_handler</span> <span class=n>cb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 子进程的pid，收到SIGCHLD信号之后会判断信号来源是否与该pid相等，如果相等则执行回调
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_process_add</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_process</span> <span class=o>*</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_process_delete</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_process</span> <span class=o>*</span><span class=n>p</span><span class=p>);</span>
</span></span></code></pre></div><p>下面是添加、删除子进程的处理逻辑：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 将参数p指定的进程事件插入到链表中，插入顺序按照pid从小到大的顺序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>uloop_process_add</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_process</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_process</span> <span class=o>*</span><span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span><span class=n>h</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>processes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pending</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 按照进程id从小达到的顺序插入
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>list_for_each_entry</span><span class=p>(</span><span class=n>tmp</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>processes</span><span class=p>,</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>tmp</span><span class=o>-&gt;</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 找到刚好大于传入进程事件中指定pid的节点后退出
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>h</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>tmp</span><span class=o>-&gt;</span><span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>list</span><span class=p>,</span> <span class=n>h</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 表示进程事件正在处理中
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>p</span><span class=o>-&gt;</span><span class=n>pending</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_process_delete</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_process</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pending</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>p</span><span class=o>-&gt;</span><span class=n>pending</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到，这和添加、删除超时定时器事件的操作基本一直，唯一不同的地方在于，链表排序的依据是子进程ID。</p><h3 id=处理逻辑><a href=#%e5%a4%84%e7%90%86%e9%80%bb%e8%be%91>处理逻辑</a></h3><p>在<code>uloop_run_timeout</code>函数中，有以下两行代码是用来处理子进程事件的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// do_sigchld表示是否受到SIGCHLD信号，然后处理进程事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>do_sigchld</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 只有收到SIGCHLD信号才会处理进程事件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>uloop_handle_processes</span><span class=p>();</span>
</span></span></code></pre></div><p>其中<code>do_sigchld</code>标志是否收到SIGCHLD信号，如果收到则为<code>true</code>。</p><p>下面是<code>SIGCHLD</code>信号处理逻辑</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>list_head</span> <span class=n>processes</span> <span class=o>=</span> <span class=nf>LIST_HEAD_INIT</span><span class=p>(</span><span class=n>processes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>uloop_signal_wake</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span> <span class=n>sigbyte</span> <span class=o>=</span> <span class=n>signo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// SIGCHLD 系统通知父进程其子进程终止，父进程此时需要处理回收动作
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>==</span> <span class=n>SIGCHLD</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>do_sigchld</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>uloop_install_handler</span><span class=p>(</span><span class=kt>int</span> <span class=n>signum</span><span class=p>,</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>handler</span><span class=p>)(</span><span class=kt>int</span><span class=p>),</span> <span class=k>struct</span> <span class=n>sigaction</span><span class=o>*</span> <span class=n>old</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>add</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>sigaction</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>sigaction</span> <span class=o>*</span><span class=n>act</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>act</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 获取备份旧的信号处理方式
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>sigaction</span><span class=p>(</span><span class=n>signum</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>add</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>==</span> <span class=n>SIG_DFL</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* Do not override existing custom signal handlers */</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 旧的信号处理方式是默认，则将旧信号处理方式保存在old中
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>memcpy</span><span class=p>(</span><span class=n>old</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>sigaction</span><span class=p>));</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 设置新的信号处理方式
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>s</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>handler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>s</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>act</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>==</span> <span class=n>handler</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* Do not restore if someone modified our handler */</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 如果不是添加信号处理方式，则恢复旧的
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>act</span> <span class=o>=</span> <span class=n>old</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>act</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 注册新的信号处理方式
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>sigaction</span><span class=p>(</span><span class=n>signum</span><span class=p>,</span> <span class=n>act</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 所有信号事件均通过管道和文件描述符事件来处理，只是SIGINT和SIGTERM信号需要做额外的参数设置
</span></span></span><span class=line><span class=cl><span class=c1>// 该函数用来设置默认的信号处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>uloop_setup_signals</span><span class=p>(</span><span class=kt>bool</span> <span class=n>add</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>static</span> <span class=k>struct</span> <span class=n>sigaction</span> <span class=n>old_sigint</span><span class=p>,</span> <span class=n>old_sigchld</span><span class=p>,</span> <span class=n>old_sigterm</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>uloop_install_handler</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=n>uloop_handle_sigint</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>old_sigint</span><span class=p>,</span> <span class=n>add</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>uloop_install_handler</span><span class=p>(</span><span class=n>SIGTERM</span><span class=p>,</span> <span class=n>uloop_handle_sigint</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>old_sigterm</span><span class=p>,</span> <span class=n>add</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>uloop_handle_sigchld</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>uloop_install_handler</span><span class=p>(</span><span class=n>SIGCHLD</span><span class=p>,</span> <span class=n>uloop_signal_wake</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>old_sigchld</span><span class=p>,</span> <span class=n>add</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>uloop_ignore_signal</span><span class=p>(</span><span class=n>SIGPIPE</span><span class=p>,</span> <span class=n>add</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>通过<code>uloop_init->uloop_setup_signals->uloop_install_handler</code>的调用链，可以看到<code>uloop_signal_wake</code>函数也被注册为<code>SIGCHLD</code>信号处理方式。</p><p>在<code>uloop_signal_wake</code>函数中，如果收到<code>SIGCHLD</code>信号，则将<code>do_sigchld</code>设置为<code>true</code>。此时在<code>uloop_run_timeout</code>的下一次循环中就会执行<code>uloop_handle_processes</code>处理子进程事件了。</p><p>那具体是怎么处理子进程事件的呢</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>uloop_handle_processes</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_process</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=o>*</span><span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>do_sigchld</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 等待任何子进程的终止，WNOHANG表示没有子进程在等待时立即返回，不阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>pid</span> <span class=o>=</span> <span class=nf>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ret</span><span class=p>,</span> <span class=n>WNOHANG</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=c1>// &lt;0表示出错
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>errno</span> <span class=o>==</span> <span class=n>EINTR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// 出错或者没有子进程
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nf>list_for_each_entry_safe</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>tmp</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>processes</span><span class=p>,</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=c1>// 从链表中删除当前进程事件，并执行回调
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>uloop_process_delete</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=n>p</span><span class=o>-&gt;</span><span class=nf>cb</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在收到<code>SIGCHLD</code>信号之后，已经可以确认有子进程等待回收，因此会在<code>while</code>循环中调用<code>waitpid</code>回收子进程，回收完成之后会遍历子进程事件列表，从中删除对应pid的子进程事件，然后调用子进程事件的回调。</p><h2 id=信号事件><a href=#%e4%bf%a1%e5%8f%b7%e4%ba%8b%e4%bb%b6>信号事件</a></h2><p>信号事件类似于信号处理程序，但是比<code>sigaction</code>函数注册信号处理程序要简单一些，但比直接使用<code>signal</code>函数好像要复杂。</p><p>信号事件的数据结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 信号事件
</span></span></span><span class=line><span class=cl><span class=c1>// SIGINT、SIGTERM、SIGCHLD信号的处理会内置
</span></span></span><span class=line><span class=cl><span class=c1>// 其余信号需要用户通过接口来添加
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// 默认信号处理函数是一个写管道的函数
</span></span></span><span class=line><span class=cl><span class=c1>// 收到信号之后会将其写入管道，管道的另一侧注册在文件描述符事件中，通过文件描述符事件进行提醒，然后获取信号执行回调
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>uloop_signal</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 保存旧的信号处理动作
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>sigaction</span> <span class=n>orig</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 判断是否已经加入到信号事件列表
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>bool</span> <span class=n>pending</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>uloop_signal_handler</span> <span class=n>cb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>signo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_signal_add</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_signal</span> <span class=o>*</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_signal_delete</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_signal</span> <span class=o>*</span><span class=n>s</span><span class=p>);</span>
</span></span></code></pre></div><p>信号事件的处理并不在<code>uloop_run_timeout</code>函数中，而是在<code>uloop_init</code>中就已经注册。</p><p>信号事件的添加和删除逻辑如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>list_head</span> <span class=n>signals</span> <span class=o>=</span> <span class=nf>LIST_HEAD_INIT</span><span class=p>(</span><span class=n>signals</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 该函数用于添加自定义的信号处理事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>uloop_signal_add</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_signal</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span><span class=n>h</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>signals</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_signal</span> <span class=o>*</span><span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>sigaction</span> <span class=n>sa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>pending</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>list_for_each_entry</span><span class=p>(</span><span class=n>tmp</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>signals</span><span class=p>,</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>tmp</span><span class=o>-&gt;</span><span class=n>signo</span> <span class=o>&gt;</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>signo</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>h</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>tmp</span><span class=o>-&gt;</span><span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>list</span><span class=p>,</span> <span class=n>h</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>s</span><span class=o>-&gt;</span><span class=n>pending</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 获取旧的信号处理函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>sigaction</span><span class=p>(</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>signo</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>orig</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 判断旧的信号处理动作
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>orig</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>!=</span> <span class=n>uloop_signal_wake</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 设置信号处理函数为写管道的函数，收到信号时写入管道，管道另一端执行信号事件
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>sa</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>uloop_signal_wake</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>sa</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 信号处理期间无阻塞信号
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sa</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=nf>sigaction</span><span class=p>(</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>signo</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sa</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uloop_signal_delete</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_signal</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>pending</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>s</span><span class=o>-&gt;</span><span class=n>pending</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>orig</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>!=</span> <span class=n>uloop_signal_wake</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>sigaction</span><span class=p>(</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>signo</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>orig</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在<code>uloop_signal_add</code>函数中，首先会按照信号值的从小到大的顺序将信号事件插入的对应的链表中，其次会判断当前信号的处理方式是否为<code>uloop_signal_wake</code>，如果不是则进行设置，并将旧的信号处理程序保存在<code>orig</code>中。</p><p>删除信号则很简单，在<code>uloop_signal_delete</code>中先从全局链表中删除对应的信号事件，随后恢复原有的信号处理函数。</p><p>当收到信号时，则会调用<code>uloop_signal_wake</code>函数，该函数的处理逻辑如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>uloop_signal_wake</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span> <span class=n>sigbyte</span> <span class=o>=</span> <span class=n>signo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// SIGCHLD 系统通知父进程其子进程终止，父进程此时需要处理回收动作
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>==</span> <span class=n>SIGCHLD</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>do_sigchld</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 收到信号之后向管道写入信号值，然后通过文件描述符事件通知管道的另一侧
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=nf>write</span><span class=p>(</span><span class=n>waker_pipe</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sigbyte</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EINTR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在收到信号后，<code>uloop_signal_wake</code>函数会将信号值写入<code>waker_pipe</code>管道，接下来看看管道的另一侧怎么处理</p><p>管道的另一侧是在<code>waker_init</code>函数中处理，该函数也是在<code>uloop_init</code>中进行调用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>waker_pipe</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>uloop_fd</span> <span class=n>waker_fd</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>fd</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>cb</span> <span class=o>=</span> <span class=n>signal_consume</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>waker_init_fd</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_SETFD</span><span class=p>,</span> <span class=nf>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_GETFD</span><span class=p>)</span> <span class=o>|</span> <span class=n>FD_CLOEXEC</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_SETFL</span><span class=p>,</span> <span class=nf>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_GETFL</span><span class=p>)</span> <span class=o>|</span> <span class=n>O_NONBLOCK</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>waker_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>fds</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>waker_pipe</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nf>pipe</span><span class=p>(</span><span class=n>fds</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>waker_init_fd</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=nf>waker_init_fd</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=n>waker_pipe</span> <span class=o>=</span> <span class=n>fds</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 管道的另一侧，接收文件描述符读事件
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>waker_fd</span><span class=p>.</span><span class=n>fd</span> <span class=o>=</span> <span class=n>fds</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>waker_fd</span><span class=p>.</span><span class=n>cb</span> <span class=o>=</span> <span class=n>signal_consume</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nf>uloop_fd_add</span><span class=p>(</span><span class=o>&amp;</span><span class=n>waker_fd</span><span class=p>,</span> <span class=n>ULOOP_READ</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>从<code>waker_init</code>函数中可以看到，管道的另一侧即<code>fds[0]</code>被注册为文件描述符事件，事件回调为<code>signal_consume</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>set_signo</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=o>*</span><span class=n>signums</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>&gt;=</span> <span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>signo</span> <span class=o>&lt;=</span> <span class=mi>64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=o>*</span><span class=n>signums</span> <span class=o>|=</span> <span class=p>(</span><span class=mi>1u</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>signo</span> <span class=o>-</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>get_signo</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>signums</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>(</span><span class=n>signo</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>signo</span> <span class=o>&lt;=</span> <span class=mi>64</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>signums</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1u</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>signo</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 读取到信号后处理信号事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>signal_consume</span><span class=p>(</span><span class=k>struct</span> <span class=n>uloop_fd</span> <span class=o>*</span><span class=n>fd</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>events</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>uloop_signal</span> <span class=o>*</span><span class=n>usig</span><span class=p>,</span> <span class=o>*</span><span class=n>usig_next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// signums中的每一位表示一个信号，比如收到信号9，则设置第9位为1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>uint64_t</span> <span class=n>signums</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span> <span class=n>buf</span><span class=p>[</span><span class=mi>32</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=kt>ssize_t</span> <span class=n>nsigs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>nsigs</span> <span class=o>=</span> <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>(</span><span class=kt>ssize_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nsigs</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nf>set_signo</span><span class=p>(</span><span class=o>&amp;</span><span class=n>signums</span><span class=p>,</span> <span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=p>(</span><span class=n>nsigs</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 遍历信号事件列表，判断是否添加了该信号，如果以添加则执行信号回调
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>list_for_each_entry_safe</span><span class=p>(</span><span class=n>usig</span><span class=p>,</span> <span class=n>usig_next</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>signals</span><span class=p>,</span> <span class=n>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=nf>get_signo</span><span class=p>(</span><span class=n>signums</span><span class=p>,</span> <span class=n>usig</span><span class=o>-&gt;</span><span class=n>signo</span><span class=p>))</span>
</span></span><span class=line><span class=cl>			<span class=n>usig</span><span class=o>-&gt;</span><span class=nf>cb</span><span class=p>(</span><span class=n>usig</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>而在<code>signal_consume</code>回调函数中会接收所有的信号，并将其保存在一个64位的无符号整数中，其中每位代表一个信号。然后遍历信号事件链表，找到对应的信号事件处理回调并执行。</p><p>总结一下</p><ol><li>初始化信号处理管道，并将其注册到文件描述符事件中，设置文件描述符事件回调为<code>signal_consume</code></li><li>通过<code>struct uloop_signal</code>添加信号处理事件，并添加到全局链表中</li><li>注册通用信号处理函数<code>uloop_signal_wake</code></li><li>收到信号后，在<code>uloop_signal_wake</code>中将其写入管道，触发文件描述符事件，执行回调<code>signal_consume</code></li><li>在文件描述符事件回调中接收信号，并执行全局链表中注册的信号事件回调</li></ol></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://DBL2017.github.io/>生如夏花</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/libubox/uloop%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/>https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/libubox/uloop%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br><div class=post-archive><h2>相关文章</h2><ul class=listing><li><a href=/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/uci/openwrt%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%A4%84%E7%90%86uci%E9%85%8D%E7%BD%AE/>OpenWrt之shell脚本处理UCI配置</a></li><li><a href=/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/uci/openwrt%E4%B9%8Buci.sh%E4%B8%ADuci_load%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/>OpenWrt之uci.sh中uci_load的工作原理</a></li><li><a href=/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/openwrt%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E5%9C%A8vmware%E4%B8%8A%E8%BF%90%E8%A1%8C/>OpenWrt下载编译以及在VMWare上运行</a></li><li><a href=/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/openwrt%E4%B9%8Bfeeds/>OpenWrt之Feeds</a></li><li><a href=/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/uci/uci-system/>UCI system</a></li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a href=/tags/openwrt>OpenWrt</a></li><li><a href=/tags/libubox>libubox</a></li><li><a href=/tags/uloop>uloop</a></li></ul></div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=DBL2017/DBL2017.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></div></div></div><div class=content-right><div class=sidebar><section class=widget><form id=form-search action=https://DBL2017.github.io/search/ method=get accept-charset=utf-8 _lpchecked=1><input type=text name=q maxlength=20 placeholder=请输入查找关键字 required>
<button type=submit class=submit title=提交>
<svg t="1714448321870" class="icon" style="width:22px;height:22px" viewBox="0 0 1024 1024" p-id="1771" width="200" height="200"><path d="M781.9264 691.1232l236.928 236.9216-90.816 90.8032-236.9152-236.9216c-72.032 53.3568-161.184 84.9088-257.7088 84.9088C194.048 866.8352.0 672.7872.0 433.408.0 194.048 194.048.0 433.4144.0c239.3728.0 433.4208 194.048 433.4208 433.4144.0 96.5248-31.552 185.6768-84.9088 257.7088zm-348.512 47.2896c168.448.0 304.9984-136.5504 304.9984-304.9984s-136.5504-304.992-304.9984-304.992-304.992 136.5504-304.992 304.9856c0 168.448 136.5504 304.9984 304.992 304.9984z" fill="#4A4A4A" p-id="1772"/></svg></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%BF%98%E8%AE%B0ubuntu14.04%E7%9A%84%E7%99%BB%E5%BD%95%E8%B4%A6%E5%AF%86%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/ title=记录一次忘记Ubuntu14.04的登录账密的处理方式>记录一次忘记Ubuntu14.04的登录账密的处理方式</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/neovim/diagnostic/ title=Diagnostic>Diagnostic</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/libubox/uloop%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/ title=uloop源码剖析>uloop源码剖析</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/tikz%E7%BB%98%E5%88%B6%E6%8A%98%E7%BA%BF%E5%9B%BE/ title=TiKZ绘制折线图>TiKZ绘制折线图</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ubuntu18%E6%B0%B8%E4%B9%85%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%90%8D%E7%A7%B0/ title=Ubuntu18永久修改网络接口名称>Ubuntu18永久修改网络接口名称</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8Bdocumentclass/ title=LaTeX之documentclass>LaTeX之documentclass</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8Bctex%E5%AE%8F%E9%9B%86%E4%B9%8B%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%E7%B1%BB/ title=LaTeX之CTeX宏集之中文文档类>LaTeX之CTeX宏集之中文文档类</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8B%E4%B8%AD%E6%96%87%E6%94%AF%E6%8C%81/ title=LaTex之中文支持>LaTex之中文支持</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/dibbler-server%E7%9A%84dhcpv6-pd%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D56%E4%BD%8D%E5%89%8D%E7%BC%80/ title=dibbler-server的DHCPv6-PD如何分配56位前缀>dibbler-server的DHCPv6-PD如何分配56位前缀</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/ipv6%E8%BF%87%E6%B8%A1%E6%8A%80%E6%9C%AF/ipip%E9%9A%A7%E9%81%93%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/ title=IPIP隧道创建实例>IPIP隧道创建实例</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=https://DBL2017.github.io/categories/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/>传输协议 (17)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/>工具使用 (24)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/>开源三方 (2)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统 (14)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/>数字安全 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/>数据结构和算法 (5)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言 (14)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/>网络工程师 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记 (56)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/>问题排查 (6)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%BB%98%E8%AE%A4/>默认 (2)</a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://mermaid.live/ title=Mermaid>Mermaid 编辑</a></li><li><a target=_blank href=https://excalidraw.com/ title=EXCALIDRAW>Excalidraw 绘图</a></li><li><a target=_blank href=https://git-scm.com/docs title=Git命令参考手册>Git命令参考手册</a></li><li><a target=_blank href=https://www.gnu.org/software/make/manual/make.html title="GNU make官方文档">GNU make官方文档</a></li><li><a target=_blank href=https://www.emojiall.com/ title=Emojiall表情网站>Emojiall表情网站</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/index.xml>文章 RSS</a></li></ul></section></div></div></div><div class=container-footer><footer id=footer><div>&copy; 2025 <a href=https://DBL2017.github.io/>生如夏花 By
生如夏花</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>广电总局</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered
by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://DBL2017.github.io/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">生如夏花</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script src=/js/jquery.fancybox.min.min.7fa821ee946e58947030e5d007d358378119205e16b74ab4d0c60560a36d0414a775f9dbe0586ce12723c75cea8794fabadd1f33100a9ee22f6da3826256c0ef.js integrity="sha512-f6gh7pRuWJRwMOXQB9NYN4EZIF4Wt0q00MYFYKNtBBSndfnb4Fhs4Scjx1zqh5T6ut0fMxAKnuIvbaOCYlbA7w==" crossorigin=anonymous></script><a id=rocket href=#top></a><script src=/js/totop.min.8c7573186baa30f09c49b5cf3176c3b105785324d961b3d5c2f7f099d14673160a29aeebdec25909d046aa14936cd43451e17664662d518550d5e8998dbec670.js integrity="sha512-jHVzGGuqMPCcSbXPMXbDsQV4UyTZYbPVwvfwmdFGcxYKKa7r3sJZCdBGqhSTbNQ0UeF2ZGYtUYVQ1eiZjb7GcA==" crossorigin=anonymous></script><script src=/js/clipboard.min.0765794be1674926c1a3810afcf039f605f367cb11cef727ad49e6aa70f9fca0a37d329d64c55822896869eb0960763e73e085ee7675cbc497e4d3256a6e6a67.js integrity="sha512-B2V5S+FnSSbBo4EK/PA59gXzZ8sRzvcnrUnmqnD5/KCjfTKdZMVYIoloaesJYHY+c+CF7nZ1y8SX5NMlam5qZw==" crossorigin=anonymous></script><script>var spy=new Gumshoe("#TableOfContents a",{nested:!0,nestedClass:"active"})</script><script>hljs.highlightAll()</script></div></div></body></html>