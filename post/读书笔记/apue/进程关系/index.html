<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>进程关系 | 生如夏花</title>
<meta property="og:title" content="进程关系 - 生如夏花"><meta property="og:type" content="article"><meta property="article:published_time" content='2022-07-22T21:11:24+08:00'><meta property="article:modified_time" content='2022-07-22T21:11:24+08:00'><meta name=Keywords content="C语言,Linux系统开发,物联网,博客,项目管理,软件架构"><meta name=description content="终端简介之物理终端、模拟终端以及伪终端。终端登录以及网路登录的区别。进程组、会话以及控制终端相关概念。孤儿进程组、作业控制、终端驱动程序。fg、bg切换前后台进程。"><meta name=author content><meta property="og:url" content="https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai.min.css integrity="sha512-RLF8eOxhuwsRINc7r56dpl9a3VStqrXD+udWahutJrYdyh++2Ghnf+s4jFsOyryKZt/GNjPwbXVPH3MJpKrn2g==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/badge.min.dc57f0a9d275742b1e2d17f204ae0b829361b5dd0df99d3d356615830fb223936c054d31a888c5f369975da90586601e2666ddbbbb36e98510b814a70826e874.css integrity="sha512-3FfwqdJ1dCseLRfyBK4LgpNhtd0N+Z09NWYVgw+yI5NsBU0xqIjF82mXXakFhmAeJmbdu7s26YUQuBSnCCbodA==" crossorigin=anonymous><link rel=stylesheet href=/css/header.min.9e74ad2f7e23fb54e2da3ef2f1eb6498897cd4139d181133b5e641f107980364ccfbcea731badb693b4a50819c388b6f8cab037346daf142114f86f14faa8766.css integrity="sha512-nnStL34j+1Ti2j7y8etkmIl81BOdGBEzteZB8QeYA2TM+86nMbrbaTtKUIGcOItvjKsDc0ba8UIRT4bxT6qHZg==" crossorigin=anonymous><link rel=stylesheet href=/css/table.min.032852d8d049c55be5cd0a27bf8c7b09c8ea549fb719c2fd0231ebd262fdddb5aaaf391dabeb89ce33bcbe49f13ee8a530822a26f76b675af23473ed07b95d2e.css integrity="sha512-AyhS2NBJxVvlzQonv4x7CcjqVJ+3GcL9AjHr0mL93bWqrzkdq+uJzjO8vknxPuilMIIqJvdrZ1ryNHPtB7ldLg==" crossorigin=anonymous><link rel=stylesheet href=/css/baseof.min.e78724d0b9c6d515ee22f97ac39b8898ad417d6f0b47977db4981358565ae050fdb352dfca9a019ce22403d9580bc837bfe3e3287b039b96af75939c1071e9e4.css integrity="sha512-54ck0LnG1RXuIvl6w5uImK1BfW8LR5d9tJgTWFZa4FD9s1LfypoBnOIkA9lYC8g3v+PjKHsDm5avdZOcEHHp5A==" crossorigin=anonymous><link rel=stylesheet href=/css/rocket.min.96a6be31cd3df9dcd4e7e131e9fcb0e63149da1da6a23df5ed8c8e0ccf0436f4c95aad5ded6a69e7fba5c051f8cc00466fcedaa07e4c7f59492d4a15aba2e936.css integrity="sha512-lqa+Mc09+dzU5+Ex6fyw5jFJ2h2moj317YyODM8ENvTJWq1d7Wpp5/ulwFH4zABGb87aoH5Mf1lJLUoVq6LpNg==" crossorigin=anonymous><link rel=stylesheet href=/css/toc.min.cc966f24bfde5608a7e63066d31db9943c15156ef9cbb936f9f022eb998d941648fd23cd07b96a0b74dd5e76048764cc033cee10639f11faa98b37682ffb3a16.css integrity="sha512-zJZvJL/eVgin5jBm0x25lDwVFW75y7k2+fAi65mNlBZI/SPNB7lqC3TdXnYEh2TMAzzuEGOfEfqpizdoL/s6Fg==" crossorigin=anonymous><link rel=stylesheet href=/css/clipboard.min.5e6a0198e50c850ced7dc2ba6f282ecaab21a8daad9eee626b990120818361b4b0007128d73957d5682346c88a6f9831f5872051e5f12da830cc29ca75676403.css integrity="sha512-XmoBmOUMhQztfcK6byguyqshqNqtnu5ia5kBIIGDYbSwAHEo1zlX1WgjRsiKb5gx9YcgUeXxLagwzCnKdWdkAw==" crossorigin=anonymous><link rel=stylesheet href=/css/style.min.0ee927227dc0f181f293a851db44642879c59ab0e5e6dfaae42f3402d8e06810cb2c8fe30201142d9f8205e46f706cf646ccba5e8ee7695327d888861ddaf10d.css integrity="sha512-DuknIn3A8YHyk6hR20RkKHnFmrDl5t+q5C80AtjgaBDLLI/jAgEULZ+CBeRvcGz2Rsy6Xo7naVMn2IiGHdrxDQ==" crossorigin=anonymous><link rel="shortcut icon" href=/img/favicon.png type=image/x-icon><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vim.min.js></script><script src=/js/gumshoe.min.min.9dec1df0371d73b03324ed4bb78a6d5b2e84af6a37b11ce799808a26d70dfd156595f8d23c42db9e4866f12b4c0de664cfd032fa6f95bdaaada1bacdb235e79e.js integrity="sha512-newd8Dcdc7AzJO1Lt4ptWy6Er2o3sRznmYCKJtcN/RVllfjSPELbnkhm8StMDeZkz9Ay+m+VvaqtobrNsjXnng==" crossorigin=anonymous></script></head><body><div class=container><div class=container-header><header><div class=header-main><div class=header-site-name><a id=header-title href=https://DBL2017.github.io/>生如夏花</a><p class=description>专注于工业物联网行业数据采集，嵌入式Linux系统裁剪，5G智慧网关软件开发等</p></div><div class=header-menu><nav id=header-nav-menu><a href=https://DBL2017.github.io/>首页</a>
<a href=https://DBL2017.github.io/series/ title=系列>系列</a>
<a href=https://DBL2017.github.io/categories/ title=分类>分类</a>
<a href=https://DBL2017.github.io/tags/ title=标签>标签</a>
<a href=https://DBL2017.github.io/archives/ title=归档>归档</a>
<a href=https://DBL2017.github.io/about/ title=关于>关于</a></nav></div></div></header></div><div class=container-content><div class=content-center><div class=main-single><div class=single-toc><div class=post-toc><h2 class=post-toc-title><a href=#>目录</a></h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#终端简介>终端简介</a><ul><li><a href=#物理终端>物理终端</a></li><li><a href=#模拟终端>模拟终端</a></li><li><a href=#伪终端>伪终端</a></li></ul></li><li><a href=#登录>登录</a><ul><li><a href=#终端登录>终端登录</a></li><li><a href=#网络登录>网络登录</a></li></ul></li><li><a href=#进程组>进程组</a><ul><li><a href=#孤儿进程组>孤儿进程组</a></li></ul></li><li><a href=#会话>会话</a></li><li><a href=#控制终端>控制终端</a></li><li><a href=#作业控制>作业控制</a><ul><li><a href=#shell>shell</a></li><li><a href=#终端驱动程序>终端驱动程序</a></li></ul></li><li><a href=#shell执行程序>shell执行程序</a><ul><li><a href=#无作业控制>无作业控制</a></li><li><a href=#支持作业控制>支持作业控制</a></li></ul></li></ul></nav></div></div></div><div class=single-article><article class=post><header><h1 class=post-title>进程关系</h1></header><date class="post-meta meta-date"><span class=meta-category><a href=/archives/#2022>2022年7月22日</a></span></date><div class=post-meta><span>|</span>
<span class=meta-category><a href=/categories/#%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0>读书笔记</a></span></div><div class=post-meta><span>|</span>
<span class=meta-category><a href=/series/#APUE>APUE</a></span></div><div class=post-meta><span>|</span>
<span>共9260字</span></div><div class=post-meta><span>|</span>
<span>阅读时长(19分钟)</span></div><div class=clear style=display:none><div class=toc-article><div class=toc-title>文章目录</div></div></div><div class=post-content><p>本文主要介绍了终端，包括物理终端、模拟终端以及伪终端等。</p><p>两种不同的登录方式、即终端登录和网络登录。</p><p>重点是进程组、会话以及控制终端之间的联系。</p><p>最后是作业控制，作业控制是目前很多类Unix系统都支持的功能。</p><p>介绍了shell程序是如何实现作业控制的以及shell运行程序的方式。</p><h2 id=终端简介><a href=#%e7%bb%88%e7%ab%af%e7%ae%80%e4%bb%8b>终端简介</a></h2><h3 id=物理终端><a href=#%e7%89%a9%e7%90%86%e7%bb%88%e7%ab%af>物理终端</a></h3><p>1869年证券报价机被发明出来，用于远距离实时分配股票价格，证券报价机由一台打字机、一对长电缆和一台电动收报机组成。</p><p>随后证券报价机发展成为基于ASCII码的电传打字机，连接在名为Telex的大型网络中，用于传输商业电报，并没有连接到任何计算机上。</p><p>与此同时，计算机虽然大且原始，但是已经开始支持多任务和实时交互功能。因此命令行开始取代批处理模型，电传打字机被用来作为输入输出设备，因为市面上这种设备最常见。</p><p>而市面上的不同类型电传打印机都需要软件来支持，因此Unix内核来处理这些底层细节，例如字长、波特率、流控制、奇偶校验、基于行编辑的控制码等。</p><p><strong>此时的电传打印机teletype就被成为物理终端。</strong> 如下图所示：</p><p><a data-fancybox=gallery href=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%e7%89%a9%e7%90%86%e7%bb%88%e7%ab%af.webp><img class=mx-auto alt src=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%e7%89%a9%e7%90%86%e7%bb%88%e7%ab%af.webp></a></p><p>电传打字机通过两根电缆连接：一根用于向计算机发送指令，一根用于接收计算机的输出。这两根电缆插入计算机的串行接口（UART，通用异步接收发送装置）。</p><p><strong>操作系统内核包含UART驱动用来处理物理线路接收到的字节数据，包括流控制、奇偶校验等。</strong> 然后将字符数据传递给行规程（line discipline）。</p><p><strong>行规程（line descipline）</strong> 用来处转换特殊字符（退格、擦除、清除等）并将收到的数据回传给电传打字机，以便用户可以看到输入的内容。</p><p><strong>行规程（line descipline）</strong> 同时还会对数据进行缓冲，当按下回车键时，缓冲的数据被传递给TTY相关的前台用户进程。用户可以并行执行几个程序，但每次只与一个进程进行交互，其他进程后台工作。</p><p><a data-fancybox=gallery href=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E7%89%A9%E7%90%86%E7%BB%88%E7%AB%AF1.png><img class=mx-auto alt src=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E7%89%A9%E7%90%86%E7%BB%88%E7%AB%AF1.png></a></p><p>还有一些高级程序使用的是raw模式，该模式下需要自己来处理输入的特殊字符，而不是使用行规程（line descipline）程序。</p><h3 id=模拟终端><a href=#%e6%a8%a1%e6%8b%9f%e7%bb%88%e7%ab%af>模拟终端</a></h3><p>今天电传打字机已经进入了博物馆，但是行规成（line desicipline）和TTY驱动保留了下来。终端不在是一个通过UART连接到计算机的物理设备，而是成为内核的一个模块。</p><p>它可以直接转发数据到TTY驱动，并将TTY驱动读取相应然后打印到屏幕上。</p><p><strong>这种使用内核模块模拟的终端物理设备，被称为模拟终端。</strong></p><p><a data-fancybox=gallery href=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E6%A8%A1%E6%8B%9F%E7%BB%88%E7%AB%AF.webp><img class=mx-auto alt src=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E6%A8%A1%E6%8B%9F%E7%BB%88%E7%AB%AF.webp></a></p><p><a data-fancybox=gallery href=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E6%A8%A1%E6%8B%9F%E7%BB%88%E7%AB%AF1.png><img class=mx-auto alt src=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E6%A8%A1%E6%8B%9F%E7%BB%88%E7%AB%AF1.png></a></p><p>现在是Linux桌面环境时代，启动系统默认会进入到登录界面，然而对于服务器版本，并不需要桌面环境，此时进行登录的命令行环境就是模拟终端。</p><p><strong>对于每个模拟终端，在/dev下都有一个特殊的设备文件tty[n]。与该虚拟终端的交互，是通过对这个设备文件进行的读写操作，以及使用<code>ioctl</code>系统调用操作这个设备文件进行的。</strong></p><p>可以使用<code>tty</code>命令查看当前登录的模拟终端对应的设备文件名。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>$tty</span>
</span></span><span class=line><span class=cl>/dev/tty6
</span></span></code></pre></div><p>Ubuntu提供了6个模拟终端，其中早期的X系统和现在GNONE都是运行模拟终端上tty2上，可以使用<code>Ctrl+Shift+F2</code>切换到X系统。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ps aux <span class=p>|</span> grep tty2
</span></span><span class=line><span class=cl>blduan      <span class=m>5083</span>  0.0  0.1 <span class=m>165468</span>  <span class=m>6424</span> tty2     Ssl+ 17:22   0:00 /usr/libexec/gdm-wayland-session env <span class=nv>GNOME_SHELL_SESSION_MODE</span><span class=o>=</span>ubuntu /usr/bin/gnome-session --session<span class=o>=</span>ubuntu
</span></span><span class=line><span class=cl>blduan      <span class=m>5087</span>  0.0  0.3 <span class=m>226116</span> <span class=m>15692</span> tty2     Sl+  17:22   0:00 /usr/libexec/gnome-session-binary --session<span class=o>=</span>ubuntu
</span></span><span class=line><span class=cl>blduan      <span class=m>5677</span>  0.0  0.0  <span class=m>12296</span>  <span class=m>2596</span> pts/4    S+   17:24   0:00 grep --color<span class=o>=</span>auto tty2
</span></span><span class=line><span class=cl>$ ll /proc/5083/fd
</span></span><span class=line><span class=cl>total <span class=m>0</span>
</span></span><span class=line><span class=cl>dr-x------ <span class=m>2</span> blduan blduan  <span class=m>0</span>  7月 <span class=m>24</span> 17:22 ./
</span></span><span class=line><span class=cl>dr-xr-xr-x <span class=m>9</span> blduan blduan  <span class=m>0</span>  7月 <span class=m>24</span> 17:22 ../
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>24</span> 17:22 <span class=m>0</span> -&gt; /dev/tty2
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>24</span> 17:22 <span class=m>1</span> -&gt; <span class=s1>&#39;socket:[106022]&#39;</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>24</span> 17:22 <span class=m>2</span> -&gt; <span class=s1>&#39;socket:[106023]&#39;</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>24</span> 17:22 <span class=m>3</span> -&gt; <span class=s1>&#39;anon_inode:[eventfd]&#39;</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>24</span> 17:22 <span class=m>4</span> -&gt; <span class=s1>&#39;anon_inode:[eventfd]&#39;</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>24</span> 17:22 <span class=m>5</span> -&gt; <span class=s1>&#39;socket:[106024]&#39;</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>24</span> 17:22 <span class=m>6</span> -&gt; <span class=s1>&#39;anon_inode:[eventfd]&#39;</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>24</span> 17:22 <span class=m>7</span> -&gt; <span class=s1>&#39;socket:[106026]&#39;</span>
</span></span></code></pre></div><p>下面的例子是虚拟终端tty3登录之后向虚拟终端tty4发送消息，如果tty4已经登录，则可以收到该消息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1>#echo &#34;hello, tty4&#34; &gt; /dev/tty4</span>
</span></span></code></pre></div><h3 id=伪终端><a href=#%e4%bc%aa%e7%bb%88%e7%ab%af>伪终端</a></h3><p><strong>为了将终端模拟器从内核空间移到用户空间，并保持TTY驱动和行规程（descipline）的完整性，此时发明了伪终端（pseudo terminal, PTY）。</strong> 因此伪终端可以用来创建登录会话和提供行规程的能力。</p><p>伪终端由两个虚拟字符设备组成：master(PTM)和slave(PTS)。</p><p><strong>通常master设备连接到终端模拟软件上（例如xterm、gnome-terminal）并且slave设备连接到正在运行中的程序上，通常是shell（例如bash）。因此slave就和物理终端表现一样。</strong></p><p><strong>当master端被打开时，对应的slave设备可以像任何tty设备一样使用。master和slave设备由内核连接，等效于具有TTY功能的双向管道。</strong></p><p>伪终端主要用于网络登录服务（ssh、rlogin、telnet等）和实现终端仿真器（xterm、mobaxterm、tmux、gnome-terminal等）</p><p><a data-fancybox=gallery href=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E4%BC%AA%E7%BB%88%E7%AB%AF.webp><img class=mx-auto alt src=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E4%BC%AA%E7%BB%88%E7%AB%AF.webp></a></p><p><a data-fancybox=gallery href=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E4%BC%AA%E7%BB%88%E7%AB%AF1.png><img class=mx-auto alt src=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E4%BC%AA%E7%BB%88%E7%AB%AF1.png></a></p><p>以gnome-terminal为例：</p><ol><li><p>gnome-terminal打开伪终端的master设备<code>/dev/ptmx</code>，并负责监听键盘事件，通过伪终端master设备接收或发送字符到slave设备，同时在屏幕上绘制master设备的字符输出。</p></li><li><p>gnome-termial会fork出一个shell子进程（bash），并让该子进程获取slave设备文件<code>/dev/pts/[n]</code>，该子进程通过slave设备接收字符，并进行处理然后返回。</p></li></ol><p>在gnome-terminal中执行<code>tty</code>命令，可以看到slave设备对应的设备文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>$tty</span>
</span></span><span class=line><span class=cl>/dev/pts/0
</span></span></code></pre></div><p>下面是Ubuntu22.04下gnome-terminal执行命令的过程：</p><ol><li>系统启动时会拉起init进程。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ps aux <span class=p>|</span> grep init
</span></span><span class=line><span class=cl>root           <span class=m>1</span>  0.0  0.2 <span class=m>166420</span> <span class=m>11504</span> ?        Ss   17:50   0:01 /sbin/init auto noprompt splash
</span></span></code></pre></div><ol start=2><li>init进程创建systemd子进程用来管理用户进程。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ps ajx <span class=p>|</span> grep systemd
</span></span><span class=line><span class=cl><span class=m>1</span>     <span class=m>833</span>     <span class=m>833</span>     <span class=m>833</span> ?             -1 Ss    <span class=m>1000</span>   0:00 /lib/systemd/systemd --user
</span></span></code></pre></div><ol start=3><li>当用户在桌面第一次打开gnome-terminal时，systemd进程会先创建gnome-terminal-server子进程，gnome-terminal-server进程fork出bash子进程以执行shell命令。systemd进程之后再调用python3来创建gnome-terminal.real子进程（即输入窗口）。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ps ajx  <span class=p>|</span> grep gnome-terminal*
</span></span><span class=line><span class=cl>    <span class=m>833</span>    <span class=m>1926</span>    <span class=m>1099</span>    <span class=m>1099</span> ?             -1 S     <span class=m>1000</span>   0:00 /usr/bin/python3 /usr/bin/gnome-terminal --wait
</span></span><span class=line><span class=cl>   <span class=m>1926</span>    <span class=m>1929</span>    <span class=m>1099</span>    <span class=m>1099</span> ?             -1 Sl    <span class=m>1000</span>   0:00 /usr/bin/gnome-terminal.real --wait
</span></span><span class=line><span class=cl>    <span class=m>833</span>    <span class=m>1996</span>    <span class=m>1099</span>    <span class=m>1099</span> ?             -1 S     <span class=m>1000</span>   0:00 /usr/bin/python3 /usr/bin/gnome-terminal --wait
</span></span><span class=line><span class=cl>   <span class=m>1996</span>    <span class=m>1999</span>    <span class=m>1099</span>    <span class=m>1099</span> ?             -1 Sl    <span class=m>1000</span>   0:00 /usr/bin/gnome-terminal.real --wait
</span></span><span class=line><span class=cl>   <span class=m>833</span>    <span class=m>1934</span>    <span class=m>1934</span>    <span class=m>1934</span> ?             -1 Ssl   <span class=m>1000</span>   0:00 /usr/libexec/gnome-terminal-server
</span></span><span class=line><span class=cl>$ ps ajx <span class=p>|</span> grep  bash
</span></span><span class=line><span class=cl>   <span class=m>1934</span>    <span class=m>1960</span>    <span class=m>1960</span>    <span class=m>1960</span> pts/0       <span class=m>1960</span> Ss+   <span class=m>1000</span>   0:00 bash
</span></span><span class=line><span class=cl>   <span class=m>1934</span>    <span class=m>2004</span>    <span class=m>2004</span>    <span class=m>2004</span> pts/2       <span class=m>2004</span> Ss+   <span class=m>1000</span>   0:00 bash
</span></span></code></pre></div><ol start=4><li>此时gome-terminal.real进程打开了伪终端的master设备，bash进程打开伪终端slave设备。当用户再gnome-terminal中输入命令之后就会被该bash执行并返回。</li><li>此时该bash的标准流都被重定向到slave设备文件中。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ll /proc/2004/fd
</span></span><span class=line><span class=cl>total <span class=m>0</span>
</span></span><span class=line><span class=cl>dr-x------ <span class=m>2</span> blduan blduan  <span class=m>0</span>  7月 <span class=m>24</span> 18:30 ./
</span></span><span class=line><span class=cl>dr-xr-xr-x <span class=m>9</span> blduan blduan  <span class=m>0</span>  7月 <span class=m>24</span> 18:30 ../
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>24</span> 18:30 <span class=m>0</span> -&gt; /dev/pts/0
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>24</span> 18:30 <span class=m>1</span> -&gt; /dev/pts/0
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>24</span> 18:30 <span class=m>2</span> -&gt; /dev/pts/0
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>24</span> 18:30 <span class=m>255</span> -&gt; /dev/pts/0
</span></span></code></pre></div><ol start=6><li>此时gnome-terminal监听键盘事件，并将收到的字符写入master设备。</li><li>line discipline收到字符，进行缓冲。当收到回车键时，TTY驱动负责将缓冲的字符写入slave设备。</li><li>line discipline在收到字符后，也会把字符写回master设备。gnome-terminal只会在屏幕上显示master设备回传的内容。</li><li>bash从标准输入读取输入的字符（以ls -l为例）。</li><li>bash fork出子进程，调用exec执行ls -l命令，结果打印到标准输出。</li><li>TTY驱动将标准输出的字符写入master设备。</li><li>gnome-terminal将master设备的字符渲染到屏幕上。</li></ol><h2 id=登录><a href=#%e7%99%bb%e5%bd%95>登录</a></h2><h3 id=终端登录><a href=#%e7%bb%88%e7%ab%af%e7%99%bb%e5%bd%95>终端登录</a></h3><p>终端登录指的是早期物理终端和模拟终端登录的场景。</p><p><strong>终端登录流程如下：</strong></p><ol><li>init进程对于每个终端连接都运行一个独立的getty程序。init进程fork子进程来运行getty程序。</li><li>getty进程在终端进行监听，并且输出欢迎信息（保存在/etc/issue中），并且提示输入用户名，在用户输入用户名之后使用exec调用login程序。</li><li>login进程通过命令行参数接收用户名并提示用户输入密码。如果账密匹配，则启动bash；否则进程退出终止或者让用户重新输出账密（比如Ubuntu22.04）。</li><li>init进程检测到login进程退出，则对当前终端重新启动getty进程。</li></ol><p><a data-fancybox=gallery href=../%e8%bf%9b%e7%a8%8b%e5%85%b3%e7%b3%bb/%e7%bb%88%e7%ab%af%e7%99%bb%e5%bd%95%e6%b5%81%e7%a8%8b.png><img class=mx-auto alt=终端登录流程 src=../%e8%bf%9b%e7%a8%8b%e5%85%b3%e7%b3%bb/%e7%bb%88%e7%ab%af%e7%99%bb%e5%bd%95%e6%b5%81%e7%a8%8b.png></a></p><p><strong>唯一的新进程是由init进程创建的（使用fork函数）；getty和login只会替换进程中运行的程序（使用exec函数）.</strong></p><p>下面是Linux系统进程关系图：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># ps ajx | grep init</span>
</span></span><span class=line><span class=cl><span class=m>0</span>     <span class=m>1</span>     <span class=m>1</span>     <span class=m>1</span> ?           -1 Ss       <span class=m>0</span>   0:08 /sbin/init
</span></span><span class=line><span class=cl><span class=c1># ps ajx | grep agetty</span>
</span></span><span class=line><span class=cl>   <span class=m>1</span> <span class=m>31144</span> <span class=m>31144</span> <span class=m>31144</span> ttyFIQ0  <span class=m>31144</span> Ss+      <span class=m>0</span>   0:00 /sbin/agetty -o -p -- <span class=se>\u</span> --keep-baud 115200,38400,9600 ttyFIQ0 vt220
</span></span><span class=line><span class=cl><span class=c1># 此处输入了username</span>
</span></span><span class=line><span class=cl><span class=c1># ps ajx | grep login</span>
</span></span><span class=line><span class=cl>   <span class=m>1</span> <span class=m>31144</span> <span class=m>31144</span> <span class=m>31144</span> ttyFIQ0  <span class=m>31144</span> Ss+      <span class=m>0</span>   0:00 /bin/login -p --
</span></span><span class=line><span class=cl><span class=c1># 此处输入了passwd，然后fork子进程，然后exec shell</span>
</span></span><span class=line><span class=cl><span class=c1># ps ajx | grep bash</span>
</span></span><span class=line><span class=cl><span class=m>31144</span> <span class=m>32462</span> <span class=m>32462</span> <span class=m>31144</span> ttyFIQ0  <span class=m>32462</span> S+       <span class=m>0</span>   0:00 -bash
</span></span></code></pre></div><h3 id=网络登录><a href=#%e7%bd%91%e7%bb%9c%e7%99%bb%e5%bd%95>网络登录</a></h3><p>在终端登录中，init进程知道那些终端设备可以用来登录，并为每个终端创建一个getty进程。</p><p>但是网络登录不同，所有登录都经由内核的网络接口驱动程序，而且事先不知道会有多少个登录。因此必须等待网络连接请求的到达，而不是使一个getty进程等待一个可能的登录。</p><p><strong>网络登录流程如下（以telnet登录为例）：</strong></p><ol><li>init进程启动inetd进程在后台运行，监听TCP/IP连接请求到达主机，当有连接请求到达时，执行fork，生成子进程执行telnetd进程。</li><li>telned进程打开一个伪终端设备，并用fork分为两个进程。父进程处理通过网络连接的通信，子进程则执行login程序。<strong>父子进程通过伪终端相连接。</strong></li><li>telnetd进程将文件描述符0，1，2和socket连接，用于接收和发送接收到数据，将文件描述符3连接到伪终端的master设备，用于转发接收到的命令。</li><li>login进程用于验证输入的账密，验证通过则通过fork创建子进程，然后exec bash进程（父子进程共享文件描述符，因此也会连接到伪终端的slave设备）；验证失败则login进程和telnetd都退出，重新由inetd进程创建telnetd进程。</li></ol><p><a data-fancybox=gallery href=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E7%BD%91%E7%BB%9C%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png><img class=mx-auto alt=网络登录流程图 src=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E7%BD%91%E7%BB%9C%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png></a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ps ajx <span class=p>|</span> grep <span class=m>2223</span>
</span></span><span class=line><span class=cl>      <span class=m>1</span>    <span class=m>2223</span>    <span class=m>2223</span>    <span class=m>2223</span> ?             -1 Ss       <span class=m>0</span>   0:00 /usr/sbin/inetd
</span></span><span class=line><span class=cl>   <span class=m>2223</span>    <span class=m>2313</span>    <span class=m>2313</span>    <span class=m>2313</span> ?             -1 Ss     <span class=m>129</span>   0:00 in.telnetd: 192.168.1.4
</span></span><span class=line><span class=cl><span class=c1># ll /proc/2313/fd</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> telnetd telnetd <span class=m>64</span>  7月 <span class=m>28</span> 23:12 <span class=m>0</span> -&gt; <span class=s1>&#39;socket:[57712]&#39;</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> telnetd telnetd <span class=m>64</span>  7月 <span class=m>28</span> 23:12 <span class=m>1</span> -&gt; <span class=s1>&#39;socket:[57712]&#39;</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> telnetd telnetd <span class=m>64</span>  7月 <span class=m>28</span> 23:12 <span class=m>2</span> -&gt; <span class=s1>&#39;socket:[57712]&#39;</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> telnetd telnetd <span class=m>64</span>  7月 <span class=m>28</span> 23:12 <span class=m>3</span> -&gt; /dev/ptmx
</span></span><span class=line><span class=cl>$ ps ajx <span class=p>|</span> grep <span class=m>2313</span>
</span></span><span class=line><span class=cl>   <span class=m>2223</span>    <span class=m>2313</span>    <span class=m>2313</span>    <span class=m>2313</span> ?             -1 Ss     <span class=m>129</span>   0:00 in.telnetd: 192.168.1.4
</span></span><span class=line><span class=cl>   <span class=m>2313</span>    <span class=m>2314</span>    <span class=m>2314</span>    <span class=m>2314</span> pts/1       <span class=m>2386</span> Ss       <span class=m>0</span>   0:00 login -h 192.168.1.4 -p
</span></span><span class=line><span class=cl><span class=c1># ll /proc/2314/fd</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> root root   <span class=m>64</span>  7月 <span class=m>28</span> 23:11 <span class=m>0</span> -&gt; /dev/pts/1
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> root root   <span class=m>64</span>  7月 <span class=m>28</span> 23:13 <span class=m>1</span> -&gt; /dev/pts/1
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> root root   <span class=m>64</span>  7月 <span class=m>28</span> 23:13 <span class=m>2</span> -&gt; /dev/pts/1
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> root root   <span class=m>64</span>  7月 <span class=m>28</span> 23:13 <span class=m>3</span> -&gt; <span class=s1>&#39;socket:[56988]&#39;</span>
</span></span><span class=line><span class=cl>$ ps ajx <span class=p>|</span> grep <span class=m>2314</span>
</span></span><span class=line><span class=cl>   <span class=m>2313</span>    <span class=m>2314</span>    <span class=m>2314</span>    <span class=m>2314</span> pts/1       <span class=m>2386</span> Ss       <span class=m>0</span>   0:00 login -h 192.168.1.4 -p
</span></span><span class=line><span class=cl>   <span class=m>2314</span>    <span class=m>2386</span>    <span class=m>2386</span>    <span class=m>2314</span> pts/1       <span class=m>2386</span> S+    <span class=m>1000</span>   0:00 -bash
</span></span><span class=line><span class=cl><span class=c1># ll /proc/2386/fd</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>28</span> 23:14 <span class=m>0</span> -&gt; /dev/pts/1
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>28</span> 23:14 <span class=m>1</span> -&gt; /dev/pts/1
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>28</span> 23:14 <span class=m>2</span> -&gt; /dev/pts/1
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> blduan blduan <span class=m>64</span>  7月 <span class=m>28</span> 23:14 <span class=m>255</span> -&gt; /dev/pts/1
</span></span></code></pre></div><p><strong>当通过终端或网络登陆时，我们会得到一个登录shell，其标准输入、标准输出以及标准错误要么连接到一个终端设备上要么连接到一个伪终端设备上。</strong></p><h2 id=进程组><a href=#%e8%bf%9b%e7%a8%8b%e7%bb%84>进程组</a></h2><p>每个进程除了有一个进程ID外，还属于一个进程组。</p><p>进程组是一个或多个进程的集合。通常进程组中的进程是在同一作业中结合起来的，同一进程组中的各进程接收来自同一终端的各种信号。</p><p>每个进程组有唯一的进程组ID，类似于进程ID，都是正整数，存放在<code>pid_t</code>数据类型中。</p><p>函数<code>getpgrp</code>返回调用进程的进程组ID。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>getpgrp</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 返回调用进程的进程组ID */</span>
</span></span></code></pre></div><hr><p>下面的例子查看当前进程的进程组ID和进程ID：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;process group id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpgrp</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;pid is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>process group id is 24358
</span></span></span><span class=line><span class=cl><span class=cm>pid is 24358
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p>从上面的例子可以看出，进程组ID等于创建进程组的进程ID。</p><hr><p><strong>每个进程组都有一个组长进程。组长进程的进程组ID等于其进程ID。</strong></p><p>进程组组长可以创建一个进程组、创建该组中的进程，然后终止。<strong>从进程组创建开始到其中最后一个进程离开为止的时间成为进程组的生命周期。</strong></p><p>进程组中的最后一个进程可以终止，也可以转移到另一个进程组。</p><p><strong>进程调用<code>setgid</code>可以加入一个现有的进程组或者创建一个新进程组。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setpgid</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>pid_t</span> <span class=n>pgid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回0， 失败返回-1 */</span>
</span></span></code></pre></div><p><code>setpgid</code>函数将<code>pid</code>进程的进程组ID设置为<code>pgid</code>。</p><ol><li>两个参数相等，则由<code>pid</code>指定的进程变为进程组组长。</li><li><code>pid==0</code>，则使用调用进程的进程ID。</li><li><code>pgid==0</code>，则由<code>pid</code>指定的进程ID用作进程组ID。</li></ol><p><strong>一个进程只能为它自己或它的子进程设置进程组ID。</strong> 在它的子进程调用了<code>exec</code>之后，就不再更改该子进程的进程组ID。</p><hr><p>下面的例子中子进程通过调用<code>setpgid</code>创建新进程组，并成为新进程组组长。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error:&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>pid_t</span> <span class=n>childPID</span> <span class=o>=</span> <span class=nf>getpid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process id is %d, process group id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>childPID</span><span class=p>,</span> <span class=nf>getpgrp</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>setpgid</span><span class=p>(</span><span class=n>childPID</span><span class=p>,</span> <span class=n>childPID</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;setpgid error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>_exit</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process id is %d, process group id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>childPID</span><span class=p>,</span> <span class=nf>getpgrp</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(;;)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;parent process id is %d, process group id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=nf>getpgrp</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(;;)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>parent process id is 27924, process group id is 27924
</span></span></span><span class=line><span class=cl><span class=cm>child process id is 27925, process group id is 27924
</span></span></span><span class=line><span class=cl><span class=cm>child process id is 27925, process group id is 27925
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><h3 id=孤儿进程组><a href=#%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b%e7%bb%84>孤儿进程组</a></h3><p>该组中每个成员的父进程要么是该组的一个成员，要么不是该组所属会话的成员。</p><h2 id=会话><a href=#%e4%bc%9a%e8%af%9d>会话</a></h2><p>会话是一个或多个进程组的集合。</p><p>进程可与调用<code>setsid</code>函数建立一个新会话。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>setsid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回进程组ID，失败返回-1。*/</span>
</span></span></code></pre></div><p><code>setsid</code>函数说明：</p><ol><li>调用进程不是一个进程组的组长，则此函数创建一个新会话。<ul><li>该进程成为新会话的会话首进程。此时该进程是该会话的唯一进程。</li><li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。</li><li>该进程没有控制终端。如果在调用<code>setsid</code>之前该进程有一个控制终端（比如login启动的bash进程），那么这种联系也被切断。</li></ul></li><li>调用进程是一个进程组的组长，返回出错。通常采用的方式是父进程fork子进程，然后使父进程终止，子进程继续，可以保证子进程不是进程组组长。</li></ol><p><strong>会话ID指的是该会话中首进程的进程组ID。</strong> 通常bash进程ID为当前会话ID。</p><p><code>getsid</code>函数可以用来获取该会话首进程的进程组ID。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>getsid</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/*  成功返回会话首进程的进程组ID，失败返回-1 */</span>
</span></span></code></pre></div><p><code>pid==0</code>，返回调用进程所在会话的首进程的进程组ID。如果<code>pid</code>不属于调用进程所在的会话，则不能得到该会话首进程的进程组ID。</p><hr><p>下面的例子中使用fork创建子进程然后在子进程中调用<code>setsid</code>创建新会话，并同时创建了新进程组。子进程作为进程组的组长，也是会话的首进程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;current child process group id is %d, session id is %d, &#34;</span>
</span></span><span class=line><span class=cl>               <span class=s>&#34;process id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nf>getpgrp</span><span class=p>(),</span> <span class=nf>getsid</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>setsid</span><span class=p>()</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;setsid error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>_exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;current child process group id is %d, session id is %d, &#34;</span>
</span></span><span class=line><span class=cl>               <span class=s>&#34;process id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nf>getpgrp</span><span class=p>(),</span> <span class=nf>getsid</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;current parent process group id is %d, session id is %d, &#34;</span>
</span></span><span class=line><span class=cl>               <span class=s>&#34;process id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nf>getpgrp</span><span class=p>(),</span> <span class=nf>getsid</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(;;)</span>
</span></span><span class=line><span class=cl>            <span class=nf>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>current parent process group id is 4219, session id is 3509, process id is 4219
</span></span></span><span class=line><span class=cl><span class=cm>current child process group id is 4219, session id is 3509, process id is 4220
</span></span></span><span class=line><span class=cl><span class=cm>current child process group id is 4220, session id is 4220, process id is 4220
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ps -eo pgid,sid,pid,command <span class=p>|</span> grep bash
</span></span><span class=line><span class=cl>   <span class=m>3509</span>    <span class=m>3509</span>    <span class=m>3509</span> -bash
</span></span></code></pre></div><p>由上面的例子可以看出，父进程是一个进程组组长，进程ID和进程组ID相同，<strong>所在进程组同时也是会话首进程为bash进程（进程ID为3509）的会话成员。</strong></p><p>子进程在调用<code>setsid</code>之前，是父进程所属进程组的成员，同时也是父进程所在会话的成员。调用<code>setsid</code>之后，创建了进程组和会话，成为了进程组组长和会话首进程。</p><hr><p><strong>进程、进程组、会话是逐级递加的方式来管理进程的。</strong></p><h2 id=控制终端><a href=#%e6%8e%a7%e5%88%b6%e7%bb%88%e7%ab%af>控制终端</a></h2><p>当会话首进程打开一个尚未与会话相关联的终端设备时，只要在调用<code>open</code>函数时没有指定<code>O_NOCTTY</code>标志，System V派生系统将此终端作为控制终端分配给此会话。</p><p>当会话首进程用<code>TIOCSCTTY</code>作为<code>request</code>参数调用<code>ioctl</code>时，基于BSD的系统为会话分配控制终端。为使此调用成功执行，此会话不能已经有一个控制终端。（通常<code>ioctl</code>调用在<code>setsid</code>之后）</p><p><strong>普通应用程序可以使用<code>open</code>文件<code>/dev/tty</code>来和控制终端主动通信。在内核中，该文件是控制终端的代名词。</strong> 如果进程没有控制终端，<code>open</code>返回失败。</p><p><strong>会话、进程组以及控制终端的关系</strong>如下：</p><ol><li>一个会话可以有一个控制终端，通常是终端设备或伪终端设备。</li><li>与控制终端建立连接的会话首进程被称为<strong>控制进程</strong>。</li><li>一个会话中的几个进程组可被分成一个<strong>前台进程组</strong>以及一个或多个<strong>后台进程组</strong>。</li><li>如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组都为后台进程组。</li><li>无论何时键入终端的中断键（Ctrl+C），都会将中断信号发送至<strong>前台进程组的所有进程</strong>。</li><li>如果终端接口检测到调制解调器或网络已经断开连接，则将挂断信号发送<strong>控制进程（会话首进程）</strong>。</li></ol><hr><p>进程组、会话以及控制终端关系图如下：
<a data-fancybox=gallery href=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BC%9A%E8%AF%9D%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF%E5%85%B3%E7%B3%BB%E5%9B%BE.png><img class=mx-auto alt=进程组、会话以及进程关系图 src=../%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BC%9A%E8%AF%9D%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF%E5%85%B3%E7%B3%BB%E5%9B%BE.png></a></p><p><strong>需要由一种方法通知内核哪个进程组是前台进程组，因为终端驱动程序需要知道要将终端输入输出产生的信号发送到何处</strong></p><p>以下几个函数提供了这种功能：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>tcgetpgrp</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回前台进程组ID，失败返回-1 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>tcsetpgrp</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>pid_t</span> <span class=n>pgrpid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回0，失败返回-1 */</span>
</span></span></code></pre></div><p><code>tcgetpgrp</code>函数返回前台进程组ID，它与在<code>fd</code>上打开的终端相关联。</p><p>如果进程有一个控制终端，则该进程可以调用<code>tcsetpgrp</code>将<code>pgrpid</code>指向的进程组设置为前台进程组。<code>pgrpid</code>值应当是在同一会话中的一个进程组的ID，<code>fd</code>必须引用该会话的控制终端。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;termios.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>tcgetsid</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回会话首进程的进程组ID，等价于会话ID，失败返回-1 */</span>
</span></span></code></pre></div><p><code>tcgetsid()</code>函数用于获取该控制终端对应的会话ID，也即是会话首进程的进程组ID（一般情况下为bash的进程ID）。</p><p>下面的例子展示上面3个函数的用法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;termios.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>judge</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>  <span class=c1>// 判断是否为前台或后台进程组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=nf>tcgetpgrp</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>);</span>  <span class=c1>// 与终端相关联的FD，STDIN_FILENO, tcgetpgrp返回前台进程组ID
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;tcgetpgrp&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=nf>getpgrp</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;foreground</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;background</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>spid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 控制终端的会话首进程的进程组ID（会话ID），调用进程的会话首进程的进程组ID，进程组ID，进程ID，前台进程组ID
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;tcgetsid:%d,sid=%d,pgrp=%d,pid=%d,fgpid=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>tcgetsid</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>),</span> <span class=nf>getsid</span><span class=p>(</span><span class=nf>getpid</span><span class=p>()),</span> <span class=nf>getpgrp</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=nf>getpid</span><span class=p>(),</span> <span class=nf>tcgetpgrp</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>spid</span> <span class=o>=</span> <span class=nf>tcgetsid</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>);</span>  <span class=c1>// 保存会话ID
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>signal</span><span class=p>(</span><span class=n>SIGTTOU</span><span class=p>,</span> <span class=n>SIG_IGN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>judge</span><span class=p>();</span> <span class=c1>// background
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=nf>tcsetpgrp</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>,</span> <span class=nf>getpgrp</span><span class=p>());</span>  <span class=c1>// 设置当前进程组为前台进程组
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;tcgetsid:%d,sid=%d,pgrp=%d,pid=%d,fgpid=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>tcgetsid</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>),</span> <span class=nf>getsid</span><span class=p>(</span><span class=nf>getpid</span><span class=p>()),</span> <span class=nf>getpgrp</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=nf>getpid</span><span class=p>(),</span> <span class=nf>tcgetpgrp</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;tcsetpgrp&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>judge</span><span class=p>();</span> <span class=c1>// foreground
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 控制终端如果没有与之关联的前台进程，则会被操作系统释放。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 因此下面将控制终端的前台进程组设置为原来的进程组(一般情况下为bash进程，即会话首进程所在进程组)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>result</span> <span class=o>=</span> <span class=nf>tcsetpgrp</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>,</span> <span class=n>spid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;tcgetsid:%d,sid=%d,pgrp=%d,pid=%d,fgpid=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>tcgetsid</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>),</span> <span class=nf>getsid</span><span class=p>(</span><span class=nf>getpid</span><span class=p>()),</span> <span class=nf>getpgrp</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=nf>getpid</span><span class=p>(),</span> <span class=nf>tcgetpgrp</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以后台方式执行上面的程序，得到如下结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./tcgetpgrp_demo <span class=p>&amp;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span> <span class=m>174068</span>
</span></span><span class=line><span class=cl>$ tcgetsid:173625,sid<span class=o>=</span>173625,pgrp<span class=o>=</span>174068,pid<span class=o>=</span>174068,fgpid<span class=o>=</span><span class=m>173625</span> <span class=c1># 此时前台进程组为bash所在进程组</span>
</span></span><span class=line><span class=cl>background
</span></span><span class=line><span class=cl>tcgetsid:173625,sid<span class=o>=</span>173625,pgrp<span class=o>=</span>174068,pid<span class=o>=</span>174068,fgpid<span class=o>=</span><span class=m>174068</span> <span class=c1># 此时前台进程组为当前进程</span>
</span></span><span class=line><span class=cl>foreground
</span></span><span class=line><span class=cl>tcgetsid:173625,sid<span class=o>=</span>173625,pgrp<span class=o>=</span>174068,pid<span class=o>=</span>174068,fgpid<span class=o>=</span><span class=m>173625</span> <span class=c1># 此时又将bash进程设为前台进程组</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span>+  Done                    ./tcgetpgrp_demo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ps -o sid,pid,ppid,pgid,command
</span></span><span class=line><span class=cl>    SID     PID    PPID    PGID COMMAND
</span></span><span class=line><span class=cl> <span class=m>173625</span>  <span class=m>173625</span>  <span class=m>173624</span>  <span class=m>173625</span> -bash
</span></span><span class=line><span class=cl> <span class=m>173625</span>  <span class=m>174069</span>  <span class=m>173625</span>  <span class=m>174069</span> ps -o sid,pid,ppid,pgid,command
</span></span></code></pre></div><p>从结果来进行看来，</p><ol><li>bash进程的进程以及进程组ID均为173625，所以可以确定bash进程为其所在进程组的组长进程。</li><li>bash进程的进程组ID与会话ID相同，所以bash进程为会话首进程，也即控制终端的控制进程。</li><li>tcgetpgrp_demo在设置为前台进程组之前，其前台进程组ID与bash所在进程组ID相同，因此bash所在的进程组为前台进程组，即会话首进程所在进程组为前台进程组。</li><li>tcgetpgrp_demo在设置为前台进程组之后，会话ID没变，会话首进程仍旧是bash进程，前台进程组则变为tcpgetpgrp_demo的进程组ID。</li></ol><p><strong>当控制终端没有前台进程组时，会被操作系统关闭。</strong></p><h2 id=作业控制><a href=#%e4%bd%9c%e4%b8%9a%e6%8e%a7%e5%88%b6>作业控制</a></h2><p>作业控制指的是在一个终端上启动多个作业（进程组），并且控制哪一个作业可以访问该终端以及哪些作业在后台运行。</p><p><strong>作业指的是进程组。</strong></p><p>作业控制有以下3个条件：</p><ol><li>支持作业控制的shell。</li><li>内核中的终端驱动程序必须支持作业控制。</li><li>内核必须提供对某些作业控制信号的支持。</li></ol><h3 id=shell><a href=#shell>shell</a></h3><p>从shell使用作业控制来看，用户可以在前台启动一个作业，可以在后台启动多个作业。</p><p>例如，<code>vi main.c</code>在前台启动了只有一个进程组成的作业；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>pr *.c | lpr &amp;
</span></span><span class=line><span class=cl>make all &amp;
</span></span></code></pre></div><p>上面的命令在后台启动了两个作业，这两个作业调用的所有进程都在后台运行。</p><p>当启动后台作业时，shell会赋予一个作业标识符，并且打印一个或多个进程ID。当作业完成并且键入回车时，shell会通知作业已经完成。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ make <span class=p>&amp;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span> <span class=m>174091</span>
</span></span><span class=line><span class=cl>$
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span>+  Done                    make
</span></span></code></pre></div><p>作业标识符为1，打印进程ID为174091。</p><h3 id=终端驱动程序><a href=#%e7%bb%88%e7%ab%af%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f>终端驱动程序</a></h3><p>有3个特殊字符可使终端驱动程序产生信号，并将信号发送至<strong>前台进程组</strong>。</p><table><thead><tr><th>字符</th><th>按键</th><th>信号</th></tr></thead><tbody><tr><td>中断字符</td><td>Delete或Ctrl+C</td><td>SIGINT</td></tr><tr><td>退出字符</td><td>Ctrl+\</td><td>SIGQUIT</td></tr><tr><td>挂起字符</td><td>Ctrl+Z</td><td>SIGTSTP</td></tr></tbody></table><p><strong>如果后台作业试图读终端，终端驱动程序检测到这一情况，会向后台作业发送特定信号SIGTTIN。</strong></p><p>该信号会停止此后台作业，并且shell会向用户发出通知，然后用户就可用shell命令将该作业转为前台作业，此时该作业就可以读终端。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ cat &gt; temp <span class=p>&amp;</span> <span class=c1># 后台运行cat，从终端标准输入读取，写入到temp文件中</span>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span> <span class=m>174439</span> <span class=c1># 作业编号1，进程ID174439</span>
</span></span><span class=line><span class=cl>$ <span class=c1># 键入回车</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span>+  Stopped                 cat &gt; temp <span class=c1># 打印后台作业状态，由于后台作业读取终端，产生SIGTTIN信号</span>
</span></span><span class=line><span class=cl>$ <span class=nb>fg</span> %1 <span class=c1># 后台作业转为前台</span>
</span></span><span class=line><span class=cl>cat &gt; temp <span class=c1># 前台作业读取数据</span>
</span></span><span class=line><span class=cl>Hello
</span></span><span class=line><span class=cl>$ cat temp
</span></span><span class=line><span class=cl>Hello
</span></span></code></pre></div><p>结果分析：</p><ol><li>shell在后台运行cat进程（shell的子进程）。</li><li>cat进程读其标准输入时，终端驱动程序检测到其为后台作业，于是向该进程发送SIGTTIN信号。</li><li>shell检测到cat进程状态改变，通知用户作业已被停止。</li><li>用户用shell的fg命令将该停止的作业送入前台运行（具体方法是<strong>shell进程调用tcsetpgrp，并发送继续信号SIGCONT给该进程组</strong>）。</li><li>该作业现在是前台作业，可以读控制终端。</li></ol><p><strong><code>stty tostop</code>可以禁止后台作业输出到控制终端</strong>。</p><p>下面的例子展示后台作业写终端的情况</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ cat temp <span class=p>&amp;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>3<span class=o>]</span> <span class=m>174627</span>
</span></span><span class=line><span class=cl>$
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>3<span class=o>]</span>+  Stopped                 cat temp
</span></span><span class=line><span class=cl>$ <span class=nb>fg</span> %3
</span></span><span class=line><span class=cl>cat temp
</span></span><span class=line><span class=cl>Hello
</span></span></code></pre></div><p>结果分析：</p><ol><li>后台启动cat作业，试图写标准输出（标准输出连接到终端）时，终端驱动程序识别出该写操作来自后台作业，会向该作业发送SIGTTOU信号，cat进程阻塞。</li><li>用户使用shell的<code>fg %3</code>命令将作业3转入前台，然后该作业继续执行，向终端写入数据。</li></ol><h2 id=shell执行程序><a href=#shell%e6%89%a7%e8%a1%8c%e7%a8%8b%e5%ba%8f>shell执行程序</a></h2><p>就是否支持作业控制来说，shell程序可以分为两类，一类是不支持作业控制的，比如Bourne shell，另一类是支持作业控制的，比如GNU Bash shell。</p><h3 id=无作业控制><a href=#%e6%97%a0%e4%bd%9c%e4%b8%9a%e6%8e%a7%e5%88%b6>无作业控制</a></h3><ol><li>无论是前台or后台执行命令，都会和shell进程处于同一进程组。</li><li>后台进程组如果没有自己重定向标准输入，则shell会自动将后台进程的标准输入重定向到/dev/null，读操作会直接产生文件结束。</li></ol><h3 id=支持作业控制><a href=#%e6%94%af%e6%8c%81%e4%bd%9c%e4%b8%9a%e6%8e%a7%e5%88%b6>支持作业控制</a></h3><p>前台执行ps命令结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ps -o pid,ppid,pgid,sid,tpgid,comm
</span></span><span class=line><span class=cl>    PID    PPID    PGID     SID   TPGID COMMAND
</span></span><span class=line><span class=cl> <span class=m>173625</span>  <span class=m>173624</span>  <span class=m>173625</span>  <span class=m>173625</span>  <span class=m>174507</span> bash
</span></span><span class=line><span class=cl> <span class=m>174507</span>  <span class=m>173625</span>  <span class=m>174507</span>  <span class=m>173625</span>  <span class=m>174507</span> ps
</span></span></code></pre></div><p>由前台执行ps命令的结果可以看出</p><ol><li>shell将前台作业ps放入它自己的进程组（174507）。</li><li>ps是进程组的组长进程，也是唯一进程。</li><li>ps进程组为前台进程组，具有控制终端，而登录shell进程在执行ps命令时转入后台，称为后台进程组。</li><li>这两个进程组都属于同一会话（173625），会话首进程一直都是shell进程（173625）。</li></ol><p>后台执行ps命令结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ps -o pid,ppid,pgid,sid,tpgid,comm <span class=p>&amp;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span> <span class=m>174545</span>
</span></span><span class=line><span class=cl>$   PID    PPID    PGID     SID   TPGID COMMAND
</span></span><span class=line><span class=cl> <span class=m>174532</span>  <span class=m>174531</span>  <span class=m>174532</span>  <span class=m>174532</span>  <span class=m>174532</span> bash
</span></span><span class=line><span class=cl> <span class=m>174545</span>  <span class=m>174532</span>  <span class=m>174545</span>  <span class=m>174532</span>  <span class=m>174532</span> ps
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span>+  Done                    ps -o pid,ppid,pgid,sid,tpgid,comm
</span></span></code></pre></div><p>有后台执行ps命令的结果可以看出</p><ol><li>shell进程同样将后台作业ps放入其自己的进程组中（174545）。</li><li>前台进程组是登录shell所在的进程组（174532），即会话首进程所在的进程组。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ps -o pid,ppid,pgid,sid,tpgid,comm <span class=p>|</span> cat
</span></span><span class=line><span class=cl>    PID    PPID    PGID     SID   TPGID COMMAND
</span></span><span class=line><span class=cl> <span class=m>174532</span>  <span class=m>174531</span>  <span class=m>174532</span>  <span class=m>174532</span>  <span class=m>174567</span> bash
</span></span><span class=line><span class=cl> <span class=m>174567</span>  <span class=m>174532</span>  <span class=m>174567</span>  <span class=m>174532</span>  <span class=m>174567</span> ps <span class=c1># ps与bash同处于同一前台进程组，父进程都是shell进程</span>
</span></span><span class=line><span class=cl> <span class=m>174568</span>  <span class=m>174532</span>  <span class=m>174567</span>  <span class=m>174532</span>  <span class=m>174567</span> cat
</span></span><span class=line><span class=cl> $ ps -o pid,ppid,pgid,sid,tpgid,comm <span class=p>|</span> cat <span class=p>&amp;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span> <span class=m>174571</span>
</span></span><span class=line><span class=cl>$   PID    PPID    PGID     SID   TPGID COMMAND
</span></span><span class=line><span class=cl> <span class=m>174532</span>  <span class=m>174531</span>  <span class=m>174532</span>  <span class=m>174532</span>  <span class=m>174532</span> bash
</span></span><span class=line><span class=cl> <span class=m>174570</span>  <span class=m>174532</span>  <span class=m>174570</span>  <span class=m>174532</span>  <span class=m>174532</span> ps <span class=c1># ps与bash同处于同一后台进程组，父进程都是shell进程</span>
</span></span><span class=line><span class=cl> <span class=m>174571</span>  <span class=m>174532</span>  <span class=m>174570</span>  <span class=m>174532</span>  <span class=m>174532</span> cat
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span>+  Done                    ps -o pid,ppid,pgid,sid,tpgid,comm <span class=p>|</span> cat
</span></span></code></pre></div><blockquote><p>版权声明: 本文为 InfoQ 作者【swordholder】的原创文章。
原文链接:【<a href=https://xie.infoq.cn/article/a6153354865c225bdce5bd55e>https://xie.infoq.cn/article/a6153354865c225bdce5bd55e</a>】。文章转载请联系作者。
<a href=http://www.linusakesson.net/programming/tty/index.php>http://www.linusakesson.net/programming/tty/index.php</a></p></blockquote></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://DBL2017.github.io/>生如夏花</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br><div class=post-archive><h2>See Also</h2><ul class=listing><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/>进程控制</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/>进程环境</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/>系统数据文件和信息</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%A0%87%E5%87%86io/>标准IO</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6io/>文件IO</a></li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a href=/tags/apue>APUE</a></li><li><a href=/tags/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB>进程关系</a></li><li><a href=/tags/%E7%BB%88%E7%AB%AF>终端</a></li><li><a href=/tags/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B>Unix环境高级编程</a></li></ul></div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=DBL2017/DBL2017.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></div></div></div><div class=content-right><div class=sidebar><section class=widget><form id=form-search action=https://DBL2017.github.io/search/ method=get accept-charset=utf-8 _lpchecked=1><input type=text name=q maxlength=20 placeholder=请输入查找关键字 required>
<button type=submit class=submit title=提交><svg t="1714448321870" class="icon" style="width:22px;height:22px" viewBox="0 0 1024 1024" p-id="1771" width="200" height="200"><path d="M781.9264 691.1232l236.928 236.9216-90.816 90.8032-236.9152-236.9216c-72.032 53.3568-161.184 84.9088-257.7088 84.9088C194.048 866.8352.0 672.7872.0 433.408.0 194.048 194.048.0 433.4144.0c239.3728.0 433.4208 194.048 433.4208 433.4144.0 96.5248-31.552 185.6768-84.9088 257.7088zm-348.512 47.2896c168.448.0 304.9984-136.5504 304.9984-304.9984s-136.5504-304.992-304.9984-304.992-304.992 136.5504-304.992 304.9856c0 168.448 136.5504 304.9984 304.992 304.9984z" fill="#4a4a4a" p-id="1772"/></svg></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/eve-ng/eve-ng%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ title=EVE-NG环境搭建>EVE-NG环境搭建</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/ns-3/ns-3%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ title=NS-3环境搭建>NS-3环境搭建</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/%E5%87%BD%E6%95%B0/ title=函数>函数</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/win10%E4%B8%8A%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/ title=WIN10上搭建samba服务器和Ubuntu虚拟机共享文件>WIN10上搭建samba服务器和Ubuntu虚拟机共享文件</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/ title=代码块和控制结构>代码块和控制结构</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/lua%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/ title=Lua语言学习框架>Lua语言学习框架</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/iptables%E5%9B%9B%E8%A1%A8%E4%BA%94%E9%93%BE/ title=iptables四表五链>iptables四表五链</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows%E4%B8%AD%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E8%B7%83%E7%82%B9%E6%95%B0%E5%92%8C%E6%B0%B8%E4%B9%85%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F/ title=Windows中通过配置跃点数和永久路由选择上网方式>Windows中通过配置跃点数和永久路由选择上网方式</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/free%E5%91%BD%E4%BB%A4%E4%B8%ADbuff-cache%E5%8D%A0%E6%BB%A1%E5%86%85%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/ title=free命令中buff-cache占满内存的问题>free命令中buff-cache占满内存的问题</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/docker%E5%91%BD%E4%BB%A4%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B/ title=docker命令无法连接到后台进程>docker命令无法连接到后台进程</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=https://DBL2017.github.io/categories/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/>传输协议 (14)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/>工具使用 (21)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/>开源三方 (2)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统 (11)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/>数字安全 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/>数据结构和算法 (5)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言 (9)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/>网络工程师 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记 (56)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/>问题排查 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%BB%98%E8%AE%A4/>默认 (2)</a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://mermaid.live/ title=Mermaid>Mermaid 编辑</a></li><li><a target=_blank href=https://excalidraw.com/ title=EXCALIDRAW>Excalidraw 绘图</a></li><li><a target=_blank href=https://git-scm.com/docs title=Git命令参考手册>Git命令参考手册</a></li><li><a target=_blank href=https://www.gnu.org/software/make/manual/make.html title="GNU make官方文档">GNU make官方文档</a></li><li><a target=_blank href=https://www.emojiall.com/ title=Emojiall表情网站>Emojiall表情网站</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/index.xml>文章 RSS</a></li></ul></section></div></div></div><div class=container-footer><footer id=footer><div>&copy; 2025 <a href=https://DBL2017.github.io/>生如夏花 By
生如夏花</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>广电总局</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered
by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://DBL2017.github.io/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">生如夏花</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script src=/js/jquery.fancybox.min.min.9040007c0fd2a6cdc356495acb1c45ba3328b261b0d9f75d3da19bc47229189108aab8ca043864c1801d59431de72dec8d51ae50539f9ce1f5964bf5f38786c3.js integrity="sha512-kEAAfA/Sps3DVklayxxFujMosmGw2fddPaGbxHIpGJEIqrjKBDhkwYAdWUMd5y3sjVGuUFOfnOH1lkv184eGww==" crossorigin=anonymous></script><a id=rocket href=#top></a><script src=/js/totop.min.8c7573186baa30f09c49b5cf3176c3b105785324d961b3d5c2f7f099d14673160a29aeebdec25909d046aa14936cd43451e17664662d518550d5e8998dbec670.js integrity="sha512-jHVzGGuqMPCcSbXPMXbDsQV4UyTZYbPVwvfwmdFGcxYKKa7r3sJZCdBGqhSTbNQ0UeF2ZGYtUYVQ1eiZjb7GcA==" crossorigin=anonymous></script><script src=/js/clipboard.min.0765794be1674926c1a3810afcf039f605f367cb11cef727ad49e6aa70f9fca0a37d329d64c55822896869eb0960763e73e085ee7675cbc497e4d3256a6e6a67.js integrity="sha512-B2V5S+FnSSbBo4EK/PA59gXzZ8sRzvcnrUnmqnD5/KCjfTKdZMVYIoloaesJYHY+c+CF7nZ1y8SX5NMlam5qZw==" crossorigin=anonymous></script><script>var spy=new Gumshoe("#TableOfContents a",{nested:!0,nestedClass:"active"})</script><script>hljs.highlightAll()</script></div></div></body></html>