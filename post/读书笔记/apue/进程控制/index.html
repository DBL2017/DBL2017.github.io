<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>进程控制 | 生如夏花的博客</title>
<meta property="og:title" content="进程控制 - 生如夏花的博客"><meta property="og:type" content="article"><meta property="article:published_time" content='2022-06-26T12:53:53+08:00'><meta property="article:modified_time" content='2022-06-26T12:53:53+08:00'><meta name=Keywords content="C语言,Linux系统开发,物联网,博客,项目管理,软件架构"><meta name=description content="进程控制"><meta name=author content><meta property="og:url" content="https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai.min.css integrity="sha512-RLF8eOxhuwsRINc7r56dpl9a3VStqrXD+udWahutJrYdyh++2Ghnf+s4jFsOyryKZt/GNjPwbXVPH3MJpKrn2g==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/badge.min.dc57f0a9d275742b1e2d17f204ae0b829361b5dd0df99d3d356615830fb223936c054d31a888c5f369975da90586601e2666ddbbbb36e98510b814a70826e874.css integrity="sha512-3FfwqdJ1dCseLRfyBK4LgpNhtd0N+Z09NWYVgw+yI5NsBU0xqIjF82mXXakFhmAeJmbdu7s26YUQuBSnCCbodA==" crossorigin=anonymous><link rel=stylesheet href=/css/header.min.9e74ad2f7e23fb54e2da3ef2f1eb6498897cd4139d181133b5e641f107980364ccfbcea731badb693b4a50819c388b6f8cab037346daf142114f86f14faa8766.css integrity="sha512-nnStL34j+1Ti2j7y8etkmIl81BOdGBEzteZB8QeYA2TM+86nMbrbaTtKUIGcOItvjKsDc0ba8UIRT4bxT6qHZg==" crossorigin=anonymous><link rel=stylesheet href=/css/table.min.032852d8d049c55be5cd0a27bf8c7b09c8ea549fb719c2fd0231ebd262fdddb5aaaf391dabeb89ce33bcbe49f13ee8a530822a26f76b675af23473ed07b95d2e.css integrity="sha512-AyhS2NBJxVvlzQonv4x7CcjqVJ+3GcL9AjHr0mL93bWqrzkdq+uJzjO8vknxPuilMIIqJvdrZ1ryNHPtB7ldLg==" crossorigin=anonymous><link rel=stylesheet href=/css/baseof.min.5e04a6c8338c3c57aedaaae91320971e148651ac160d51bb58ebfec7757346a177331ac5646bbb1b2664b1c8cc405939125785c138935bc0d29a805b11791691.css integrity="sha512-XgSmyDOMPFeu2qrpEyCXHhSGUawWDVG7WOv+x3VzRqF3MxrFZGu7GyZkscjMQFk5EleFwTiTW8DSmoBbEXkWkQ==" crossorigin=anonymous><link rel=stylesheet href=/css/rocket.min.96a6be31cd3df9dcd4e7e131e9fcb0e63149da1da6a23df5ed8c8e0ccf0436f4c95aad5ded6a69e7fba5c051f8cc00466fcedaa07e4c7f59492d4a15aba2e936.css integrity="sha512-lqa+Mc09+dzU5+Ex6fyw5jFJ2h2moj317YyODM8ENvTJWq1d7Wpp5/ulwFH4zABGb87aoH5Mf1lJLUoVq6LpNg==" crossorigin=anonymous><link rel=stylesheet href=/css/toc.min.6d85af7b55a06a3c1672914851ad8f64e3e4de3a81435cc45b05f1b71fb4bde6d0f00597b4f316d214809e3597a66516d7651772c9da8d8e42bf188fb3df5a85.css integrity="sha512-bYWve1WgajwWcpFIUa2PZOPk3jqBQ1zEWwXxtx+0vebQ8AWXtPMW0hSAnjWXpmUW12UXcsnajY5CvxiPs99ahQ==" crossorigin=anonymous><link rel=stylesheet href=/css/clipboard.min.5e6a0198e50c850ced7dc2ba6f282ecaab21a8daad9eee626b990120818361b4b0007128d73957d5682346c88a6f9831f5872051e5f12da830cc29ca75676403.css integrity="sha512-XmoBmOUMhQztfcK6byguyqshqNqtnu5ia5kBIIGDYbSwAHEo1zlX1WgjRsiKb5gx9YcgUeXxLagwzCnKdWdkAw==" crossorigin=anonymous><link rel=stylesheet href=/css/style.min.2af5fd807ef34ec700d21d326733adff6177ee5261d0810a5357fe02d9508bd54418aff2317c7d8761548124f1f7befd087353c6308ec3795a1dafbfba4b7193.css integrity="sha512-KvX9gH7zTscA0h0yZzOt/2F37lJh0IEKU1f+AtlQi9VEGK/yMXx9h2FUgSTx9779CHNTxjCOw3laHa+/uktxkw==" crossorigin=anonymous><link rel="shortcut icon" href=/img/favicon.png type=image/x-icon><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vim.min.js></script><script src=/js/gumshoe.min.min.9dec1df0371d73b03324ed4bb78a6d5b2e84af6a37b11ce799808a26d70dfd156595f8d23c42db9e4866f12b4c0de664cfd032fa6f95bdaaada1bacdb235e79e.js integrity="sha512-newd8Dcdc7AzJO1Lt4ptWy6Er2o3sRznmYCKJtcN/RVllfjSPELbnkhm8StMDeZkz9Ay+m+VvaqtobrNsjXnng==" crossorigin=anonymous></script></head><body><div class=container><div class=container-header><header><div class=header-main><div class=header-site-name><a id=header-title href=https://DBL2017.github.io/>生如夏花的博客</a><p class=description>专注于工业物联网行业数据采集，嵌入式Linux系统裁剪，5G智慧网关软件开发等</p></div><div class=header-menu><nav id=header-nav-menu><a href=https://DBL2017.github.io/>首页</a>
<a href=https://DBL2017.github.io/series/ title=系列>系列</a>
<a href=https://DBL2017.github.io/categories/ title=分类>分类</a>
<a href=https://DBL2017.github.io/tags/ title=标签>标签</a>
<a href=https://DBL2017.github.io/archives/ title=归档>归档</a>
<a href=https://DBL2017.github.io/about/ title=关于>关于</a></nav></div></div></header></div><div class=container-content><div class=content-center><div class=main-single><div class=single-toc><div class=post-toc><h2 class=post-toc-title><a href=#>目录</a></h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#进程标识>进程标识</a></li><li><a href=#创建进程>创建进程</a><ul><li><a href=#函数fork>函数fork</a></li><li><a href=#函数vfork>函数vfork</a></li></ul></li><li><a href=#执行程序>执行程序</a><ul><li><a href=#函数exec>函数exec</a></li><li><a href=#函数system>函数system</a></li><li><a href=#解释器文件>解释器文件</a></li></ul></li><li><a href=#进程终止>进程终止</a><ul><li><a href=#函数exit>函数exit</a></li><li><a href=#函数wait族>函数wait族</a><ul><li><a href=#waitpid函数>waitpid函数</a></li><li><a href=#waitid函数>waitid函数</a></li><li><a href=#wait3和wait4函数>wait3和wait4函数</a></li></ul></li></ul></li><li><a href=#进程属性>进程属性</a><ul><li><a href=#实际用户>实际用户</a></li><li><a href=#竞争条件>竞争条件</a></li><li><a href=#调度>调度</a></li><li><a href=#更改用户id>更改用户ID</a></li><li><a href=#进程时间>进程时间</a></li></ul></li><li><a href=#进程会计>进程会计</a></li></ul></nav></div></div></div><div class=single-article><article class=post><header><h1 class=post-title>进程控制</h1></header><date class="post-meta meta-date"><span class=meta-category><a href=/archives/#2022>2022年6月26日</a></span></date><div class=post-meta><span>|</span>
<span class=meta-category><a href=/categories/#%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0>读书笔记</a></span></div><div class=post-meta><span>|</span>
<span class=meta-category><a href=/series/#APUE>APUE</a></span></div><div class=post-meta><span>|</span>
<span>共12689字</span></div><div class=post-meta><span>|</span>
<span>阅读时长(26分钟)</span></div><div class=clear style=display:none><div class=toc-article><div class=toc-title>文章目录</div></div></div><div class=post-content><p><code>fork</code>创建子进程之后资源如何分配？</p><p>运行中的进程的有效用户和程序文件的所属用户的区别？</p><p>运行中的进程都有什么权限？</p><p>函数<code>system</code>是否成功执行？</p><p>什么是进程会计？</p><h2 id=进程标识><a href=#%e8%bf%9b%e7%a8%8b%e6%a0%87%e8%af%86>进程标识</a></h2><p><strong>每个进程都有一个非负整数的唯一进程ID。</strong></p><p>进程ID是可复用的。当进程终止，进程ID就是可复用的候选项。</p><p>Unix系统实现了延迟服用算法，使得赋予新建进程的ID不同于最近终止进程的ID。</p><p>每个Unix系统实现都有他自己的一套提供操作系统服务的内核进程。</p><p>下面函数用来获取进程相关的标识符：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* 分别获取进程ID和父进程ID */</span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>getpid</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>getppid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 分别获取进程的实际用户ID和有效用户ID */</span>
</span></span><span class=line><span class=cl><span class=kt>uid_t</span> <span class=nf>getuid</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>uid_t</span> <span class=nf>geteuid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 分别获取进程的实际组ID和有效组ID */</span>
</span></span><span class=line><span class=cl><span class=kt>gid_t</span> <span class=nf>getgid</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>gid_t</span> <span class=nf>getegid</span><span class=p>();</span>
</span></span></code></pre></div><p>默认情况下，进程的实际用户ID和有效用户ID相同，实际组ID和有效组ID相同。</p><p>下面是测试实例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=nf>getpid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>ppid</span> <span class=o>=</span> <span class=nf>getppid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;pid=%d, ppid=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>,</span> <span class=n>ppid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uid_t</span> <span class=n>realUID</span> <span class=o>=</span> <span class=nf>getuid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>uid_t</span> <span class=n>effectiveUID</span> <span class=o>=</span> <span class=nf>geteuid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;realUID=%d, effectiveUID==%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>realUID</span><span class=p>,</span> <span class=n>effectiveUID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>gid_t</span> <span class=n>realGID</span> <span class=o>=</span> <span class=nf>getgid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>gid_t</span> <span class=n>effectiveGID</span> <span class=o>=</span> <span class=nf>getegid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;realGID=%d, effectiveGID=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>realGID</span><span class=p>,</span> <span class=n>effectiveGID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./proc_identifier
</span></span><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span>67679, <span class=nv>ppid</span><span class=o>=</span><span class=m>51979</span>
</span></span><span class=line><span class=cl><span class=nv>realUID</span><span class=o>=</span>1000, <span class=nv>effectiveUID</span><span class=o>==</span><span class=m>1000</span>
</span></span><span class=line><span class=cl><span class=nv>realGID</span><span class=o>=</span>1000, <span class=nv>effectiveGID</span><span class=o>=</span><span class=m>1000</span>
</span></span></code></pre></div><h2 id=创建进程><a href=#%e5%88%9b%e5%bb%ba%e8%bf%9b%e7%a8%8b>创建进程</a></h2><h3 id=函数fork><a href=#%e5%87%bd%e6%95%b0fork>函数fork</a></h3><p>现有进程可以通过调用<code>fork</code>函数来创建新进程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功：子进程返回0，父进程返回子进程ID；失败：返回-1*/</span>
</span></span></code></pre></div><p><code>fork</code>创建的进程为调用进程的子进程。</p><p><code>fork</code>调用一次返回两次：子进程返回0，父进程返回子进程ID。原因是父进程可以拥有多个子进程，子进程只有一个父进程并且可以通过函数<code>getppid</code>获取父进程ID。</p><p>下面是<code>fork</code>函数和I/O的使用实例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>gVal</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>char</span> <span class=n>buf</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;a write to stdout</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>var</span> <span class=o>=</span> <span class=mi>88</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;write error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;before fork</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>gVal</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>var</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;pid=%ld, gVal=%d, var=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>,</span> <span class=n>gVal</span><span class=p>,</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./fork_demo
</span></span><span class=line><span class=cl>a write to stdout
</span></span><span class=line><span class=cl>before fork
</span></span><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span>0, <span class=nv>gVal</span><span class=o>=</span>2, <span class=nv>var</span><span class=o>=</span><span class=m>89</span>
</span></span><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span>75104, <span class=nv>gVal</span><span class=o>=</span>1, <span class=nv>var</span><span class=o>=</span><span class=m>88</span>
</span></span><span class=line><span class=cl>$ ./fork_demo &gt; temp
</span></span><span class=line><span class=cl>$ cat temp
</span></span><span class=line><span class=cl>a write to stdout
</span></span><span class=line><span class=cl>before fork
</span></span><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span>0, <span class=nv>gVal</span><span class=o>=</span>2, <span class=nv>var</span><span class=o>=</span><span class=m>89</span>
</span></span><span class=line><span class=cl>before fork
</span></span><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span>75106, <span class=nv>gVal</span><span class=o>=</span>1, <span class=nv>var</span><span class=o>=</span><span class=m>88</span>
</span></span></code></pre></div><p>由此可以得出以下结论：</p><ol><li>子进程和父进程都会执行<code>fork</code>函数之后的部分。可以得出父子进程共享正文段，但父子进程谁先执行，取决于内核的调度算法。</li><li>通过<code>gVal</code>和<code>val</code>的值可以得出，子进程会获得父进程数据空间、堆、栈的副本，但不共享，是相互独立的，每个进程都会可以修改自己的数据。</li><li>由于<code>fork</code>后进程跟随<code>exec</code>函数，因此<code>fork</code>执行之后并不立即给子进程分配父进程数据空间、堆以及栈的副本，而是采用<strong>写时复制</strong>技术，即这些区域改为父子进程共享且只读，只有当一个进程试图修改这些区域时，内核才会这个区域的内存制作一个副本。</li><li>父子进程同时写一个文件，<code>fork</code>函数执行之后父进程的所有文件描述符都被复制给子进程。</li><li><code>write</code>函数是不缓冲的，因此无论是终端设备还是文件都只写一次。</li><li>标准I/O是带缓冲的，标准输出重定向为终端设备时是行缓冲，因此遇到<code>\n</code>就会直接输出。<strong>但是当重定向到文件时是全缓冲，因此执行<code>printf</code>之后数据还在缓冲区中，同时也会被子进程共享，此时父子进程都有该该行内容的缓冲区，因此会输出两遍。</strong> 最后<code>exit</code>之前的<code>printf</code>函数会将其数据添加到已有缓冲区，在进程退出时写入到文件中。</li><li>根据写入的结果来看，父子进程共享同一文件偏移量。由此，父子进程的文件描述符表项指向指向的同一个文件表。如下图所示：
<a data-fancybox=gallery href=../%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%AF%B9%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB.png><img class=mx-auto alt src=../%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%AF%B9%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB.png></a></li></ol><p><strong><code>fork</code>之后处理文件描述符有两种方法</strong>：</p><ol><li>父进程等待子进程读写完成。此时父进程无需对文件描述符做任何处理，因为文件偏移量已更新。</li><li>父子进程各自执行不同代码段。这种情况父子进程关闭其不适用的文件描述符。</li></ol><p>其他被子进程继承的属性如下：</p><ul><li>实际用户ID、实际组ID、有效用户ID以及有效组ID。</li><li>附属组ID</li><li>进程组ID</li><li>会话ID</li><li>控制终端。</li><li>设置用户ID位和设置组ID标志</li><li>当前工作目录</li><li>根目录</li><li>文件模式创建屏蔽字</li><li>信号屏蔽和安排</li><li>对任一打开文件描述符的执行时关闭标志</li><li>环境</li><li>连接的共享存储段</li><li>资源限制</li><li>存储映像</li></ul><p>不被继承的属性如下：</p><ul><li>父进程设置的文件锁</li><li>未处理的闹钟</li><li>未处理的信号集</li></ul><p><strong><code>fork</code>函数的两种用法</strong>：</p><ul><li>父子进程各自执行不同的代码段。类似于网络服务进程，父进程继续等待客户端请求，子进程处理业务。</li><li>子进程执行一个不同的程序。类似于<code>shell</code>程序，<code>fork</code>返回后立即调用<code>exec</code>。</li></ul><h3 id=函数vfork><a href=#%e5%87%bd%e6%95%b0vfork>函数vfork</a></h3><p><code>vfork</code>函数和<code>fork</code>的调用返回值相同。</p><p><code>vfork</code>函数也是用于创建一个新进程，而该新进程的目的是执行一个新程序。</p><p><code>vfork</code>区别于<code>fork</code>的地方在于它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用<code>exec</code>或<code>exit</code>，于是也就不会引用该地址空间。</p><p><strong>不过在子进程调用<code>exec</code>或<code>exit</code>之前，它在父进程的空间中运行。</strong></p><p><code>vfork</code>保证子进程先运行，在它调用<code>exec</code>或<code>exit</code>之后父进程才可能被调度执行。（如果调用这两个函数之前依赖于父进程的进一步动作，可能会导致死锁）</p><p>下面是<code>vfork</code>的一个实例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>gVal</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>var</span> <span class=o>=</span> <span class=mi>88</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;before fork</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>vfork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>gVal</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>var</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;pid=%ld, gVal=%d, var=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>,</span> <span class=n>gVal</span><span class=p>,</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./vfork_demo
</span></span><span class=line><span class=cl>before fork
</span></span><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span>83780, <span class=nv>gVal</span><span class=o>=</span>2, <span class=nv>var</span><span class=o>=</span><span class=m>89</span>
</span></span></code></pre></div><p>通过上述示例可以看出：</p><ol><li>在子进程中对变量<code>gVal</code>和<code>val</code>变量加1，结果改变了父进程中的变量值，可以确定子进程在父进程的地址空间中运行。</li><li>子进程最后执行<code>_exit</code>而不是<code>exit</code>，是因为<code>_exit</code>并不执行标准I/O缓冲区的冲洗动作。</li><li>如果子进程执行<code>exit</code>函数退出进程，那么输出结果将是不确定，具体结果取决于标准I/O库的实现。<ul><li>如果<code>exit</code>函数仅冲洗标准I/O流，那么这样操作的输出与子进程调用<code>_exit</code>函数产生的输出相同。</li><li>如果<code>exit</code>函数会关闭标准I/O流，那么标准输出FILE对象的相关存储区会被清0。因为子进程使用的是父进程的空间，所以父进程调用<code>printf</code>时会返回-1。</li></ul></li></ol><p><strong>vfork创建的子进程虽然共享父进程的数据空间，但是它还是会有自己的文件描述符数组。</strong> 因为在执行<code>exec</code>函数之前重定向标准流是很常见的事情（这个原因并不充分）。 还有一个原因是<code>vfork</code>只会复制<code>task_struct</code>结构体，因为文件描述符数组也会被复制一份（这个比较靠谱）。</p><h2 id=执行程序><a href=#%e6%89%a7%e8%a1%8c%e7%a8%8b%e5%ba%8f>执行程序</a></h2><h3 id=函数exec><a href=#%e5%87%bd%e6%95%b0exec>函数exec</a></h3><p>当进程调用<code>exec</code>函数时，该进程执行的程序完全替换为新程序，而新程序则从其<code>main</code>函数开始执行。</p><p>因为调用<code>exec</code>函数并不创建新进程，因此进程ID前后不变。</p><p><strong><code>exec</code>只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。</strong></p><p>有7个不同类型的<code>exec</code>函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>extern</span> <span class=kt>char</span> <span class=o>**</span><span class=n>environ</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execl</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>pathname</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg</span><span class=p>,</span> <span class=p>...</span> <span class=cm>/* char* NULL */</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execlp</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>file</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>arg</span><span class=p>,</span> <span class=p>...</span> <span class=cm>/* char* NULL */</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execle</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>pathname</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>arg</span><span class=p>,</span> <span class=p>...</span> <span class=cm>/* char* NULL, char *const envp[] */</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execv</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>pathname</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>argv</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execve</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span><span class=p>[],</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>envp</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execvp</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>file</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>argv</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execvpe</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>file</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>argv</span><span class=p>[],</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>envp</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fexecve</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>argv</span><span class=p>[],</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>envp</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 成功不返回，失败返回-1. */</span>
</span></span></code></pre></div><p><strong>在上述函数中，只有<code>execve</code>是系统调用，其他7个函数都要转换参数然后调用该系统调用。</strong> 下面是函数关系图：
<a data-fancybox=gallery href=../%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/exec%E6%97%8F%E5%87%BD%E6%95%B0%E5%85%B3%E7%B3%BB%E5%9B%BE.png><img class=mx-auto alt src=../%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/exec%E6%97%8F%E5%87%BD%E6%95%B0%E5%85%B3%E7%B3%BB%E5%9B%BE.png></a></p><p>初始参数<code>pathname</code>或<code>file</code>都是将要被执行的文件名。</p><p>函数可以根据前缀<code>exec</code>后面的字符进行分类：</p><table><thead><tr><th style=text-align:left>包含字符</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>l</td><td style=text-align:left>参数都被展开为<code>arg0</code>,<code>arg1</code>,&mldr;,<code>NULL</code>，NULL为结尾，以作为待执行程序中的命令行参数，并且按照惯例，该命令行参数的第一个参数应为待执行程序的文件名。</td></tr><tr><td style=text-align:left>v</td><td style=text-align:left>待执行程序的命令行参数以<code>char* const argv[]</code>数组形式传递，并且数组的最后一个元素为<code>NULL</code>。按照惯例，数组第一个元素应为待执行程序的文件名。</td></tr><tr><td style=text-align:left>e</td><td style=text-align:left>调用进程的环境变量通过<code>char* const envp[]</code>数组传递给待执行程序，数组的最后一个元素为<code>NULL</code>。其他调用方式新程序的环境变量从外部环境中获取。</td></tr><tr><td style=text-align:left>p</td><td style=text-align:left>如果<code>file</code>参数包含<code>/</code>，则当作待执行文件的路径名。否则在<code>PATH</code>环境变量指定的目录中查找该文件。</td></tr></tbody></table><p>下面的例子展示<code>exec</code>族函数的用法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>env_init</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;USER=unkonw&#34;</span><span class=p>,</span> <span class=s>&#34;PATH=/tmp&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 1.验证传递命令行参数 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;current process id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 休眠5s保证子进程先结束 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 从外部获取环境变量 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>execl</span><span class=p>(</span><span class=s>&#34;./echoall&#34;</span><span class=p>,</span> <span class=s>&#34;echoall&#34;</span><span class=p>,</span> <span class=s>&#34;arg1&#34;</span><span class=p>,</span> <span class=s>&#34;arg2&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;execl error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 2.验证传递环境变量 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;current process id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 休眠5s保证子进程先结束 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* echoall进程的环境变量来源于传入的参数 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>execle</span><span class=p>(</span><span class=s>&#34;./echoall&#34;</span><span class=p>,</span> <span class=s>&#34;echoall&#34;</span><span class=p>,</span> <span class=s>&#34;arg3&#34;</span><span class=p>,</span> <span class=s>&#34;arg4&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>env_init</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;execle error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 3.验证传递命令行参数数组 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;current process id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 休眠5s保证子进程先结束 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span><span class=o>*</span> <span class=n>arg</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;echoall&#34;</span><span class=p>,</span> <span class=s>&#34;arg5&#34;</span><span class=p>,</span> <span class=s>&#34;arg6&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 以数组方式传递命令行参数，第一个元素是执行文件名 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>execve</span><span class=p>(</span><span class=s>&#34;./echoall&#34;</span><span class=p>,</span> <span class=n>arg</span><span class=p>,</span> <span class=n>env_init</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;execve error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./exec_test
</span></span><span class=line><span class=cl>current process id is <span class=m>26173</span>
</span></span><span class=line><span class=cl>child process id is <span class=m>26174</span>
</span></span><span class=line><span class=cl><span class=nv>uid</span><span class=o>=</span>1000, <span class=nv>euid</span><span class=o>=</span>1000, <span class=nv>gid</span><span class=o>=</span>1000, <span class=nv>egid</span><span class=o>=</span>1000, <span class=nv>pid</span><span class=o>=</span>26174, <span class=nv>ppid</span><span class=o>=</span><span class=m>26173</span>
</span></span><span class=line><span class=cl>argv:
</span></span><span class=line><span class=cl>argv<span class=o>[</span>0<span class=o>]=</span>echoall
</span></span><span class=line><span class=cl>argv<span class=o>[</span>1<span class=o>]=</span>arg1
</span></span><span class=line><span class=cl>argv<span class=o>[</span>2<span class=o>]=</span>arg2
</span></span><span class=line><span class=cl>environ:
</span></span><span class=line><span class=cl>environ<span class=o>[</span>0<span class=o>]=</span><span class=nv>SHELL</span><span class=o>=</span>/bin/bash
</span></span><span class=line><span class=cl>environ<span class=o>[</span>1<span class=o>]=</span><span class=nv>LC_ADDRESS</span><span class=o>=</span>zh_CN.UTF-8
</span></span><span class=line><span class=cl>environ<span class=o>[</span>2<span class=o>]=</span><span class=nv>LC_NAME</span><span class=o>=</span>zh_CN.UTF-8
</span></span><span class=line><span class=cl>environ<span class=o>[</span>3<span class=o>]=</span><span class=nv>LC_MONETARY</span><span class=o>=</span>zh_CN.UTF-8
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>environ<span class=o>[</span>34<span class=o>]=</span><span class=nv>_</span><span class=o>=</span>./exec_test
</span></span><span class=line><span class=cl>current process id is <span class=m>26173</span>
</span></span><span class=line><span class=cl>child process id is <span class=m>26175</span>
</span></span><span class=line><span class=cl><span class=nv>uid</span><span class=o>=</span>1000, <span class=nv>euid</span><span class=o>=</span>1000, <span class=nv>gid</span><span class=o>=</span>1000, <span class=nv>egid</span><span class=o>=</span>1000, <span class=nv>pid</span><span class=o>=</span>26175, <span class=nv>ppid</span><span class=o>=</span><span class=m>26173</span>
</span></span><span class=line><span class=cl>argv:
</span></span><span class=line><span class=cl>argv<span class=o>[</span>0<span class=o>]=</span>echoall
</span></span><span class=line><span class=cl>argv<span class=o>[</span>1<span class=o>]=</span>arg3
</span></span><span class=line><span class=cl>argv<span class=o>[</span>2<span class=o>]=</span>arg4
</span></span><span class=line><span class=cl>environ:
</span></span><span class=line><span class=cl>environ<span class=o>[</span>0<span class=o>]=</span><span class=nv>USER</span><span class=o>=</span>unkonw
</span></span><span class=line><span class=cl>environ<span class=o>[</span>1<span class=o>]=</span><span class=nv>PATH</span><span class=o>=</span>/tmp
</span></span><span class=line><span class=cl>current process id is <span class=m>26173</span>
</span></span><span class=line><span class=cl>child process id is <span class=m>26176</span>
</span></span><span class=line><span class=cl><span class=nv>uid</span><span class=o>=</span>1000, <span class=nv>euid</span><span class=o>=</span>1000, <span class=nv>gid</span><span class=o>=</span>1000, <span class=nv>egid</span><span class=o>=</span>1000, <span class=nv>pid</span><span class=o>=</span>26176, <span class=nv>ppid</span><span class=o>=</span><span class=m>26173</span>
</span></span><span class=line><span class=cl>argv:
</span></span><span class=line><span class=cl>argv<span class=o>[</span>0<span class=o>]=</span>echoall
</span></span><span class=line><span class=cl>argv<span class=o>[</span>1<span class=o>]=</span>arg5
</span></span><span class=line><span class=cl>argv<span class=o>[</span>2<span class=o>]=</span>arg6
</span></span><span class=line><span class=cl>environ:
</span></span><span class=line><span class=cl>environ<span class=o>[</span>0<span class=o>]=</span><span class=nv>USER</span><span class=o>=</span>unkonw
</span></span><span class=line><span class=cl>environ<span class=o>[</span>1<span class=o>]=</span><span class=nv>PATH</span><span class=o>=</span>/tmp
</span></span></code></pre></div><p>根据<code>echoall</code>和<code>exec_test</code>两个程序打印的结果来看，新程序的<strong>进程ID</strong>、<strong>实际用户ID</strong>、<strong>实际组ID</strong>等都不会发生变化，而<strong>有效用户ID和有效组ID取决于程序文件有没有设置设置用户ID位和设置组ID位。</strong></p><p>对打开文件的处理与每个描述符的执行时关闭标志（FD_CLOEXEC）有关。若设置了该标志，则在执行<code>exec</code>时会关闭该描述符。</p><p><strong>POSIX.1明确要求在<code>exec</code>时关闭打开目录流，<code>opendir</code>函数中调用<code>fcntl</code>函数为打开目录流的描述符表了执行时关闭（FD_CLOEXEC）。</strong></p><h3 id=函数system><a href=#%e5%87%bd%e6%95%b0system>函数system</a></h3><p><code>system</code>函数是有ISO C定义的，但是POSIX.1对<code>system</code>函数进行扩展。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>system</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>cmdstring</span><span class=p>);</span>
</span></span></code></pre></div><p><code>system</code>函数的执行有3个过程：</p><ol><li><code>fork</code>创建子进程。</li><li><code>exec</code>函数执行调用<code>/bin/sh -c</code>执行命令。</li><li><code>waitpid</code>函数等待执行结果。</li></ol><p>上述3个过程都可能出错，因此导致<code>system</code>函数的返回值取决于上述3个过程的执行结果。</p><p>当<code>fork</code>执行失败时，返回-1。</p><p>当<code>waitpid</code>执行失败时，也返回-1。</p><p>当<code>exec</code>执行失败时，返回127，等同于<code>/bin/sh</code>执行<code>exit(127)</code>。</p><p><strong>当3个过程都没有失败，才会返回命令执行后的结果。</strong></p><p>下面的例子展示了这一点：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>status</span> <span class=o>=</span> <span class=nf>system</span><span class=p>(</span><span class=s>&#34;/tmp/test&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 1. 判断是否是fork或waitpid错误 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;system error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 2. 判断进程是否正常终止 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>WIFEXITED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 正常终止 */</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;normal termination, exit status is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WEXITSTATUS</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 3. 判断退出码是否是指定值 */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>WEXITSTATUS</span><span class=p>(</span><span class=n>status</span><span class=p>)</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* 是，表示命令执行成功 */</span>
</span></span><span class=line><span class=cl>                <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;command executed successfully</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;command executed failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nf>WIFSIGNALED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 异常终止 */</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;abnormal termination, signal is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WTERMSIG</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;exception</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./system_test
</span></span><span class=line><span class=cl>sh: 1: /tmp/test: not found
</span></span><span class=line><span class=cl><span class=c1># 下面的结果表示fork创建进程成功，但是sh执行失败。</span>
</span></span><span class=line><span class=cl>normal termination, <span class=nb>exit</span> status is <span class=m>127</span>
</span></span><span class=line><span class=cl><span class=nb>command</span> executed failed
</span></span></code></pre></div><p>下面是<code>system</code>函数的一个实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>mysystem</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>cmdstring</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cmdstring</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>status</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>execl</span><span class=p>(</span><span class=s>&#34;/bin/sh&#34;</span><span class=p>,</span> <span class=s>&#34;sh&#34;</span><span class=p>,</span> <span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=n>cmdstring</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=mi>127</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=nf>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>!=</span> <span class=n>EINTR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>status</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>print_exit</span><span class=p>(</span><span class=kt>int</span> <span class=n>status</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>WIFEXITED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;normal termination, exit status = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WEXITSTATUS</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nf>WIFSIGNALED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 异常终止子进程的信号编号 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;abnormal termination, signal number = %d%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WTERMSIG</span><span class=p>(</span><span class=n>status</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 是否已经产生core文件 */</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef WCOREDUMP
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=nf>WCOREDUMP</span><span class=p>(</span><span class=n>status</span><span class=p>)</span> <span class=o>?</span> <span class=s>&#34;(core file generated)&#34;</span> <span class=o>:</span> <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nf>WIFSTOPPED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 当前暂停子进程的信号编号 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child stopped, signal number = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WSTOPSIG</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>status</span> <span class=o>=</span> <span class=nf>mysystem</span><span class=p>(</span><span class=s>&#34;date&#34;</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;mysystem error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>print_exit</span><span class=p>(</span><span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>status</span> <span class=o>=</span> <span class=nf>mysystem</span><span class=p>(</span><span class=s>&#34;nosuchcommand&#34;</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;mysystem error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>print_exit</span><span class=p>(</span><span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>status</span> <span class=o>=</span> <span class=nf>mysystem</span><span class=p>(</span><span class=s>&#34;who; exit 44&#34;</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;mysystem error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>print_exit</span><span class=p>(</span><span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./system_new
</span></span><span class=line><span class=cl>2022年 07月 18日 星期一 23:24:33 JST
</span></span><span class=line><span class=cl>normal termination, <span class=nb>exit</span> <span class=nv>status</span> <span class=o>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>sh: 1: nosuchcommand: not found
</span></span><span class=line><span class=cl>normal termination, <span class=nb>exit</span> <span class=nv>status</span> <span class=o>=</span> <span class=m>127</span>
</span></span><span class=line><span class=cl>blduan   tty2         2022-07-18 22:52 <span class=o>(</span>tty2<span class=o>)</span>
</span></span><span class=line><span class=cl>blduan   pts/0        2022-07-18 22:52 <span class=o>(</span>192.168.1.4<span class=o>)</span>
</span></span><span class=line><span class=cl>normal termination, <span class=nb>exit</span> <span class=nv>status</span> <span class=o>=</span> <span class=m>44</span>
</span></span></code></pre></div><p><strong>bash程序不带-p参数，并且当进程的实际用户和有效用户不一致时， 会调用<code>setuid</code>将进程的有效用户和保存的设置用户ID都设置为实际用户ID。如果带-p参数，则保持不变。</strong></p><h3 id=解释器文件><a href=#%e8%a7%a3%e9%87%8a%e5%99%a8%e6%96%87%e4%bb%b6>解释器文件</a></h3><p><strong>解释器文件是文本文件，其起始行的形式是<code>#! pathname [option-argument]</code>，感叹号和<code>pathname</code>之间的空格可选。</strong></p><p>所有的类Unix系统都支持解释器文件，最常见的解释器文件的起始行是<code>#! /bin/sh</code>。</p><p>其中<code>pathname</code>通常是绝对路径名，对这种文件的识别是由内核在作为<code>exec</code>系统调用的一部分来完成的。内核使调用<code>exec</code>函数的进程实际执行的并不是该解释器文件，而是在该解释器文件第一行中<code>pathname</code>所指定的文件。</p><p>下面的代码执行了一个解释器文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>execl</span><span class=p>(</span><span class=s>&#34;./testinterp&#34;</span><span class=p>,</span> <span class=s>&#34;testinterp&#34;</span><span class=p>,</span> <span class=s>&#34;myarg1&#34;</span><span class=p>,</span> <span class=s>&#34;MY ARG2&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;execl error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;waitpid error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 下面查看解释器文件的内容</span>
</span></span><span class=line><span class=cl>$ cat testinterp
</span></span><span class=line><span class=cl><span class=c1>#! /home/blduan/projects/code_snippet/unix_code/8_chapter/echoarg foo</span>
</span></span><span class=line><span class=cl>$ ./exec_interpreter
</span></span><span class=line><span class=cl><span class=c1># argv[0]是解释器文件中的pathname, argv[1]是解释器文件的可选参数。</span>
</span></span><span class=line><span class=cl>argv<span class=o>[</span>0<span class=o>]=</span>/home/blduan/projects/code_snippet/unix_code/8_chapter/echoarg
</span></span><span class=line><span class=cl>argv<span class=o>[</span>1<span class=o>]=</span>foo
</span></span><span class=line><span class=cl><span class=c1># execl携带的命令行参数偏移了两个位置，</span>
</span></span><span class=line><span class=cl><span class=c1># 并且将execl函数的第一个参数作为传递给子进程的第一个命令行参数输出，而本来的第一个命令行参数被忽略。</span>
</span></span><span class=line><span class=cl>argv<span class=o>[</span>2<span class=o>]=</span>./testinterp
</span></span><span class=line><span class=cl>argv<span class=o>[</span>3<span class=o>]=</span>myarg1
</span></span><span class=line><span class=cl>argv<span class=o>[</span>4<span class=o>]=</span>MY ARG2
</span></span></code></pre></div><p>另一个解释器文件内容如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># -f参数指定了从接下来的内容中读取解释器awk要执行代码</span>
</span></span><span class=line><span class=cl>$ cat awkexample
</span></span><span class=line><span class=cl><span class=c1>#! /usr/bin/awk -f</span>
</span></span><span class=line><span class=cl><span class=c1># Note: on Ubuntu, use nawk instead</span>
</span></span><span class=line><span class=cl>BEGIN <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=nv>i</span><span class=o>=</span>0<span class=p>;</span> i&lt;ARGC<span class=p>;</span> i++<span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>printf</span> <span class=s2>&#34;ARGV[%d]=%s\n&#34;</span>, i, ARGV<span class=o>[</span>i<span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=nb>exit</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1># 使用execl函数执行和下面的效果一致</span>
</span></span><span class=line><span class=cl>$ /usr/bin/awk -f ./awkexample myarg1 <span class=s2>&#34;MY ARG2&#34;</span>
</span></span><span class=line><span class=cl>ARGV<span class=o>[</span>0<span class=o>]=</span>awk
</span></span><span class=line><span class=cl>ARGV<span class=o>[</span>1<span class=o>]=</span>myarg1
</span></span><span class=line><span class=cl>ARGV<span class=o>[</span>2<span class=o>]=</span>MY ARG2
</span></span></code></pre></div><p><strong>解释器文件的用途</strong>：可以隐藏具体的程序内容，该程序可以是一个脚本也可以是一个二进制文件。可以写除/bin/sh之外的脚本文件，因为默认总是调用/bin/sh来执行文件。</p><h2 id=进程终止><a href=#%e8%bf%9b%e7%a8%8b%e7%bb%88%e6%ad%a2>进程终止</a></h2><h3 id=函数exit><a href=#%e5%87%bd%e6%95%b0exit>函数exit</a></h3><p>进程有5种正常终止方式和3种异常终止方式：</p><table><thead><tr><th style=text-align:left>进程正常终止方式</th><th style=text-align:left>说明</th><th style=text-align:left>进程异常终止方式</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><code>main</code>函数执行<code>return</code>语句</td><td style=text-align:left>等同于调用<code>exit</code></td><td style=text-align:left>调用<code>abort</code></td><td style=text-align:left>会产生SIGABRT信号</td></tr><tr><td style=text-align:left>调用<code>exit</code>函数</td><td style=text-align:left>ISO C定义，会调用各终止处理程序（<code>aexit</code>注册的），关闭所有标准I/O流</td><td style=text-align:left>进程接收到某些信号。</td><td style=text-align:left>信号可有进程自身、其他进程或内核产生</td></tr><tr><td style=text-align:left>调用<code>_exit</code>或<code>_Exit</code>函数</td><td style=text-align:left>ISO C定义了<code>_Exit</code>，目的是为进程提供一种无需执行终止程序或信号处理程序的终止方法。是否对标准I/O流冲洗取决于实现。Unix系统中，<code>_Exit</code>和<code>_exit</code>同义，并不冲洗标准I/O流。<code>_exit</code>函数由<code>exit</code>调用，用于处理Unix系统的特定细节。</td><td style=text-align:left>最后一个线程对<code>取消</code>请求做出响应</td><td style=text-align:left></td></tr><tr><td style=text-align:left>进程的最后一个线程在其启动历程中执行<code>return</code>语句</td><td style=text-align:left>该线程的返回值不用作进程的返回值，该进程以终止状态0返回。</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left>进程的最后一个线程调用<code>pthread_exit</code>函数</td><td style=text-align:left>进程的终止状态为0，和传递给<code>pthread_exit</code>的参数无关。</td><td style=text-align:left></td><td style=text-align:left></td></tr></tbody></table><p><strong>不管进程如何终止，最后都会执行内核中的同一段代码。这段代码用以为相应进程关闭所有打开的描述符，释放他们使用的存储器等。</strong></p><p>对于进程的任意一种终止情形，内核都能够通知到其父进程终止状态是什么。</p><ol><li>对于终止进程调用<code>_exit, _Exit, exit</code>终止函数，其函数参数为<strong>退出状态</strong>，内核在最终调用<code>_exit</code>时会将退出状态转化为进程的<strong>终止状态</strong>。</li><li>对于终止进程异常终止情况，内核会产生指示其终止原因的终止状态。</li><li>在任意一种情况下，该终止进程的父进程都能够通过<code>wait</code>和<code>waitpid</code>函数来获取其终止状态。</li></ol><p>有两种特殊情况：</p><ol><li>父进程在子进程之前终止：对于父进程已经终止的所有进程，它们的父进程都改变为<code>init</code>进程。</li><li>子进程在父进程之前终止：内核为每个进程都保存了一定量的信息，父进程可以通过<code>wait</code>或<code>waitpid</code>来获取这些信息（CPU时间总量，进程终止状态等）。</li></ol><p><strong>一个已经终止，但是其父进程并未对其进行善后处理（获取终止子进程的有关信息、释放其占用的资源）的进程被称为僵死进程。</strong> <code>init</code>进程在其子进程终止时会自动调用<code>wait</code>函数，获取终止进程的信息、释放资源。</p><p>下面的例子演示了父进程在子进程之前终止，子进程的父进程变为<code>init</code>进程：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;pid=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./parent_proc_init
</span></span><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span><span class=m>94706</span>
</span></span><span class=line><span class=cl>$ ps -ef <span class=p>|</span> grep <span class=m>94706</span>
</span></span><span class=line><span class=cl>blduan     <span class=m>94706</span>       <span class=m>1</span>  <span class=m>0</span> 00:02 pts/0    00:00:00 ./parent_proc_init
</span></span></code></pre></div><p>下面的示例演示父进程一直不获取子进程终止后的终止状态，子进程将变为<strong>僵死进程</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;pid=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./child_proc_zombie
</span></span><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span><span class=m>95612</span>
</span></span><span class=line><span class=cl>^C
</span></span><span class=line><span class=cl>$ ps -aux <span class=p>|</span> grep <span class=m>95612</span>
</span></span><span class=line><span class=cl>blduan     <span class=m>95612</span>  0.0  0.0      <span class=m>0</span>     <span class=m>0</span> pts/0    Z+   00:07   0:00 <span class=o>[</span>child_proc_zomb<span class=o>]</span> &lt;defunct&gt;
</span></span></code></pre></div><p>僵死进程的标志是Z+。</p><h3 id=函数wait族><a href=#%e5%87%bd%e6%95%b0wait%e6%97%8f>函数wait族</a></h3><p><strong>当一个进程无论正常还是异常终止，内核都会向其父进程发送SIGCHLD信号。</strong></p><p>下面的函数用来获取子进程的终止状态：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>wait</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>statloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>waitpid</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>statloc</span><span class=p>,</span> <span class=kt>int</span> <span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回进程ID，失败返回0 */</span>
</span></span></code></pre></div><p>函数参数<code>statloc</code>为整形指针，如果不是NULL，则将终止进程的终止状态保存在其中。</p><ol><li>收到SIGCHLD信号而调用<code>wait</code>函数，<code>wait</code>函数立即返回。</li><li>随机时间点调用<code>wait</code>函数，结果如下：<ul><li>如果所有子进程都正在运行，阻塞。</li><li>如果一个子进程已终止，正在等待父进程获取其终止状态（此时子进程为僵死进程），则立即返回该子进程的终止状态。</li><li>如果没有任何子进程，则出错返回。</li></ul></li></ol><p>下面的例子验证了没有任何子进程时，调用<code>wait</code>函数会直接出错返回。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;wait error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>wait</span> error: : No child processes
</span></span></code></pre></div><p>下面的例子验证子进程正在运行时，父进程调用<code>wait</code>会阻塞。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process is running</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process is blocking</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;wait error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;wait return</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>r$ ./wait_block
</span></span><span class=line><span class=cl>child process is blocking
</span></span><span class=line><span class=cl>child process is running
</span></span></code></pre></div><p>下面的例子验证当子进程已经终止成为僵死进程时，调用<code>wait</code>会直接返回。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process exit</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>statloc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;wait return is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>statloc</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;exit code is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>statloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>WIFEXITED</span><span class=p>(</span><span class=n>statloc</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WEXITSTATUS</span><span class=p>(</span><span class=n>statloc</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nf>WIFSIGNALED</span><span class=p>(</span><span class=n>statloc</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WTERMSIG</span><span class=p>(</span><span class=n>statloc</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./wait_return
</span></span><span class=line><span class=cl>child process id is <span class=m>110121</span>
</span></span><span class=line><span class=cl>child process <span class=nb>exit</span>
</span></span><span class=line><span class=cl><span class=nb>wait</span> <span class=k>return</span> is <span class=m>110121</span>
</span></span><span class=line><span class=cl><span class=m>3</span>
</span></span></code></pre></div><p>下面的例子验证在SIGCHLD信号处理程序中执行<code>wait</code>函数会直接返回。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>handle_sig_cancel</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 验证信号处理函数中执行wait是否阻塞 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;signal handle</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;wait error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;wait return</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>signal</span><span class=p>(</span><span class=n>SIGCHLD</span><span class=p>,</span> <span class=n>handle_sig_cancel</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process is running</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process is blocking</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 阻止父进程退出 */</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./wait_sig_cancel
</span></span><span class=line><span class=cl>child process id is <span class=m>109947</span>
</span></span><span class=line><span class=cl>child process is blocking
</span></span><span class=line><span class=cl>child process is running
</span></span><span class=line><span class=cl>signal handle
</span></span><span class=line><span class=cl><span class=nb>wait</span> <span class=k>return</span>
</span></span></code></pre></div><p><strong>父进程可以通过<code>wait</code>函数返回的整形状态字来判断子进程是否正常终止。</strong></p><p>整型状态字是由系统定义的，其中某些位表示<strong>退出状态</strong>（正常终止），其他为表示<strong>信号编号</strong>（异常终止），有一位表示是否产生core文件。</p><p>系统提供了4个互斥的宏来取得进程终止的原因。其所在头文件为<code>#include &lt;sys/wait.h></code></p><table><thead><tr><th style=text-align:left>宏</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><code>WIFEXITED(status)</code></td><td style=text-align:left>若为正常终止子进程返回的状态，则为真。对于这种情况可执行<code>WEXITSTATUS(status)</code> 获取子进程传给<code>exit</code>函数的参数的低8位。</td></tr><tr><td style=text-align:left><code>WIFSIGNALED(status)</code></td><td style=text-align:left>若为异常终止子进程返回的状态，则为真。对于这种情况，可以执行<code>WTERMSIG(status)</code>，获取使子进程终止的信号编号。 有些实现会定义宏<code>WCOREDUMP(status)</code>，若已产生终止进程的core文件，则它返回真。</td></tr><tr><td style=text-align:left><code>WIFSTOPPED(status)</code></td><td style=text-align:left>若为当前暂停子进程的返回的状态，则为真。对于这种情况，可执行<code>WSTOPSIG(status)</code>获取使子进程暂停的信号编号。</td></tr><tr><td style=text-align:left><code>WIFCONTINUED(status)</code></td><td style=text-align:left>若在作业控制暂停后已经继续的子进程返回了状态，则为真。</td></tr></tbody></table><p>下面的例子展示了如何使用这些宏：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>print_exit</span><span class=p>(</span><span class=kt>int</span> <span class=n>status</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>WIFEXITED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;normal termination, exit status = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WEXITSTATUS</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nf>WIFSIGNALED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 异常终止子进程的信号编号 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;abnormal termination, signal number = %d%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WTERMSIG</span><span class=p>(</span><span class=n>status</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 是否已经产生core文件 */</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef WCOREDUMP
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=nf>WCOREDUMP</span><span class=p>(</span><span class=n>status</span><span class=p>)</span> <span class=o>?</span> <span class=s>&#34;(core file generated)&#34;</span> <span class=o>:</span> <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nf>WIFSTOPPED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 当前暂停子进程的信号编号 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child stopped, signal number = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WSTOPSIG</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 子进程正常终止 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>status</span><span class=p>)</span> <span class=o>!=</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;wait error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>print_exit</span><span class=p>(</span><span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 子进程异常终止，产生信号SIGABRT */</span>
</span></span><span class=line><span class=cl>        <span class=nf>abort</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>status</span><span class=p>)</span> <span class=o>!=</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;wait error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>print_exit</span><span class=p>(</span><span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 子进程异常终止，产生SIGFPE信号 */</span>
</span></span><span class=line><span class=cl>        <span class=n>status</span> <span class=o>/=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>status</span><span class=p>)</span> <span class=o>!=</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;wait error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>print_exit</span><span class=p>(</span><span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./print_exit
</span></span><span class=line><span class=cl>normal termination, <span class=nb>exit</span> <span class=nv>status</span> <span class=o>=</span> <span class=m>7</span>
</span></span><span class=line><span class=cl>abnormal termination, signal <span class=nv>number</span> <span class=o>=</span> 6<span class=o>(</span>core file generated<span class=o>)</span>
</span></span><span class=line><span class=cl>abnormal termination, signal <span class=nv>number</span> <span class=o>=</span> 8<span class=o>(</span>core file generated<span class=o>)</span>
</span></span></code></pre></div><p><strong>如果一个进程有多个子进程，那么只要其中一个子进程终止，<code>wait</code>函数就返回。</strong> 如果要等待指定的进程终止，可以使用<code>waitpid</code>函数。</p><h4 id=waitpid函数><a href=#waitpid%e5%87%bd%e6%95%b0>waitpid函数</a></h4><p><code>waitpid</code>函数参数说明：</p><p><code>pid</code>参数作用如下：</p><ul><li>pid==-1，等待任一子进程， 和<code>wait</code>函数等效。</li><li>pid > 0，等待进程ID与pid相等的子进程。</li><li>pid == 0，等待组ID等调用进程组ID的任一子进程。（同组的子进程）</li><li>pid &lt; -1，等待组ID等于pid绝对值的任一子进程。（指定组的子进程）</li></ul><p><code>waitpid</code>函数返回终止子进程的进程ID，并将该子进程的终止状态保存在<code>statloc</code>指向的存储单元中。</p><p><strong>如果指定的进程或进程组不存在，则<code>waitpid</code>调用会出错。</strong></p><p><code>option</code>参数取值范围是0和以下的值：</p><table><thead><tr><th style=text-align:left>常量</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>WCONTINUED</td><td style=text-align:left>若实现作业控制，那么有pid指定的任一子进程在停止后已经继续，但其状态未报告，则返回其状态。</td></tr><tr><td style=text-align:left>WHONANG</td><td style=text-align:left>若有pid指定的子进程并不是立即可用的，则<code>waitpid</code>不阻塞，此时返回值是0。</td></tr><tr><td style=text-align:left>WUNTRACED</td><td style=text-align:left>若某实现作业控制，而由pid指定的任一子进程已终止，并且其状态还未报告过，则返回其状态。WIFSTOPPED宏确定返回值是否对应与一个停止的子进程。</td></tr></tbody></table><p><code>waitpid</code>函数默认会阻塞调用进程，除非<code>options</code>参数设置为WHONANG。<code>options=WHONANG|WUNTRACED</code>时，返回值为0表示没有停止或终止的子进程，非0表示停止或终止的子进程ID。</p><p>非阻塞版的<code>wait</code>调用可以这么写<code>waitpid(-1, NULL, WNOHANG|WUNTRACED)</code>，含义是等待任一子进程并立即返回，若子进程终止返回子进程id，否则返回0。</p><p><strong>下面的代码验证WNOHANG参数的作用</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process is running</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* WNOHANG表示pid指定的子进程不是可用的，则立即返回0 */</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>WNOHANG</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;waitpid return</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process id is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;waitpid error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./waitpid_nohang
</span></span><span class=line><span class=cl>waitpid <span class=k>return</span>
</span></span><span class=line><span class=cl>child process is running
</span></span><span class=line><span class=cl>$ ps -a
</span></span><span class=line><span class=cl>    PID TTY          TIME CMD
</span></span><span class=line><span class=cl>   <span class=m>1562</span> pts/0    00:00:00 waitpid_nohang
</span></span><span class=line><span class=cl>   <span class=m>1567</span> pts/0    00:00:00 ps
</span></span></code></pre></div><h4 id=waitid函数><a href=#waitid%e5%87%bd%e6%95%b0>waitid函数</a></h4><p>POSIX.1的超集Single UNIX Specification定义了一个额外的获取终止进程状态的函数<code>waitid</code>，类似与<code>waitpid</code>，但灵活性更强。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/type.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>waitid</span><span class=p>(</span><span class=kt>idtype_t</span> <span class=n>idtype</span><span class=p>,</span> <span class=kt>id_t</span> <span class=n>id</span><span class=p>,</span> <span class=kt>siginfo_t</span> <span class=o>*</span><span class=n>infop</span><span class=p>,</span> <span class=kt>int</span> <span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回0， 失败返回-1 */</span>
</span></span></code></pre></div><p><code>id</code>参数的作用由<code>idtype</code>参数来决定。<code>idtype</code>的取值返回如下：</p><table><thead><tr><th style=text-align:left>常量</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>P_PID</td><td style=text-align:left>等待进程ID为参数id的进程。</td></tr><tr><td style=text-align:left>P_PGID</td><td style=text-align:left>等待进程组ID为参数id的组内任一子进程。</td></tr><tr><td style=text-align:left>P_ALL</td><td style=text-align:left>等待任一子进程，参数id忽略。</td></tr></tbody></table><p><code>options</code>参数的取值范围如下：</p><table><thead><tr><th style=text-align:left>常量</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>WCONTINUED</td><td style=text-align:left>等待一进程，该进程以前终止过，此后又继续运行，但其状态未报告。</td></tr><tr><td style=text-align:left>WEXITED</td><td style=text-align:left>等待已退出的进程。</td></tr><tr><td style=text-align:left>WNOHANG</td><td style=text-align:left>如无可用的子进程退出状态，则立即返回而非阻塞。</td></tr><tr><td style=text-align:left>WNOWAIT</td><td style=text-align:left>不破坏子进程退出状态。该子进程退出状态可由后续的<code>wait</code>、<code>waitpid</code>等调用获取。</td></tr><tr><td style=text-align:left>WSTOPPED</td><td style=text-align:left>等待一进程，它已经停止，但状态未曾报告。</td></tr></tbody></table><p>WCONTINUED、WEXITED和WSTOPPED三个常量，<code>options</code>参数必须选择一个。</p><p><strong>进程停止和终止是不同的，stoped和terminated状态不同。</strong></p><p><code>infop</code>参数是指向<code>siginfo</code>结构的指针，包含了信号相关的信息。</p><p><strong><code>waitid</code>函数默认情况下也会阻塞，除非<code>options</code>参数设置WNOHANG。</strong></p><p>下面的例子测试<code>waitid</code>函数的基本用法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>siginfo_t</span> <span class=n>sig</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>waitid</span><span class=p>(</span><span class=n>P_PID</span><span class=p>,</span> <span class=n>pid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sig</span><span class=p>,</span> <span class=n>WEXITED</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process id is %d, and exited</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d %d %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>sig</span><span class=p>.</span><span class=n>si_code</span><span class=p>,</span> <span class=n>sig</span><span class=p>.</span><span class=n>si_errno</span><span class=p>,</span> <span class=n>sig</span><span class=p>.</span><span class=n>si_signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;waitid error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./waitid_test
</span></span><span class=line><span class=cl><span class=c1># 下面的结果是10s之后打印的，可见waitid会阻塞调用进程。</span>
</span></span><span class=line><span class=cl>child process id is 3715, and exited
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>0</span> <span class=m>17</span>
</span></span></code></pre></div><h4 id=wait3和wait4函数><a href=#wait3%e5%92%8cwait4%e5%87%bd%e6%95%b0>wait3和wait4函数</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/resource.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>wait3</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>wstatus</span><span class=p>,</span> <span class=kt>int</span> <span class=n>options</span><span class=p>,</span> <span class=k>struct</span> <span class=n>rusage</span> <span class=o>*</span><span class=n>rusage</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>wait4</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>wstatus</span><span class=p>,</span> <span class=kt>int</span> <span class=n>options</span><span class=p>,</span> <span class=k>struct</span> <span class=n>rusage</span> <span class=o>*</span><span class=n>rusage</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回进程id， 失败返回-1 */</span>
</span></span></code></pre></div><p>这两个函数会返回终止进程及其子进程的资源概况，其中包括CPU时间总量、系统CPU时间总量、缺页次数、接收不到信号的次数等。</p><h2 id=进程属性><a href=#%e8%bf%9b%e7%a8%8b%e5%b1%9e%e6%80%a7>进程属性</a></h2><h3 id=实际用户><a href=#%e5%ae%9e%e9%99%85%e7%94%a8%e6%88%b7>实际用户</a></h3><p><strong>任一进程都可以得到其实际用户ID、有效用户ID以及组ID。</strong> 也可以得到运行该程序的登录名，即实际用户名。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>char</span><span class=o>*</span> <span class=nf>getlogin</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回登录用户名，失败返回NULL */</span>
</span></span></code></pre></div><p>有时多个用户名可以对应一个用户ID。通过上述函数获得登录名之后，就可以调用<code>getpwnam</code>在口令文件中查找相应记录，进而确定其登录终端。</p><p><strong>如果调用此函数的进程没有连接到用户登录时所用的终端，则函数会失败，通常称这些进程为守护进程。</strong></p><p>调用实例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=nf>getlogin</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 执行结果如下： */</span>
</span></span><span class=line><span class=cl><span class=err>$</span> <span class=p>.</span><span class=o>/</span><span class=n>get_login_name</span>
</span></span><span class=line><span class=cl><span class=n>blduan</span>
</span></span></code></pre></div><h3 id=竞争条件><a href=#%e7%ab%9e%e4%ba%89%e6%9d%a1%e4%bb%b6>竞争条件</a></h3><p>当多个进程都企图对共享数据进行某种处理，而最后的结果取决于进程运行的顺序，此时就发生竞争条件。</p><p>如果<code>fork</code>之后的逻辑显式或隐式的依赖于<code>fork</code>之后是父进程先运行还是子进程先运行，那么<code>fork</code>函数会就会产生竞争条件。</p><p>如果一个进程希望等待一个子进程终止，则它必须调用<code>wait</code>函数中的一个。如果一个进程要等待其父进程终止，则可以使用下面的循环条件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=nf>getppid</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面这种方式被称为<strong>轮询</strong>，存在的问题是浪费CPU时间，因为调用者每隔1s都被唤醒，然后进行条件测试。</p><p>为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号发送和接收的方法。</p><h3 id=调度><a href=#%e8%b0%83%e5%ba%a6>调度</a></h3><p>Unix系统历史上对进程提供的只是基于优先级的粗粒度的控制。调度策略和调度优先级由内核控制。进程可以通过调整友好值选择以更低优先级运行。<strong>只有特权进程允许提高优先级。</strong></p><p>Linux系统的友好值范围是-20~19，<strong>友好值越低，优先级越高。</strong></p><p>进程可以通过<code>nice</code>函数获取或修改其友好值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>nice</span><span class=p>(</span><span class=kt>int</span> <span class=n>incr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回新的友好值，失败返回-1 */</span>
</span></span></code></pre></div><p><code>incr</code>参数被增加到调用进程的现有友好值上。如果<code>incr</code>太大，系统直接把它降低到最大合法值；相反，如果<code>incr</code>太小，系统也会提高到最小合法值。</p><p>调用成功并且返回-1，但<code>errno</code>为0，也被视为调用成功。</p><p>下面的例子打印<code>NZERO</code>的值，并在单核CPU中父子进程分别以不同友好值运行10s，来进行判断父子进程占用CPU的情况。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>timeval</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>check_time</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>timeval</span> <span class=n>tv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>gettimeofday</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tv</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>tv</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>&gt;=</span> <span class=n>end</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>&amp;&amp;</span> <span class=n>tv</span><span class=p>.</span><span class=n>tv_usec</span> <span class=o>&gt;=</span> <span class=n>end</span><span class=p>.</span><span class=n>tv_usec</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s count=%lld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 1.获取友好值范围 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>nzero</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>incr</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>name</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>setbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef NZERO
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>nzero</span> <span class=o>=</span> <span class=n>NZERO</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#elif _SC_NZERO
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>nzero</span> <span class=o>=</span> <span class=nf>sysconf</span><span class=p>(</span><span class=n>_SC_NZERO</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;NZERO=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>nzero</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 2. 从输入参数中获取incr */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>incr</span> <span class=o>=</span> <span class=nf>strtol</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>gettimeofday</span><span class=p>(</span><span class=o>&amp;</span><span class=n>end</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>+=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 3. 创建子进程和父进程运行相同的时间，并计数 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 子进程 */</span>
</span></span><span class=line><span class=cl>        <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;child&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;current nice value in child is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>nice</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>errno</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>ret</span> <span class=o>=</span> <span class=nf>nice</span><span class=p>(</span><span class=n>incr</span><span class=p>))</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>errno</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;nice error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;current nice value in child is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 父进程 */</span>
</span></span><span class=line><span class=cl>        <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;parent&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;current nice value in parent is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>nice</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 4. 父子进程开始计数，根据计数的值来判断占用CPU的时间长度 */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>++</span><span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>check_time</span><span class=p>(</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./nice_test
</span></span><span class=line><span class=cl><span class=nv>NZERO</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>current nice value in parent is <span class=m>0</span>
</span></span><span class=line><span class=cl>current nice value in child is <span class=m>0</span>
</span></span><span class=line><span class=cl>current nice value in child is <span class=m>0</span>
</span></span><span class=line><span class=cl>parent <span class=nv>count</span><span class=o>=</span><span class=m>320828014</span>
</span></span><span class=line><span class=cl>child <span class=nv>count</span><span class=o>=</span><span class=m>321910059</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ./nice_test <span class=m>20</span>
</span></span><span class=line><span class=cl><span class=nv>NZERO</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>current nice value in parent is <span class=m>0</span>
</span></span><span class=line><span class=cl>current nice value in child is <span class=m>0</span>
</span></span><span class=line><span class=cl>current nice value in child is <span class=m>19</span>
</span></span><span class=line><span class=cl>parent <span class=nv>count</span><span class=o>=</span><span class=m>652649803</span>
</span></span><span class=line><span class=cl>child <span class=nv>count</span><span class=o>=</span><span class=m>9793971</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sudo ./nice_test -20
</span></span><span class=line><span class=cl><span class=nv>NZERO</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>current nice value in parent is <span class=m>0</span>
</span></span><span class=line><span class=cl>current nice value in child is <span class=m>0</span>
</span></span><span class=line><span class=cl>current nice value in child is -20
</span></span><span class=line><span class=cl>child <span class=nv>count</span><span class=o>=</span><span class=m>655302483</span>
</span></span><span class=line><span class=cl>parent <span class=nv>count</span><span class=o>=</span><span class=m>7797852</span>
</span></span></code></pre></div><p>从结果中可以看出，当父子进程同时以友好值0运行时，优先级相同，占用CPU比例分别为 $\frac {320828014}{(320828014+321910059)} =49.92 \%$ 和 $\frac {321910059}{(320828014+321910059)} =50.08 \%$，两者基本相同。</p><p>当父子进程同时分别以友好值0和19运行时，父进程优先级高，子进程优先级低，占用CPU的比例分别为 $\frac {652649803}{652649803+9793971} = 98.52 \%$ 和 $\frac {9793971}{652649803+9793971} = 1.48 \%$</p><p>当父子进程分别以友好值0和-20运行时，子进程优先级高，父进程优先级低，占用CPU的比例分别为 $\frac {7797852}{655302483+7797852} = 1.18\%$ 和 $\frac {655302483}{655302483+7797852} = 98.82\%$</p><p>因此，<strong>调度程序会根据进程的友好值，来决定分配CPU时间片的多少。</strong></p><p><code>getpriority</code>函数不仅可以像<code>nice</code>函数获取单个进程的友好值，也可以获取一组相关进程的友好值。<code>setpriority</code>函数可用于为进程、进程组和属于特定用户ID的所有进程设置优先级。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/resource.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>getpriority</span><span class=p>(</span><span class=kt>int</span> <span class=n>which</span><span class=p>,</span> <span class=kt>id_t</span> <span class=n>who</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回友好值，失败返回-1 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setpriority</span><span class=p>(</span><span class=kt>int</span> <span class=n>which</span><span class=p>,</span> <span class=kt>id_t</span> <span class=n>who</span><span class=p>,</span> <span class=kt>int</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 增加value到现有友好值上，成功返回0， 失败返回-1 */</span>
</span></span></code></pre></div><p>参数解释如下：</p><table><thead><tr><th style=text-align:left>which</th><th style=text-align:left>who</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>PRIO_PROCESS</td><td style=text-align:left>0</td><td style=text-align:left>表示调用进程ID</td></tr><tr><td style=text-align:left>PRIO_PGRP</td><td style=text-align:left>0</td><td style=text-align:left>调用进程组ID</td></tr><tr><td style=text-align:left>PRIO_USER</td><td style=text-align:left>0</td><td style=text-align:left>调用进程的实际用户ID</td></tr></tbody></table><p><strong>如果<code>which</code>参数作用于多个进程，则返回所有作用进程中优先级最高的（友好值最小的）。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/resource.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;PRIO_PROCESS: %d PRIO_PGRP: %d PRIO_USER: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpriority</span><span class=p>(</span><span class=n>PRIO_PROCESS</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span> <span class=nf>getpriority</span><span class=p>(</span><span class=n>PRIO_PGRP</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=nf>getpriority</span><span class=p>(</span><span class=n>PRIO_USER</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// PRIO_PROCESS: 0 PRIO_PGRP: 0 PRIO_USER: -11
</span></span></span></code></pre></div><h3 id=更改用户id><a href=#%e6%9b%b4%e6%94%b9%e7%94%a8%e6%88%b7id>更改用户ID</a></h3><p>对于文件来说，有3个相关权限，分别是所有者（owner）ID、所有组（group）ID以及其他（other）。</p><p>对运行中的进程来说，有3个相关用户/组，分别是实际用户/组（real user or group，登录用户/组），有效用户/组（effective user or group）以及设置的用户/组（set user or group）。</p><p>有一系列函数可用用来设置进程的用户/组：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setuid</span><span class=p>(</span><span class=kt>uid_t</span> <span class=n>uid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setgid</span><span class=p>(</span><span class=kt>gid_t</span> <span class=n>gid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setreuid</span><span class=p>(</span><span class=kt>uid_t</span> <span class=n>ruid</span><span class=p>,</span> <span class=kt>uid_t</span> <span class=n>euid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setregid</span><span class=p>(</span><span class=kt>gid_t</span> <span class=n>rgid</span><span class=p>,</span> <span class=kt>gid_t</span> <span class=n>egid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>seteuid</span><span class=p>(</span><span class=kt>uid_t</span> <span class=n>uid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setegid</span><span class=p>(</span><span class=kt>gid_t</span> <span class=n>gid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回0， 失败返回-1 */</span>
</span></span></code></pre></div><p>这些函数的使用场景是<strong>程序需要增加特权或访问当前并不允许访问的资源，此时需要更换自己的用户ID和组ID，使得新ID具有合适的特权或访问权限。</strong></p><p><code>setuid</code>函数用于设置调用进程的实际用户ID和有效用户ID；<code>setgid</code>函数用于设置调用进程的实际组ID和有效组ID。</p><p>不同权限调用<code>setuid</code>函数结果（<code>setgid</code>函数结果类似）如下图：
<a data-fancybox=gallery href=../%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6/setuid%e4%b8%8d%e5%90%8c%e6%9d%83%e9%99%90%e8%b0%83%e7%94%a8%e5%9b%be.png><img class=mx-auto alt src=../%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6/setuid%e4%b8%8d%e5%90%8c%e6%9d%83%e9%99%90%e8%b0%83%e7%94%a8%e5%9b%be.png></a></p><p><code>setreuid</code>和<code>setregid</code>函数分别是用来设置实际用户ID有效用户ID和实际组ID有效组ID的，权限判断和<code>setuid</code>一致。但传入参数为-1时，则对应的ID不变。</p><p><code>seteuid</code>和<code>setegid</code>函数分别是用来设置调用进程的有效用户ID和有效组ID。</p><p><strong>上述所有函数设置用户ID或组ID时都需要遵循下面3点：</strong></p><ol><li>若进程具有超级用户权限，则可以将相应的ID设置为传入的参数值。</li><li>若进程无超级用户权限，但是传入的参数等于调用进程的实际用户ID或设置用户ID时，也可以将有效用户ID设置为传入的参数。</li><li>若上面的参数都不满足，则<code>errno=EPERM</code>，并返回-1。</li></ol><p>进程设置用户ID位调用关系如下：
<a data-fancybox=gallery href=../%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/%E8%BF%9B%E7%A8%8B%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7ID%E8%B0%83%E7%94%A8%E5%9B%BE.png><img class=mx-auto alt src=../%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/%E8%BF%9B%E7%A8%8B%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7ID%E8%B0%83%E7%94%A8%E5%9B%BE.png></a></p><p>下面是进程用户设置的使用示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define _GNU_SOURCE
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>print_ids</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uid_t</span> <span class=n>ruid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uid_t</span> <span class=n>euid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uid_t</span> <span class=n>saved_uid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>getresuid</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ruid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>euid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>saved_uid</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;real uid=%d, effective uid=%d saved uid =%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ruid</span><span class=p>,</span> <span class=n>euid</span><span class=p>,</span> <span class=n>saved_uid</span><span class=p>,</span> <span class=n>saved_uid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;getresuid error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 1. 修改了进程文件的所有者和所有组为root，并设置了设置用户ID位和设置组ID位。
</span></span></span><span class=line><span class=cl><span class=cm>     *     此时进程的有效用户为root，保存的设置用户也为root. */</span>
</span></span><span class=line><span class=cl>    <span class=nf>print_ids</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 2. 降低特权，调用seteuid会将有效用户设置为实际用户，此时保存的设置用户为root */</span>
</span></span><span class=line><span class=cl>    <span class=nf>seteuid</span><span class=p>(</span><span class=nf>getuid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=nf>print_ids</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 3. 提高特权，将有效用户设置为保存的设置用户 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>setuid</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>print_ids</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 4. 创建进程以执行特定用户的命令需要降低权限· */</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 运行用户命令，降低权限 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>setuid</span><span class=p>(</span><span class=nf>getuid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=nf>print_ids</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./setuid_test
</span></span><span class=line><span class=cl>real <span class=nv>uid</span><span class=o>=</span>1000, effective <span class=nv>uid</span><span class=o>=</span><span class=m>0</span> saved <span class=nv>uid</span> <span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>real <span class=nv>uid</span><span class=o>=</span>1000, effective <span class=nv>uid</span><span class=o>=</span><span class=m>1000</span> saved <span class=nv>uid</span> <span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>real <span class=nv>uid</span><span class=o>=</span>1000, effective <span class=nv>uid</span><span class=o>=</span><span class=m>0</span> saved <span class=nv>uid</span> <span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>real <span class=nv>uid</span><span class=o>=</span>1000, effective <span class=nv>uid</span><span class=o>=</span><span class=m>1000</span> saved <span class=nv>uid</span> <span class=o>=</span><span class=m>1000</span>
</span></span></code></pre></div><p>从上述使用实例中可以看出，<strong>当前在执行特定用户命令时，可以使用<code>fork</code>创建进程，然后通过<code>setuid</code>设置为特定的实际用户ID，避免权限暴露。</strong></p><h3 id=进程时间><a href=#%e8%bf%9b%e7%a8%8b%e6%97%b6%e9%97%b4>进程时间</a></h3><p>Unix系统为一个进程维护了3个进程时间值：<strong>时钟时间</strong>、<strong>用户CPU时间</strong>以及<strong>系统CPU时间</strong>。</p><p>时钟时间指的是进程运行的时间总量，其值与系统中同时运行的进程数有关。</p><p>用户CPU时间是执行用户指令所用的是时间长度，系统CPU时间是为该进程执行内核程序所用的时间长度。</p><p>任一进程调用<code>times</code>函数都可以获取上述3个值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/times.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>clock_t</span> <span class=nf>times</span><span class=p>(</span><span class=k>struct</span> <span class=n>tms</span> <span class=o>*</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* 成功返回时钟时间长度，失败返回-1. */</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>tms</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>clock_t</span> <span class=n>tms_utime</span><span class=p>;</span> <span class=cm>/* 用户CPU时间*/</span>
</span></span><span class=line><span class=cl>    <span class=kt>clock_t</span> <span class=n>tms_stime</span><span class=p>;</span> <span class=cm>/* 系统CPU时间 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>clock_t</span> <span class=n>tms_cutime</span><span class=p>;</span> <span class=cm>/* 子进程用户CPU时间 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>clock_t</span> <span class=n>tms_cstime</span><span class=p>;</span> <span class=cm>/* 子进程系统CPU时间 */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>times</code>函数返回的值都是以过去某一时间点开始测量的时间长度值，因此欲获取运行时间，需前后两次调用，再计算相对值。</p><p>所有由<code>times</code>函数返回的<code>clock_t</code>数据都可以使用<code>_SC_CLK_TCK</code>转化为秒数。</p><p>下面的示例展示了如何获取调用进程及其子进程运行使用的时间：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/times.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>print_exit</span><span class=p>(</span><span class=kt>int</span> <span class=n>status</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>WIFEXITED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;normal termination, exit status = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WEXITSTATUS</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nf>WIFSIGNALED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 异常终止子进程的信号编号 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;abnormal termination, signal number = %d%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WTERMSIG</span><span class=p>(</span><span class=n>status</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 是否已经产生core文件 */</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef WCOREDUMP
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=nf>WCOREDUMP</span><span class=p>(</span><span class=n>status</span><span class=p>)</span> <span class=o>?</span> <span class=s>&#34;(core file generated)&#34;</span> <span class=o>:</span> <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nf>WIFSTOPPED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 当前暂停子进程的信号编号 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child stopped, signal number = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WSTOPSIG</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>print_times</span><span class=p>(</span><span class=kt>clock_t</span> <span class=n>real</span><span class=p>,</span> <span class=k>struct</span> <span class=n>tms</span><span class=o>*</span> <span class=n>tmsstart</span><span class=p>,</span> <span class=k>struct</span> <span class=n>tms</span><span class=o>*</span> <span class=n>tmsend</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>clktck</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>clktck</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>clktck</span> <span class=o>=</span> <span class=nf>sysconf</span><span class=p>(</span><span class=n>_SC_CLK_TCK</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sysconf error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; real: %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>real</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; user: %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>tmsend</span><span class=o>-&gt;</span><span class=n>tms_utime</span> <span class=o>-</span> <span class=n>tmsstart</span><span class=o>-&gt;</span><span class=n>tms_utime</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; system: %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>tmsend</span><span class=o>-&gt;</span><span class=n>tms_stime</span> <span class=o>-</span> <span class=n>tmsstart</span><span class=o>-&gt;</span><span class=n>tms_stime</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; child user: %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>tmsend</span><span class=o>-&gt;</span><span class=n>tms_cutime</span> <span class=o>-</span> <span class=n>tmsstart</span><span class=o>-&gt;</span><span class=n>tms_cutime</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; child system: %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>tmsend</span><span class=o>-&gt;</span><span class=n>tms_cstime</span> <span class=o>-</span> <span class=n>tmsstart</span><span class=o>-&gt;</span><span class=n>tms_cstime</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>do_cmd</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>cmd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>tms</span> <span class=n>tmsstart</span><span class=p>,</span> <span class=n>tmsend</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>clock_t</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>command: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>cmd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>start</span> <span class=o>=</span> <span class=nf>times</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmsstart</span><span class=p>))</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;times error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>status</span> <span class=o>=</span> <span class=nf>system</span><span class=p>(</span><span class=n>cmd</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;system error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>end</span> <span class=o>=</span> <span class=nf>times</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmsend</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;system error: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>print_times</span><span class=p>(</span><span class=n>end</span> <span class=o>-</span> <span class=n>start</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tmsstart</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tmsend</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>print_exit</span><span class=p>(</span><span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>setbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>argc</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>do_cmd</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>运行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./process_clock <span class=s2>&#34;sleep 5&#34;</span> <span class=s2>&#34;date&#34;</span> <span class=s2>&#34;man bash &gt; /dev/null&#34;</span>
</span></span><span class=line><span class=cl>command: sleep <span class=m>5</span>
</span></span><span class=line><span class=cl> real:    5.01
</span></span><span class=line><span class=cl> user:    0.00
</span></span><span class=line><span class=cl> system:    0.00
</span></span><span class=line><span class=cl> child user:    0.00
</span></span><span class=line><span class=cl> child system:    0.00
</span></span><span class=line><span class=cl>normal termination, <span class=nb>exit</span> <span class=nv>status</span> <span class=o>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>command: date
</span></span><span class=line><span class=cl>2022年 07月 22日 星期五 00:23:12 JST
</span></span><span class=line><span class=cl> real:    0.00
</span></span><span class=line><span class=cl> user:    0.00
</span></span><span class=line><span class=cl> system:    0.00
</span></span><span class=line><span class=cl> child user:    0.00
</span></span><span class=line><span class=cl> child system:    0.00
</span></span><span class=line><span class=cl>normal termination, <span class=nb>exit</span> <span class=nv>status</span> <span class=o>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>command: man bash&gt; /dev/null
</span></span><span class=line><span class=cl> real:    0.14
</span></span><span class=line><span class=cl> user:    0.00
</span></span><span class=line><span class=cl> system:    0.00
</span></span><span class=line><span class=cl> child user:    0.13
</span></span><span class=line><span class=cl> child system:    0.09
</span></span><span class=line><span class=cl>normal termination, <span class=nb>exit</span> <span class=nv>status</span> <span class=o>=</span> <span class=m>0</span>
</span></span></code></pre></div><h2 id=进程会计><a href=#%e8%bf%9b%e7%a8%8b%e4%bc%9a%e8%ae%a1>进程会计</a></h2></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://DBL2017.github.io/>生如夏花</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br><div class=post-archive><h2>See Also</h2><ul class=listing><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/>进程环境</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/>系统数据文件和信息</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%A0%87%E5%87%86io/>标准IO</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6io/>文件IO</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/>文件和目录</a></li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a href=/tags/apue>APUE</a></li><li><a href=/tags/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B>Unix环境高级编程</a></li><li><a href=/tags/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6>进程控制</a></li></ul></div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=DBL2017/DBL2017.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div></div></div><div class=content-right><div class=sidebar><section class=widget><form id=form-search action=https://DBL2017.github.io/search/ method=get accept-charset=utf-8 _lpchecked=1><input type=text name=q maxlength=20 placeholder=请输入查找关键字 required>
<button type=submit class=submit title=提交><svg t="1714448321870" class="icon" style="width:22px;height:22px" viewBox="0 0 1024 1024" p-id="1771" width="200" height="200"><path d="M781.9264 691.1232l236.928 236.9216-90.816 90.8032-236.9152-236.9216c-72.032 53.3568-161.184 84.9088-257.7088 84.9088C194.048 866.8352.0 672.7872.0 433.408.0 194.048 194.048.0 433.4144.0c239.3728.0 433.4208 194.048 433.4208 433.4144.0 96.5248-31.552 185.6768-84.9088 257.7088zm-348.512 47.2896c168.448.0 304.9984-136.5504 304.9984-304.9984s-136.5504-304.992-304.9984-304.992-304.992 136.5504-304.992 304.9856c0 168.448 136.5504 304.9984 304.992 304.9984z" fill="#4a4a4a" p-id="1772"/></svg></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/tmux%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/ title=tmux使用方法>tmux使用方法</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/ title=iptables自定义链>iptables自定义链</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ubuntu24.04-apt-upgrade%E6%8F%90%E7%A4%BAesm-apps/ title="Ubuntu24.04 apt upgrade提示esm-apps">Ubuntu24.04 apt upgrade提示esm-apps</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/ubuntu24.04%E6%90%AD%E5%BB%BApppoe-server%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%8B%A8%E5%8F%B7%E6%B5%8B%E8%AF%95/ title="Ubuntu24.04搭建PPPoE Server并进行拨号测试">Ubuntu24.04搭建PPPoE Server并进行拨号测试</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/openwrt%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E5%9C%A8vmware%E4%B8%8A%E8%BF%90%E8%A1%8C/ title=OpenWrt下载编译以及在VMWare上运行>OpenWrt下载编译以及在VMWare上运行</a></li><li><a href=https://DBL2017.github.io/post/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/ubuntu24.04%E7%8E%AF%E5%A2%83%E7%BC%96%E8%AF%91glibc-2.40%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/ title=Ubuntu24.04环境编译glibc-2.40错误记录>Ubuntu24.04环境编译glibc-2.40错误记录</a></li><li><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/ title=UNIX域套接字>UNIX域套接字</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/job-systemd-networkd-wait-online.service-start-running/ title="Job systemd-networkd-wait-online.service start running">Job systemd-networkd-wait-online.service start running</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/fdisk%E5%88%9B%E5%BB%BA%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96/ title=fdisk创建磁盘分区并格式化>fdisk创建磁盘分区并格式化</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/vmware%E8%99%9A%E6%8B%9F%E6%9C%BAubuntu24.04%E6%A1%A5%E6%8E%A5%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E4%B8%8A%E7%BD%91/ title=VMware虚拟机Ubuntu24.04桥接到宿主机无线网卡上网>VMware虚拟机Ubuntu24.04桥接到宿主机无线网卡上网</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=https://DBL2017.github.io/categories/kindle/>KINDLE (1)</a></li><li><a href=https://DBL2017.github.io/categories/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/>传输协议 (11)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/>工具使用 (20)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/>开源三方 (2)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统 (6)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/>数字安全 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/>数据结构和算法 (5)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言 (6)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/>网络工程师 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记 (56)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/>问题排查 (2)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%BB%98%E8%AE%A4/>默认 (2)</a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://mermaid.live/ title=Mermaid>Mermaid 编辑</a></li><li><a target=_blank href=https://excalidraw.com/ title=EXCALIDRAW>Excalidraw 绘图</a></li><li><a target=_blank href=https://git-scm.com/docs title=Git命令参考手册>Git命令参考手册</a></li><li><a target=_blank href=https://www.gnu.org/software/make/manual/make.html title="GNU make官方文档">GNU make官方文档</a></li><li><a target=_blank href=https://www.emojiall.com/ title=Emojiall表情网站>Emojiall表情网站</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/index.xml>文章 RSS</a></li></ul></section></div></div></div><div class=container-footer><footer id=footer><div>&copy; 2024 <a href=https://DBL2017.github.io/>生如夏花的博客 By
生如夏花</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>广电总局</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered
by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://DBL2017.github.io/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">生如夏花的博客</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"]}}</script><script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=/js/jquery.fancybox.min.min.9040007c0fd2a6cdc356495acb1c45ba3328b261b0d9f75d3da19bc47229189108aab8ca043864c1801d59431de72dec8d51ae50539f9ce1f5964bf5f38786c3.js integrity="sha512-kEAAfA/Sps3DVklayxxFujMosmGw2fddPaGbxHIpGJEIqrjKBDhkwYAdWUMd5y3sjVGuUFOfnOH1lkv184eGww==" crossorigin=anonymous></script><a id=rocket href=#top></a><script src=/js/totop.min.8c7573186baa30f09c49b5cf3176c3b105785324d961b3d5c2f7f099d14673160a29aeebdec25909d046aa14936cd43451e17664662d518550d5e8998dbec670.js integrity="sha512-jHVzGGuqMPCcSbXPMXbDsQV4UyTZYbPVwvfwmdFGcxYKKa7r3sJZCdBGqhSTbNQ0UeF2ZGYtUYVQ1eiZjb7GcA==" crossorigin=anonymous></script><script src=/js/clipboard.min.0765794be1674926c1a3810afcf039f605f367cb11cef727ad49e6aa70f9fca0a37d329d64c55822896869eb0960763e73e085ee7675cbc497e4d3256a6e6a67.js integrity="sha512-B2V5S+FnSSbBo4EK/PA59gXzZ8sRzvcnrUnmqnD5/KCjfTKdZMVYIoloaesJYHY+c+CF7nZ1y8SX5NMlam5qZw==" crossorigin=anonymous></script><script>var spy=new Gumshoe("#TableOfContents a",{nested:!0,nestedClass:"active"})</script><script>hljs.highlightAll()</script></div></div></body></html>