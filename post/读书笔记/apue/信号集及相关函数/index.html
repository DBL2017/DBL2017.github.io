<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>信号集及相关函数 | 生如夏花</title>
<meta property="og:title" content="信号集及相关函数 - 生如夏花"><meta property="og:type" content="article"><meta property="article:published_time" content='2024-01-16T23:18:13+08:00'><meta property="article:modified_time" content='2024-01-16T23:18:13+08:00'><meta name=Keywords content="C语言,Linux系统开发,物联网,博客,项目管理,软件架构"><meta name=description content="信号集及相关函数"><meta name=author content><meta property="og:url" content="https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai.min.css integrity="sha512-RLF8eOxhuwsRINc7r56dpl9a3VStqrXD+udWahutJrYdyh++2Ghnf+s4jFsOyryKZt/GNjPwbXVPH3MJpKrn2g==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/badge.min.dc57f0a9d275742b1e2d17f204ae0b829361b5dd0df99d3d356615830fb223936c054d31a888c5f369975da90586601e2666ddbbbb36e98510b814a70826e874.css integrity="sha512-3FfwqdJ1dCseLRfyBK4LgpNhtd0N+Z09NWYVgw+yI5NsBU0xqIjF82mXXakFhmAeJmbdu7s26YUQuBSnCCbodA==" crossorigin=anonymous><link rel=stylesheet href=/css/header.min.9e74ad2f7e23fb54e2da3ef2f1eb6498897cd4139d181133b5e641f107980364ccfbcea731badb693b4a50819c388b6f8cab037346daf142114f86f14faa8766.css integrity="sha512-nnStL34j+1Ti2j7y8etkmIl81BOdGBEzteZB8QeYA2TM+86nMbrbaTtKUIGcOItvjKsDc0ba8UIRT4bxT6qHZg==" crossorigin=anonymous><link rel=stylesheet href=/css/table.min.032852d8d049c55be5cd0a27bf8c7b09c8ea549fb719c2fd0231ebd262fdddb5aaaf391dabeb89ce33bcbe49f13ee8a530822a26f76b675af23473ed07b95d2e.css integrity="sha512-AyhS2NBJxVvlzQonv4x7CcjqVJ+3GcL9AjHr0mL93bWqrzkdq+uJzjO8vknxPuilMIIqJvdrZ1ryNHPtB7ldLg==" crossorigin=anonymous><link rel=stylesheet href=/css/baseof.min.5e04a6c8338c3c57aedaaae91320971e148651ac160d51bb58ebfec7757346a177331ac5646bbb1b2664b1c8cc405939125785c138935bc0d29a805b11791691.css integrity="sha512-XgSmyDOMPFeu2qrpEyCXHhSGUawWDVG7WOv+x3VzRqF3MxrFZGu7GyZkscjMQFk5EleFwTiTW8DSmoBbEXkWkQ==" crossorigin=anonymous><link rel=stylesheet href=/css/rocket.min.96a6be31cd3df9dcd4e7e131e9fcb0e63149da1da6a23df5ed8c8e0ccf0436f4c95aad5ded6a69e7fba5c051f8cc00466fcedaa07e4c7f59492d4a15aba2e936.css integrity="sha512-lqa+Mc09+dzU5+Ex6fyw5jFJ2h2moj317YyODM8ENvTJWq1d7Wpp5/ulwFH4zABGb87aoH5Mf1lJLUoVq6LpNg==" crossorigin=anonymous><link rel=stylesheet href=/css/toc.min.6d85af7b55a06a3c1672914851ad8f64e3e4de3a81435cc45b05f1b71fb4bde6d0f00597b4f316d214809e3597a66516d7651772c9da8d8e42bf188fb3df5a85.css integrity="sha512-bYWve1WgajwWcpFIUa2PZOPk3jqBQ1zEWwXxtx+0vebQ8AWXtPMW0hSAnjWXpmUW12UXcsnajY5CvxiPs99ahQ==" crossorigin=anonymous><link rel=stylesheet href=/css/clipboard.min.5e6a0198e50c850ced7dc2ba6f282ecaab21a8daad9eee626b990120818361b4b0007128d73957d5682346c88a6f9831f5872051e5f12da830cc29ca75676403.css integrity="sha512-XmoBmOUMhQztfcK6byguyqshqNqtnu5ia5kBIIGDYbSwAHEo1zlX1WgjRsiKb5gx9YcgUeXxLagwzCnKdWdkAw==" crossorigin=anonymous><link rel=stylesheet href=/css/style.min.0ee927227dc0f181f293a851db44642879c59ab0e5e6dfaae42f3402d8e06810cb2c8fe30201142d9f8205e46f706cf646ccba5e8ee7695327d888861ddaf10d.css integrity="sha512-DuknIn3A8YHyk6hR20RkKHnFmrDl5t+q5C80AtjgaBDLLI/jAgEULZ+CBeRvcGz2Rsy6Xo7naVMn2IiGHdrxDQ==" crossorigin=anonymous><link rel="shortcut icon" href=/img/favicon.png type=image/x-icon><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vim.min.js></script><script src=/js/gumshoe.min.min.9dec1df0371d73b03324ed4bb78a6d5b2e84af6a37b11ce799808a26d70dfd156595f8d23c42db9e4866f12b4c0de664cfd032fa6f95bdaaada1bacdb235e79e.js integrity="sha512-newd8Dcdc7AzJO1Lt4ptWy6Er2o3sRznmYCKJtcN/RVllfjSPELbnkhm8StMDeZkz9Ay+m+VvaqtobrNsjXnng==" crossorigin=anonymous></script></head><body><div class=container><div class=container-header><header><div class=header-main><div class=header-site-name><a id=header-title href=https://DBL2017.github.io/>生如夏花</a><p class=description>专注于工业物联网行业数据采集，嵌入式Linux系统裁剪，5G智慧网关软件开发等</p></div><div class=header-menu><nav id=header-nav-menu><a href=https://DBL2017.github.io/>首页</a>
<a href=https://DBL2017.github.io/series/ title=系列>系列</a>
<a href=https://DBL2017.github.io/categories/ title=分类>分类</a>
<a href=https://DBL2017.github.io/tags/ title=标签>标签</a>
<a href=https://DBL2017.github.io/archives/ title=归档>归档</a>
<a href=https://DBL2017.github.io/about/ title=关于>关于</a></nav></div></div></header></div><div class=container-content><div class=content-center><div class=main-single><div class=single-toc><div class=post-toc><h2 class=post-toc-title><a href=#>目录</a></h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#信号集的操作函数>信号集的操作函数</a></li><li><a href=#信号集的应用函数>信号集的应用函数</a><ul><li><a href=#sigpromask函数><code>sigpromask</code>函数</a><ul><li><a href=#示例>示例</a></li></ul></li><li><a href=#sigpending函数><code>sigpending</code>函数</a></li><li><a href=#sigaction函数><code>sigaction</code>函数</a><ul><li><a href=#sa_sigaction函数说明>sa_sigaction函数说明</a></li><li><a href=#示例-1>示例</a></li></ul></li><li><a href=#sigsetjmp与siglongjmp函数>sigsetjmp与siglongjmp函数</a><ul><li><a href=#示例-2>示例</a></li></ul></li><li><a href=#sigsuspend函数><code>sigsuspend</code>函数</a><ul><li><a href=#示例-3>示例</a></li></ul></li><li><a href=#sigqueue函数><code>sigqueue</code>函数</a></li></ul></li></ul></nav></div></div></div><div class=single-article><article class=post><header><h1 class=post-title>信号集及相关函数</h1></header><date class="post-meta meta-date"><span class=meta-category><a href=/archives/#2024>2024年1月16日</a></span></date><div class=post-meta><span>|</span>
<span class=meta-category><a href=/categories/#%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0>读书笔记</a></span></div><div class=post-meta><span>|</span>
<span class=meta-category><a href=/series/#APUE>APUE</a></span></div><div class=post-meta><span>|</span>
<span>共8032字</span></div><div class=post-meta><span>|</span>
<span>阅读时长(17分钟)</span></div><div class=clear style=display:none><div class=toc-article><div class=toc-title>文章目录</div></div></div><div class=post-content><p><strong>信号集</strong>（<code>sigset_t</code>）是表示多个信号的数据类型。</p><p>不同的信号编号可能会超过一个整型量的位数，所以不能用整型量中的一位代表一个信号。</p><p>POSIX.1定义数据类型<code>sigset_t</code>用以表示信号集，并定义了信号的操作函数。</p><h2 id=信号集的操作函数><a href=#%e4%bf%a1%e5%8f%b7%e9%9b%86%e7%9a%84%e6%93%8d%e4%bd%9c%e5%87%bd%e6%95%b0>信号集的操作函数</a></h2><p>下面的函数可以用来对信号集初始化、增删、检测等：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sigemptyset</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sigfillset</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sigaddset</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signum</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sigdelset</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signum</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 上面四个函数，成功返回0；出错返回-1
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sigismember</span><span class=p>(</span><span class=k>const</span> <span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signum</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// signum信号存在返回1，不存在返回0
</span></span></span></code></pre></div><p><code>sigemptyset</code>函数初始化<code>set</code>指向的信号集，清除其中所有信号。</p><p><code>sigfillset</code>函数也初始化<code>set</code>指向的信号集，使其包含所有信号。</p><p><code>sigaddset</code>函数将<code>signum</code>指定的信号添加到信号集<code>set</code>中。</p><p><code>sigdelset</code>函数从信号集<code>set</code>中删除<code>signum</code>指定的信号。</p><p><code>sigismember</code>函数<code>signum</code>指定的信号是否在信号集<code>set</code>中。</p><h2 id=信号集的应用函数><a href=#%e4%bf%a1%e5%8f%b7%e9%9b%86%e7%9a%84%e5%ba%94%e7%94%a8%e5%87%bd%e6%95%b0>信号集的应用函数</a></h2><h3 id=sigpromask函数><a href=#sigpromask%e5%87%bd%e6%95%b0><code>sigpromask</code>函数</a></h3><p>调用<code>sigpromask</code>函数可以检测或更改进程的信号屏蔽字。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl> <span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>sigprocmask</span><span class=p>(</span><span class=kt>int</span> <span class=n>how</span><span class=p>,</span> <span class=k>const</span> <span class=kt>sigset_t</span> <span class=o>*</span> <span class=kr>restrict</span> <span class=n>set</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                          <span class=kt>sigset_t</span> <span class=o>*</span> <span class=kr>restrict</span> <span class=n>oldset</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：成功返回0， 失败返回-1
</span></span></span></code></pre></div><p>无论其他参数取何值，<code>oldset</code>参数均用于返回进程的当前信号屏蔽字。</p><p>如果<code>set</code>是空指针，则不改变该进程的信号屏蔽字，<code>how</code>参数也无意义。</p><p>如果<code>set</code>非空，则根据<code>how</code>参数来决定如何修改当前信号屏蔽字。</p><p><code>how</code>参数取值如下：</p><table><thead><tr><th><strong>how</strong></th><th>说明</th></tr></thead><tbody><tr><td><code>SIG_BLOCK</code></td><td>其当前信号屏蔽字与<code>set</code>指向的信号屏蔽字并集产生该进程新的信号屏蔽字。<code>set</code>中包含了需要阻塞的新信号。</td></tr><tr><td><code>SIG_UNBLOCK</code></td><td>该进程新的信号屏蔽字是其当前信号屏蔽字与<code>set</code>所指向信号屏蔽字的交集。<code>set</code>中包含了需要解除阻塞的信号。</td></tr><tr><td><code>SIG_SETMASK</code></td><td>该进程新的信号屏蔽字是<code>set</code>所指向的值。</td></tr></tbody></table><p><strong>在调用<code>sigprocmask</code>后如果有未决的、不在阻塞的信号，则在该函数返回前，就会至少将其中之一递送给该进程</strong>。这说明<code>sigprocmask</code>函数可能会被信号处理函数中断。</p><h4 id=示例><a href=#%e7%a4%ba%e4%be%8b>示例</a></h4><p>下面的示例会调用<code>sigprocmask</code>函数检测进程当前信号屏蔽字中的信号并打印。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;error.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>pr_mask</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sigset_t</span> <span class=n>sigset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>errno_save</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>errno_save</span> <span class=o>=</span> <span class=n>errno</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigprocmask</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sigset</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigprocmask&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sigismember</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sigset</span><span class=p>,</span> <span class=n>SIGINT</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; SIGINT&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sigismember</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sigset</span><span class=p>,</span> <span class=n>SIGQUIT</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; SIGQUIT&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sigismember</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sigset</span><span class=p>,</span> <span class=n>SIGUSR1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; SIGUSR1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sigismember</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sigset</span><span class=p>,</span> <span class=n>SIGALRM</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; SIGALRM&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sigismember</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sigset</span><span class=p>,</span> <span class=n>SIGTSTP</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; SIGTSTP&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>errno</span> <span class=o>=</span> <span class=n>errno_save</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sigset_t</span> <span class=n>newsig_set</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newsig_set</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigaddset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newsig_set</span><span class=p>,</span> <span class=n>SIGALRM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 阻塞SIGALRM信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;block signal SIGALRM</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigprocmask</span><span class=p>(</span><span class=n>SIG_BLOCK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newsig_set</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigprocmask&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>pr_mask</span><span class=p>(</span><span class=s>&#34;current sig mask:&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 取消阻塞SIGALRM信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;unblcok signal SIGALRM</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigprocmask</span><span class=p>(</span><span class=n>SIG_UNBLOCK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newsig_set</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigprocmask&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>pr_mask</span><span class=p>(</span><span class=s>&#34;current sig mask:&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// $ ./pr_mask
</span></span></span><span class=line><span class=cl><span class=c1>// block signal SIGALRM
</span></span></span><span class=line><span class=cl><span class=c1>// current sig mask: SIGALRM
</span></span></span><span class=line><span class=cl><span class=c1>// unblcok signal SIGALRM
</span></span></span><span class=line><span class=cl><span class=c1>// current sig mask:
</span></span></span></code></pre></div><p>在这个例子中，先是在信号屏蔽字中增加了<code>SIGALRM</code>信号，随后又删除了<code>SIGALRM</code>信号。</p><p>使用这种技术，也可以<strong>保护不希望由信号中断的代码临界区</strong>。</p><p>下面的示例展示了如何使用<code>sigprocmaks</code>函数来创建一个不被信号中断的代码临界区：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>volatile</span> <span class=kt>sig_atomic_t</span> <span class=n>flag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>signal_handler</span><span class=p>(</span><span class=kt>int</span> <span class=n>signum</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>flag</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sigaction</span> <span class=n>sa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>sa</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>signal_handler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sa</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sa</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sa</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigaction&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 进入临界区前屏蔽SIGINT信号
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>sigset_t</span> <span class=n>mask</span><span class=p>,</span> <span class=n>prev_mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>sigaddset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mask</span><span class=p>,</span> <span class=n>SIGINT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>sigprocmask</span><span class=p>(</span><span class=n>SIG_BLOCK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mask</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>prev_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 在临界区内执行一些操作
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;进入临界区</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>  <span class=c1>// 模拟一些耗时操作
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;离开临界区</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 恢复信号屏蔽集合
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sigprocmask</span><span class=p>(</span><span class=n>SIG_SETMASK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>prev_mask</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 检查是否收到SIGINT信号，如果是则退出循环
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>flag</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;收到SIGINT信号，退出循环</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=sigpending函数><a href=#sigpending%e5%87%bd%e6%95%b0><code>sigpending</code>函数</a></h3><p><code>sigpending</code>函数返回当前进程阻塞不能递送的信号集，其中的信号都是未决的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>sigpending</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 成功返回0， 失败返回-1
</span></span></span></code></pre></div><p>下面的例子展示了<code>sigpending</code>函数的用法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_quit</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sigset_t</span> <span class=n>newmask</span><span class=p>,</span> <span class=n>oldmask</span><span class=p>,</span> <span class=n>pendmask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 捕捉退出信号，终端按键Ctrl+\;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGQUIT</span><span class=p>,</span> <span class=n>sig_quit</span><span class=p>)</span> <span class=o>==</span> <span class=n>SIG_ERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;signal&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 阻塞SIGQUIT，并保存信号屏蔽字在oldmask中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newmask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigaddset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newmask</span><span class=p>,</span> <span class=n>SIGQUIT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigprocmask</span><span class=p>(</span><span class=n>SIG_BLOCK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newmask</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldmask</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigprocmask&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 休眠5s，此时产生的SIGQUIT会被阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 检测SIGQUIT是否正在阻塞中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigpending</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pendmask</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigpending&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigismember</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pendmask</span><span class=p>,</span> <span class=n>SIGQUIT</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>SIGQUIT pending</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 恢复之前的信号屏蔽字，即解除SIGQUIT阻塞，之前的信号屏蔽字保存在oldmask中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 这里不适用SIG_UNBLOCK的原因是在执行这段代码之前，SIGQUIT也有可能是阻塞，所以这里不能直接解除阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigprocmask</span><span class=p>(</span><span class=n>SIG_SETMASK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldmask</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigprocmask&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果已经SIGQUIT信号是未决的，则在sigprocmask返回之前就会被递送，继而执行信号处理函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 因此sig_quit函数执行在printf之前
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;SIGQUIT unblocked</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 此时在产生SIG_QUIT就会退出进程，因为sig_quit函数中将信号处理程序设置为默认
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_quit</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Caught SIGQUIT</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGQUIT</span><span class=p>,</span> <span class=n>SIG_DFL</span><span class=p>)</span> <span class=o>==</span> <span class=n>SIG_ERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;signal&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./sigpend
</span></span><span class=line><span class=cl>^<span class=se>\ </span><span class=c1># 产生一次SIGQUIT信号，在第一次sleep(5)之间</span>
</span></span><span class=line><span class=cl>SIGQUIT pending <span class=c1># 从sleep返回后使用sigpending函数检测到该信号阻塞</span>
</span></span><span class=line><span class=cl>Caught SIGQUIT <span class=c1># 解除阻塞后，sigprocmask返回之前先递送阻塞的信号给进程，执行信号处理程序</span>
</span></span><span class=line><span class=cl>SIGQUIT unblocked
</span></span><span class=line><span class=cl>^<span class=se>\Q</span>uit <span class=o>(</span>core dumped<span class=o>)</span> <span class=c1># 信号处理程序重置为默认时，信号会使进程直接退出</span>
</span></span><span class=line><span class=cl>$ ./sigpend
</span></span><span class=line><span class=cl>^<span class=se>\^\^\^\^\^\^\^\^\^\^\
</span></span></span><span class=line><span class=cl><span class=se></span>SIGQUIT pending
</span></span><span class=line><span class=cl>Caught SIGQUIT <span class=c1># 信号处理程序仅执行一次，可见系统没有将SIGQUIT信号进行排队，并仅传递一次</span>
</span></span><span class=line><span class=cl>SIGQUIT unblocked
</span></span><span class=line><span class=cl>^<span class=se>\Q</span>uit <span class=o>(</span>core dumped<span class=o>)</span>
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><h3 id=sigaction函数><a href=#sigaction%e5%87%bd%e6%95%b0><code>sigaction</code>函数</a></h3><p><code>sigaction</code>函数用于检查或修改与指定信号相关的处理动作。与之前的<code>signal</code>函数功能相同，但更加强大。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sigaction</span><span class=p>(</span><span class=kt>int</span> <span class=n>signum</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=k>const</span> <span class=k>struct</span> <span class=n>sigaction</span> <span class=o>*</span> <span class=kr>restrict</span> <span class=n>act</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=k>struct</span> <span class=n>sigaction</span> <span class=o>*</span> <span class=kr>restrict</span> <span class=n>oldact</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：成功返回0，失败返回-1
</span></span></span></code></pre></div><p><code>signum</code>参数指定要检测或修改的信号编号。</p><p>如果<code>act</code>参数非空，则修改<code>signum</code>指定的信号的处理动作。</p><p>如果<code>oldact</code>参数非空，则用于返回<code>signum</code>指定的信号的之前的处理动作。</p><p><code>sigaction</code>结构体说明：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sigaction</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 信号处理函数地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>sa_handler</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果sa_flags取值为SA_SIGINFO，则用sa_sigaction函数代替sa_handler
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>sa_sigaction</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>siginfo_t</span><span class=o>*</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 在执行信号处理函数期间，被阻塞信号的屏蔽字
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>sigset_t</span> <span class=n>sa_mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 信号的处理行为标志
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>sa_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>当修改信号处理动作时，如果<code>sa_handler</code>为信号捕捉函数地址而非<code>SIG_DFL</code>或<code>SIG_IGN</code>，并且<code>sa_mask</code>指定了一个信号集，则在调用<code>sa_handler</code>指定的信号处理函数之前，会将<code>sa_mask</code>指定的信号集加入到进程的信号屏蔽字中，直到该信号处理函数执行结束再恢复为原先值。</p><p><strong>在信号处理程序被调用执行期间，操作系统建立的新信号屏蔽字包括当前正在被递送的信号</strong>。即使该信号没有被<code>sa_mask</code>参数指定的信号集包含。</p><p>一旦对给定的信号设置了一个动作，那么在调用<code>sigaction</code>显式改变其之前，该设置就一直有效。</p><p><code>sa_flags</code>参数指定对信号进行处理的各个选项，说明如下：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>SA_NOCLDSTOP</code></td><td>如果信号是<code>SIGCHLD</code>，则子进程停止或继续时不产生<code>SIGCHLD</code>信号，子进程终止时会产生。</td></tr><tr><td><code>SA_NOCLDWAIT</code></td><td><strong>如果信号是<code>SIGCHLD</code>，则调用进程的子进程终止时不创建僵死进程</strong>。并且POSIX.1未定义是否会产生<code>SIGCHLD</code>信号，Linux下会产生。同时如果在调用进程中调用<code>wait</code>或<code>waitpid</code>，则会一直阻塞到其所有子进程都终止，然后返回-1，并且设置<code>errno</code>为<code>ECHLD</code>。</td></tr><tr><td><code>SA_NODEFER</code></td><td>在信号处理程序执行期间，不将当前信号添加到进程的信号掩码中（除非在<code>sa_mask</code>中显式包含）。这样可以允许同一信号在处理程序执行期间再次被触发。</td></tr><tr><td><code>SA_RESETHAND</code></td><td>在此信号捕捉函数入口处，将此信号的处理方式重置为<code>SIG_DFL</code>，并清除<code>SA_SIGINFO</code>标志。</td></tr><tr><td><code>SA_RESTART</code></td><td>由此信号中断的系统调用自动重启动。</td></tr><tr><td><code>SA_SIGINFO</code></td><td><strong>指定使用<code>sa_sigaction</code>字段中带有附加信息的信号处理程序</strong>。如果未设置，则使用<code>sa_handler</code>指定的信号从处理程序。</td></tr></tbody></table><p>如果<code>sa_flags</code>参数使用了<code>SA_SIGINFO</code>标志，则使用<code>sa_sigaction</code>指向的信号处理程序。</p><h4 id=sa_sigaction函数说明><a href=#sa_sigaction%e5%87%bd%e6%95%b0%e8%af%b4%e6%98%8e>sa_sigaction函数说明</a></h4><p><code>sa_sigaction</code>指向的信号处理程序原型如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handler</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>,</span> <span class=kt>siginfo_t</span><span class=o>*</span> <span class=n>info</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>context</span><span class=p>);</span>
</span></span></code></pre></div><p><code>siginfo_t</code>结构包含了信号产生原因的相关信息, POSIX.1规定实现至少包括<code>si_signo</code>与<code>si_code</code>字段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=kt>siginfo_t</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>si_signo</span><span class=p>;</span>           <span class=c1>// 信号编号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>si_errno</span><span class=p>;</span>           <span class=c1>// 如果非0，则等同于errno
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>si_code</span><span class=p>;</span>            <span class=c1>// 信号码，指示发送信号的原因
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>pid_t</span> <span class=n>si_pid</span><span class=p>;</span>           <span class=c1>// 发送信号的进程ID，适用于SIGCHLD或kill
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uid_t</span> <span class=n>si_uid</span><span class=p>;</span>           <span class=c1>// 发送信号的进程的实际用户ID，条件同上
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>si_status</span><span class=p>;</span>          <span class=c1>// 发送信号的进程的退出状态，适用于SIGCHLD
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>clock_t</span> <span class=n>si_utime</span><span class=p>;</span>       <span class=c1>// 发送信号的进程使用的用户时间，适用于SIGCHLD
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>clock_t</span> <span class=n>si_stime</span><span class=p>;</span>       <span class=c1>// 发送信号的进程使用的系统时间，适用于SIGCHLD
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span><span class=o>*</span> <span class=n>si_addr</span><span class=p>;</span>          <span class=c1>// 造成SIGBUS、SIGILL、SIGFPE、SIGSEGV等信号的错误地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>union</span> <span class=n>sigval</span> <span class=n>si_value</span><span class=p>;</span>  <span class=c1>// 自定义值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=n>sigval</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sival_int</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span><span class=o>*</span> <span class=n>sigval_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>应用程序在使用<code>sigqueue</code>函数递送信号时，可以使用<code>sigval</code>联合向信号处理程序传递整数或者指针。</p><p><code>si_code</code>参数对于特定信号用于指示其的产生原因，取值如下：</p><p><a data-fancybox=gallery href=../%e4%bf%a1%e5%8f%b7%e9%9b%86%e5%8f%8a%e7%9b%b8%e5%85%b3%e5%87%bd%e6%95%b0/si_code%e5%8f%96%e5%80%bc%e8%af%b4%e6%98%8e.jpg><img class=mx-auto alt src=../%e4%bf%a1%e5%8f%b7%e9%9b%86%e5%8f%8a%e7%9b%b8%e5%85%b3%e5%87%bd%e6%95%b0/si_code%e5%8f%96%e5%80%bc%e8%af%b4%e6%98%8e.jpg></a></p><p><code>context</code>参数可以被强制转换为<code>ucontext_t</code>结构类型，表示<strong>信号传递时进程的上下文</strong>，可以使用<code>man 3 getcontext</code>查看详细内容。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=kt>ucontext_t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=kt>ucontext_t</span> <span class=o>*</span><span class=n>uc_link</span><span class=p>;</span>   <span class=c1>// 保存当前上下文切换后的下一个上下文，当前上下文执行完毕后会切换到uc_link指向的上下文环境
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>sigset_t</span> <span class=n>uc_sigmask</span><span class=p>;</span>          <span class=c1>// 保存当前上下文中的信号屏蔽字，切换到当前上下文时会设置该信号屏蔽字
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 保存当前上下文的栈信息，栈的起始地址和大小等信息。切换到当前上下文时，会将uc_stack中的栈信息设置到当前线程中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>stack_t</span> <span class=n>uc_stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 保存当前上下文的机器相关的寄存器状态，程序计数器(PC)、栈指针(SP)、通用寄存器等的值。切换到当前上下文时，会将uc_mcontext中的寄存器状态设置到当前线程中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>mcontext_t</span> <span class=n>uc_mcontext</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>ucontext_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span><span class=o>*</span> <span class=n>ss_sp</span><span class=p>;</span>    <span class=c1>// 栈的起始地址指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>size_t</span> <span class=n>ss_size</span><span class=p>;</span> <span class=c1>// 栈的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>ss_flags</span><span class=p>;</span>   <span class=c1>// 栈的标志位
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=kt>stack_t</span><span class=p>;</span>
</span></span></code></pre></div><h4 id=示例-1><a href=#%e7%a4%ba%e4%be%8b-1>示例</a></h4><p>下面的示例使用<code>sigaction</code>函数来实现<code>signal</code>函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=n>SigFunc</span><span class=p>)(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 返回之前的信号处理函数，使用新的信号处理函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SigFunc</span> <span class=nf>mysignal</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>,</span> <span class=n>SigFunc</span> <span class=n>func</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sigaction</span> <span class=n>act</span><span class=p>,</span> <span class=n>oact</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>act</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>func</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>act</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>act</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>==</span> <span class=n>SIGALRM</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef SA_INTERRUPT
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=n>act</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>|=</span> <span class=n>SA_INTERRUPT</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 除SIGALRM之外的信号，都设置系统调用自动重启动，SIGALRM信号用于对I/O操作进行时间限制
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>act</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>|=</span> <span class=n>SA_RESTART</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigaction</span><span class=p>(</span><span class=n>signo</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>act</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oact</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>SIG_ERR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>oact</span><span class=p>.</span><span class=n>sa_handler</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_alrm</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;SIGALRM=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>mysignal</span><span class=p>(</span><span class=n>SIGALRM</span><span class=p>,</span> <span class=n>sig_alrm</span><span class=p>)</span> <span class=o>==</span> <span class=n>SIG_ERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;signal&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>alarm</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pause</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 执行结果如下：
</span></span></span><span class=line><span class=cl><span class=c1>// $ ./my_signal
</span></span></span><span class=line><span class=cl><span class=c1>// SIGALRM=14
</span></span></span></code></pre></div><p>在重启启动被中断的系统调用的环境中，使用<code>SA_INTERRUPT</code>标志可以使系统调用被中断后不再重启动。</p><h3 id=sigsetjmp与siglongjmp函数><a href=#sigsetjmp%e4%b8%8esiglongjmp%e5%87%bd%e6%95%b0>sigsetjmp与siglongjmp函数</a></h3><p><code>sigsetjmp</code>与<code>siglongjmp</code>函数是<code>setjmp</code>与<code>longjmp</code>函数的替代品，用于在信号处理程序中进行非局部跳转。</p><p>原因是<strong>使用<code>longjmp</code>函数跳出信号处理程序后，并不能保证会恢复信号屏蔽字，因为在执行信号处理程序时，当前信号会被加入到当前信号屏蔽字中</strong>。</p><p>如果在<strong>中断了其他信号处理程序的信号的处理程序中</strong>调用<code>siglongjmp</code>函数，那和调用<code>longjmp</code>函数存在的问题是一样的，都是会提前终止第一个信号处理程序，这种问题只能通过可靠信号的阻塞机制来解决。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;setjmp.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sigsetjmp</span><span class=p>(</span><span class=n>sigjmp_buf</span> <span class=n>env</span><span class=p>,</span> <span class=kt>int</span> <span class=n>savesigs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：直接调用返回0，从siglongjmp调用返回非0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>[[</span><span class=n>noreturn</span><span class=p>]]</span> <span class=kt>void</span> <span class=nf>siglongjmp</span><span class=p>(</span><span class=n>sigjmp_buf</span> <span class=n>env</span><span class=p>,</span> <span class=kt>int</span> <span class=n>val</span><span class=p>);</span>
</span></span></code></pre></div><p>这两个函数与<code>setjmp</code>和<code>longjmp</code>函数的唯一区别就是增加了一个参数<code>savesigs</code>。</p><p>如果<code>savesigs</code>非0，则<code>sigsetjmp</code>函数会在<code>env</code>参数中保存当前信号屏蔽字。</p><p>调用<code>siglongjmp</code>函数时，如果<code>env</code>中保存有当前信号屏蔽字，则从其中恢复。</p><h4 id=示例-2><a href=#%e7%a4%ba%e4%be%8b-2>示例</a></h4><p>下面的例子中显示了系统会将正在执行的信号处理程序对应的信号加入的当前信号屏蔽字中，同时也展示了<code>sigsetjmp</code>与<code>siglongjmp</code>函数的用法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;setjmp.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>sigjmp_buf</span> <span class=n>jmpbuf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 用于判定是否能够跳转，防止在还没调用sigsetjmp初始化jmpbuf之前进行跳转
</span></span></span><span class=line><span class=cl><span class=c1>// sig_atomic_t数据类型，ISO C标准定义，写时不会被中断，意味着可以用一条机器指令来对其进行访问
</span></span></span><span class=line><span class=cl><span class=c1>// volatile修饰符表示该变量不需要编译器优化，同时每次都从内存中读取，而不是缓存在寄存器中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=k>volatile</span> <span class=kt>sig_atomic_t</span> <span class=n>canjump</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>pr_mask</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sigset_t</span> <span class=n>sigset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>errno_save</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>errno_save</span> <span class=o>=</span> <span class=n>errno</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigprocmask</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sigset</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigprocmask&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sigismember</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sigset</span><span class=p>,</span> <span class=n>SIGINT</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; SIGINT&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sigismember</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sigset</span><span class=p>,</span> <span class=n>SIGQUIT</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; SIGQUIT&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sigismember</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sigset</span><span class=p>,</span> <span class=n>SIGUSR1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; SIGUSR1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sigismember</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sigset</span><span class=p>,</span> <span class=n>SIGALRM</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; SIGALRM&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sigismember</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sigset</span><span class=p>,</span> <span class=n>SIGTSTP</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; SIGTSTP&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>errno</span> <span class=o>=</span> <span class=n>errno_save</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_usr1</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>time_t</span> <span class=n>starttime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 检测是否可以跳转
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>canjump</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>  <span class=c1>// 执行到这里表示有未预期的SIGUSR1信号，因为canjmp还没初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>pr_mask</span><span class=p>(</span><span class=s>&#34;starting sig_usr1: &#34;</span><span class=p>);</span>  <span class=c1>// 在这里打印的信号屏蔽字中会出现SIGUSR1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>alarm</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>  <span class=c1>// 设置3s时钟
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>starttime</span> <span class=o>=</span> <span class=nf>time</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;;)</span>  <span class=c1>// 忙等5s，在这期间会触发SIGALRM信号
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=nf>time</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>starttime</span> <span class=o>+</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>pr_mask</span><span class=p>(</span><span class=s>&#34;finishing sig_usr1: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>canjump</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>siglongjmp</span><span class=p>(</span><span class=n>jmpbuf</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>  <span class=c1>// 跳转回main函数，并设置sigsetjmp函数返回值为1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_alrm</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 此时信号屏蔽字应该为SIGUSR1|SIGALRM，因为递送中的信号会被加入到当前信号屏蔽字中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>pr_mask</span><span class=p>(</span><span class=s>&#34;in sig_alrm: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGUSR1</span><span class=p>,</span> <span class=n>sig_usr1</span><span class=p>)</span> <span class=o>==</span> <span class=n>SIG_ERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;signal: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGALRM</span><span class=p>,</span> <span class=n>sig_alrm</span><span class=p>)</span> <span class=o>==</span> <span class=n>SIG_ERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;signal: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>pr_mask</span><span class=p>(</span><span class=s>&#34;staring main: &#34;</span><span class=p>);</span>  <span class=c1>// 此时信号屏蔽字为空
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigsetjmp</span><span class=p>(</span><span class=n>jmpbuf</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>  <span class=c1>// 1 表示保存当前信号屏蔽字，并恢复
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>pr_mask</span><span class=p>(</span><span class=s>&#34;ending main: &#34;</span><span class=p>);</span>  <span class=c1>// 此时信号屏蔽字为空
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>_exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>canjump</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>// 原子操作，并表示现在可以跳转了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(;;)</span>
</span></span><span class=line><span class=cl>        <span class=nf>pause</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ps  -ef <span class=p>|</span> grep sig
</span></span><span class=line><span class=cl>blduan     <span class=m>24494</span>   <span class=m>23109</span>  <span class=m>0</span> 20:37 pts/0    00:00:00 ./sigsetjmp_demo
</span></span><span class=line><span class=cl>$ <span class=nb>kill</span> -USR1 <span class=m>24494</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ./sigsetjmp_demo
</span></span><span class=line><span class=cl>staring main:
</span></span><span class=line><span class=cl>starting sig_usr1:  SIGUSR1
</span></span><span class=line><span class=cl>in sig_alrm:  SIGUSR1 SIGALRM
</span></span><span class=line><span class=cl>finishing sig_usr1:  SIGUSR1
</span></span><span class=line><span class=cl>ending main:
</span></span></code></pre></div><p>从执行结果可以看出，当调用一个信号处理程序时，被捕捉到的信号就被加入到进程的当前信号屏蔽字中。</p><h3 id=sigsuspend函数><a href=#sigsuspend%e5%87%bd%e6%95%b0><code>sigsuspend</code>函数</a></h3><p><code>sigsuspend()</code>函数会设置一个临时的信号屏蔽字，然后阻塞进程，直到收到一个可递送的未屏蔽的信号。</p><p><code>sigsuspend()</code>函数返回之后会将信号屏蔽字设置为调用之前的信号屏蔽字。</p><p>基于以上两点，<code>sigsuspend()</code>函数通常用于要将<strong>对某些信号解除阻塞并使进程阻塞作为一个原子操作</strong>的情况。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>sigsuspend</span><span class=p>(</span><span class=k>const</span> <span class=kt>sigset_t</span> <span class=o>*</span><span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 返回值： -1， 并将errno设置为EINTR
</span></span></span></code></pre></div><p><strong><code>sigsuspend</code>函数的作用是将解除信号阻塞与使进程休眠合并为一个原子操作</strong>， 可用于等待特定信号。</p><p>下面的三个例子中分别实现了三个版本<code>sleep</code>函数，说明了<code>sigsuspend</code>函数的作用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_alrm1</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>sleep1</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sigaction</span> <span class=n>newact</span><span class=p>,</span> <span class=n>oldact</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 设置SIGALRM的信号处理程序
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>newact</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>sig_alrm1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newact</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGALRM</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newact</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldact</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>seconds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 设置时钟，seconds秒后产生SIGALRM信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>alarm</span><span class=p>(</span><span class=n>seconds</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 休眠，等待从sig_alrm1信号函数中返回则返回。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 此处存在时间窗口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>pause</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 4. 检测休眠剩余描述
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>unslept</span> <span class=o>=</span> <span class=nf>alarm</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 5. 恢复之前的信号处理程序
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGALRM</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldact</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>unslept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>该<code>sleep1</code>函数存在的问题在于，<strong>如果第2步调用完<code>alarm</code>函数之后CPU被其他进程占用，直到<code>seconds</code>指定的秒数之后，该进程都没能抢占到CPU，那么该进程在重新运行时，就会先被<code>SIGALRM</code>信号中断，先运行<code>SIGALRM</code>信号的处理函数，然后执行<code>pause</code>就会导致进程一直休眠</strong>。</p><p>对于这个问题如何优化呢？可以在调用<code>alarm</code>函数之前将<code>SIGALRM</code>信号阻塞，然后在<code>pause</code>之前在解除阻塞，使<code>pause</code>函数等待信号，如函数<code>sleep2</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>sleep2</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sigaction</span> <span class=n>newact</span><span class=p>,</span> <span class=n>oldact</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>sigset_t</span> <span class=n>newmask</span><span class=p>,</span> <span class=n>oldmask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 设置SIGALRM的信号处理程序
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>newact</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>sig_alrm1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newact</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGALRM</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newact</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldact</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>seconds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 阻塞SIGALRM信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newmask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigaddset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newmask</span><span class=p>,</span> <span class=n>SIGALRM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigprocmask</span><span class=p>(</span><span class=n>SIG_BLOCK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newmask</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldmask</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>seconds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 设置时钟，seconds秒后产生SIGALRM信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>alarm</span><span class=p>(</span><span class=n>seconds</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 4. 解除阻塞SIGALRM信号，该函数返回前如果有未决的、不阻塞的信号，会先执行信号处理程序
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigprocmask</span><span class=p>(</span><span class=n>SIG_SETMASK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldmask</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>alarm</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 5. 休眠，等待从sig_alrm1信号函数中返回则返回。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 此处存在时间窗口，可能会被SIGALRM信号中断
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>pause</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 6. 检测休眠剩余描述
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>unslept</span> <span class=o>=</span> <span class=nf>alarm</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 7. 恢复之前的信号处理程序
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGALRM</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldact</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>unslept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然而<code>sleep2</code>函数也存在问题，即 <strong><code>sigpromask</code>函数在返回之前，系统就会将一个未决的并且不阻塞的信号递送给当前进程，这意味着<code>sigprocmask</code>函数还未返回，就会先被某个信号处理程序中断，如果仅有一个信号并且该信号是<code>SIGALRM</code>，那么就会导致下面的<code>pause</code>函数无法返回，进程永久休眠</strong>。</p><p>所以需要将解除阻塞<code>SIGALRM</code>信号与<code>pause</code>休眠等待该信号合并为一个原子动作，不会被信号中断，这就是<code>sigsuspend</code>函数的作用。</p><p>下面的示例中使用<code>sigsuspend</code>函数来实现<code>sleep3</code>函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>sleep3</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sigaction</span> <span class=n>newact</span><span class=p>,</span> <span class=n>oldact</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>sigset_t</span> <span class=n>newmask</span><span class=p>,</span> <span class=n>oldmask</span><span class=p>,</span> <span class=n>suspmask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>unslept</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>newact</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>sig_alrm1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newact</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 设置SIGALRM的信号处理程序
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGALRM</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newact</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldact</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>seconds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newmask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigaddset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newmask</span><span class=p>,</span> <span class=n>SIGALRM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 阻塞SIGALRM信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigprocmask</span><span class=p>(</span><span class=n>SIG_BLOCK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newmask</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldmask</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>seconds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 设置时钟，seconds秒后产生SIGALRM信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>alarm</span><span class=p>(</span><span class=n>seconds</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 4. 从原有的信号屏蔽字中去除SIGALRM，解除SIGALRM阻塞，并并暂停进程等待接收信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>suspmask</span> <span class=o>=</span> <span class=n>oldmask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigdelset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>suspmask</span><span class=p>,</span> <span class=n>SIGALRM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigsuspend</span><span class=p>(</span><span class=o>&amp;</span><span class=n>suspmask</span><span class=p>);</span> <span class=c1>// 原子操作，解除阻塞到进程休眠是原子操作，不会导致信号丢失
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 5. 检测休眠剩余描述
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>unslept</span> <span class=o>=</span> <span class=nf>alarm</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 6. 恢复之前的信号处理程序
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGALRM</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldact</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 7. 恢复之前的信号屏蔽字
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sigprocmask</span><span class=p>(</span><span class=n>SIG_SETMASK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldmask</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>unslept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=示例-3><a href=#%e7%a4%ba%e4%be%8b-3>示例</a></h4><p>该函数常用于临时设置一个新的信号屏蔽字，并等待特定信号的到来，以实现临时阻塞其他信号的目的。</p><p>下面的例子中，会捕捉中断信号与退出信号，但仅当捕捉到退出信号时，进程才会继续执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>static</span> <span class=k>volatile</span> <span class=kt>sig_atomic_t</span> <span class=n>quitflag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_intr</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>==</span> <span class=n>SIGQUIT</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>quitflag</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>interrupt</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>quitflag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sigset_t</span> <span class=n>newmask</span><span class=p>,</span> <span class=n>oldmask</span><span class=p>,</span> <span class=n>suspmask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=n>sig_intr</span><span class=p>)</span> <span class=o>==</span> <span class=n>SIG_ERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;signal&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGQUIT</span><span class=p>,</span> <span class=n>sig_intr</span><span class=p>)</span> <span class=o>==</span> <span class=n>SIG_ERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;signal&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newmask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigaddset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newmask</span><span class=p>,</span> <span class=n>SIGQUIT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 阻塞SIGQUIT，目的在于在调用sigsuspend之前不会被SIGQUIT信号中断
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 如果SIGQUIT信号仅产生一次并且在sigsuspend之前产生，那么下面sigsuspend就会永久阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigprocmask</span><span class=p>(</span><span class=n>SIG_BLOCK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newmask</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldmask</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigprocmask&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>suspmask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 只有捕捉到SIGQUIT信号才会退出循环，与条件变量的用法类似
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>quitflag</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 设置信号屏蔽字为susmask，并使进程休眠
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sigsuspend</span><span class=p>(</span><span class=o>&amp;</span><span class=n>suspmask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 已捕捉到SIGQUIT信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>quitflag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 恢复信号屏蔽字，并解除阻塞SIGQUIT
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigprocmask</span><span class=p>(</span><span class=n>SIG_SETMASK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldmask</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigprocmask&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./sigsuspend_demo1
</span></span><span class=line><span class=cl>^C
</span></span><span class=line><span class=cl>interrupt
</span></span><span class=line><span class=cl>^C
</span></span><span class=line><span class=cl>interrupt
</span></span><span class=line><span class=cl>^C
</span></span><span class=line><span class=cl>interrupt
</span></span><span class=line><span class=cl>^C
</span></span><span class=line><span class=cl>interrupt
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><p><strong>如果在等待信号期间需要进程去休眠，可以调用<code>sigsuspend</code>；如果在等待信号期间需要调用其他系统函数，那么解决方法是使用多线程，在单独的下线程中处理信号</strong>。</p><h3 id=sigqueue函数><a href=#sigqueue%e5%87%bd%e6%95%b0><code>sigqueue</code>函数</a></h3><p><code>sigqueue</code>函数可以在发送信号时携带整形或指针参数，其他与<code>kill</code>函数一致。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>sigqueue</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sig</span><span class=p>,</span> <span class=k>const</span> <span class=k>union</span> <span class=n>sigval</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：成功返回0，失败返回-1
</span></span></span></code></pre></div><p>如果接收进程想要获取<code>sigqueue</code>函数发送的信号的额外参数，就要对<code>sig</code>参数指定的信号使用<code>sigaction</code>函数安装信号处理程序，同时指定<code>SA_SIGINFO</code>标志，然后使用<code>sa_sigaction</code>指定的信号处理程序。</p><p>下面是使用<code>sigqueue</code>函数发送带自定义参数的示例</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 发送10个SIGUSR信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>union</span> <span class=n>sigval</span> <span class=n>val1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>val1</span><span class=p>.</span><span class=n>sival_int</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>sigqueue</span><span class=p>(</span><span class=nf>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]),</span> <span class=n>SIGUSR1</span><span class=p>,</span> <span class=n>val1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;send SIGUSR1 %d time</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 发送10个SIGRTMIN实时信号，发送优先级高，阻塞时不会被合并为一个
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>union</span> <span class=n>sigval</span> <span class=n>val1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>val1</span><span class=p>.</span><span class=n>sival_int</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>sigqueue</span><span class=p>(</span><span class=nf>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]),</span> <span class=n>SIGRTMIN</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>val1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;send SIGRTMIN %d time</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 循环交叉发送SIGINT和SIGALRM
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>union</span> <span class=n>sigval</span> <span class=n>val1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>val1</span><span class=p>.</span><span class=n>sival_int</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>sigqueue</span><span class=p>(</span><span class=nf>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]),</span> <span class=n>i</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>?</span> <span class=nl>SIGINT</span> <span class=p>:</span> <span class=n>SIGALRM</span><span class=p>,</span> <span class=n>val1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;send %s %d time</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>strsignal</span><span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>?</span> <span class=nl>SIGINT</span> <span class=p>:</span> <span class=n>SIGALRM</span><span class=p>),</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// $ ./sigqueue_send 39062
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGUSR1 0 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGUSR1 1 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGUSR1 2 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGUSR1 3 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGUSR1 4 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGUSR1 5 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGUSR1 6 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGUSR1 7 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGUSR1 8 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGUSR1 9 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGRTMIN 0 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGRTMIN 1 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGRTMIN 2 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGRTMIN 3 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGRTMIN 4 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGRTMIN 5 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGRTMIN 6 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGRTMIN 7 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGRTMIN 8 time
</span></span></span><span class=line><span class=cl><span class=c1>// send SIGRTMIN 9 time
</span></span></span><span class=line><span class=cl><span class=c1>// send Interrupt 0 time
</span></span></span><span class=line><span class=cl><span class=c1>// send Alarm clock 1 time
</span></span></span><span class=line><span class=cl><span class=c1>// send Interrupt 2 time
</span></span></span><span class=line><span class=cl><span class=c1>// send Alarm clock 3 time
</span></span></span><span class=line><span class=cl><span class=c1>// send Interrupt 4 time
</span></span></span><span class=line><span class=cl><span class=c1>// send Alarm clock 5 time
</span></span></span><span class=line><span class=cl><span class=c1>// send Interrupt 6 time
</span></span></span><span class=line><span class=cl><span class=c1>// send Alarm clock 7 time
</span></span></span><span class=line><span class=cl><span class=c1>// send Interrupt 8 time
</span></span></span><span class=line><span class=cl><span class=c1>// send Alarm clock 9 time
</span></span></span></code></pre></div><p>接收信号示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_act</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>,</span> <span class=kt>siginfo_t</span><span class=o>*</span> <span class=n>siginfo</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>context</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 在执行信号处理程序时，相应的信号会被阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 阻塞期间产生的标准信号仅递送一次，实时信号会全部排队递送
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>==</span> <span class=n>SIGUSR1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;caught SIGUSR1 &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>==</span> <span class=n>SIGALRM</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;caught SIGALRM &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>==</span> <span class=n>SIGINT</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;caught SIGINT &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>==</span> <span class=p>(</span><span class=n>SIGRTMIN</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;caught SIGRTMIN&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>siginfo</span><span class=o>-&gt;</span><span class=n>si_value</span><span class=p>.</span><span class=n>sival_int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sigaction</span> <span class=n>newact</span><span class=p>,</span> <span class=n>oldact</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newact</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>newact</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>=</span> <span class=n>SA_SIGINFO</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>newact</span><span class=p>.</span><span class=n>sa_sigaction</span> <span class=o>=</span> <span class=n>sig_act</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGUSR1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newact</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldact</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigaction&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newact</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldact</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigaction&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGALRM</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newact</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldact</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigaction&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGRTMIN</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newact</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldact</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigaction&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>_exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// $ ./sigqueue_recv
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGUSR1 0 执行信号处理程序阻塞期间，后续SIGUSR1并合并为一个
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGRTMIN0 实时信号不会被合并
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGRTMIN1
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGUSR1 1
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGRTMIN2
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGRTMIN3
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGRTMIN4
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGRTMIN5
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGRTMIN6
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGRTMIN7
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGRTMIN8
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGRTMIN9
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGALRM 1 执行信号处理程序阻塞期间，后续SIGALRM并合并为一个
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGINT 0 执行信号处理程序阻塞期间，后续SIGINT并合并为一个
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGALRM 3
</span></span></span><span class=line><span class=cl><span class=c1>// caught SIGINT 2
</span></span></span></code></pre></div><p>上面的实例中展示了如何使用<code>sigqueue</code>发送信号时如何携带参数，同时也说明了一点非<strong>实时信号在被阻塞期间产生了一次或多次，解除阻塞之后仅会被递送一次</strong>，例如<code>SIGUSR1, SIGARLRM, SIGINT</code>在第一次处理期间是阻塞的，后面产生的多个信号都被合并为一个进行递送，而<strong>实时信号则会进行排队</strong>。</p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://DBL2017.github.io/>生如夏花</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br><div class=post-archive><h2>See Also</h2><ul class=listing><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7/>可靠信号</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/>不可靠信号的相关问题</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0/>信号概述</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/>进程环境</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E6%A0%87%E5%87%86io/>标准IO</a></li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a href=/tags/apue>APUE</a></li><li><a href=/tags/unix>Unix</a></li><li><a href=/tags/%E4%BF%A1%E5%8F%B7>信号</a></li><li><a href=/tags/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B>Unix环境高级编程</a></li><li><a href=/tags/%E4%BF%A1%E5%8F%B7%E9%9B%86>信号集</a></li><li><a href=/tags/sigset_t>sigset_t</a></li></ul></div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=DBL2017/DBL2017.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></div></div></div><div class=content-right><div class=sidebar><section class=widget><form id=form-search action=https://DBL2017.github.io/search/ method=get accept-charset=utf-8 _lpchecked=1><input type=text name=q maxlength=20 placeholder=请输入查找关键字 required>
<button type=submit class=submit title=提交><svg t="1714448321870" class="icon" style="width:22px;height:22px" viewBox="0 0 1024 1024" p-id="1771" width="200" height="200"><path d="M781.9264 691.1232l236.928 236.9216-90.816 90.8032-236.9152-236.9216c-72.032 53.3568-161.184 84.9088-257.7088 84.9088C194.048 866.8352.0 672.7872.0 433.408.0 194.048 194.048.0 433.4144.0c239.3728.0 433.4208 194.048 433.4208 433.4144.0 96.5248-31.552 185.6768-84.9088 257.7088zm-348.512 47.2896c168.448.0 304.9984-136.5504 304.9984-304.9984s-136.5504-304.992-304.9984-304.992-304.992 136.5504-304.992 304.9856c0 168.448 136.5504 304.9984 304.992 304.9984z" fill="#4a4a4a" p-id="1772"/></svg></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/iptables%E5%9B%9B%E8%A1%A8%E4%BA%94%E9%93%BE/ title=iptables四表五链>iptables四表五链</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows%E4%B8%AD%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E8%B7%83%E7%82%B9%E6%95%B0%E5%92%8C%E6%B0%B8%E4%B9%85%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F/ title=Windows中通过配置跃点数和永久路由选择上网方式>Windows中通过配置跃点数和永久路由选择上网方式</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/free%E5%91%BD%E4%BB%A4%E4%B8%ADbuff-cache%E5%8D%A0%E6%BB%A1%E5%86%85%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/ title=free命令中buff-cache占满内存的问题>free命令中buff-cache占满内存的问题</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/docker%E5%91%BD%E4%BB%A4%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B/ title=docker命令无法连接到后台进程>docker命令无法连接到后台进程</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/%E6%89%A9%E5%B1%95%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6eui%E7%BB%84%E7%BB%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6oui%E5%92%8C%E5%85%AC%E5%8F%B8idcid%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/ title=扩展唯一标识符（EUI）、组织唯一标识符（OUI）和公司ID（CID）的使用指南>扩展唯一标识符（EUI）、组织唯一标识符（OUI）和公司ID（CID）的使用指南</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/openwrt%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%A4%84%E7%90%86uci%E9%85%8D%E7%BD%AE/ title=OpenWrt之shell脚本处理UCI配置>OpenWrt之shell脚本处理UCI配置</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/openwrt%E4%B9%8Buci.sh%E4%B8%ADuci_load%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/ title=OpenWrt之uci.sh中uci_load的工作原理>OpenWrt之uci.sh中uci_load的工作原理</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/tmux%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/ title=tmux使用方法>tmux使用方法</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/ title=iptables自定义链>iptables自定义链</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ubuntu24.04-apt-upgrade%E6%8F%90%E7%A4%BAesm-apps/ title="Ubuntu24.04 apt upgrade提示esm-apps">Ubuntu24.04 apt upgrade提示esm-apps</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=https://DBL2017.github.io/categories/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/>传输协议 (12)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/>工具使用 (20)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/>开源三方 (2)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统 (11)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/>数字安全 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/>数据结构和算法 (5)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言 (6)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/>网络工程师 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记 (56)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/>问题排查 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%BB%98%E8%AE%A4/>默认 (2)</a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://mermaid.live/ title=Mermaid>Mermaid 编辑</a></li><li><a target=_blank href=https://excalidraw.com/ title=EXCALIDRAW>Excalidraw 绘图</a></li><li><a target=_blank href=https://git-scm.com/docs title=Git命令参考手册>Git命令参考手册</a></li><li><a target=_blank href=https://www.gnu.org/software/make/manual/make.html title="GNU make官方文档">GNU make官方文档</a></li><li><a target=_blank href=https://www.emojiall.com/ title=Emojiall表情网站>Emojiall表情网站</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/index.xml>文章 RSS</a></li></ul></section></div></div></div><div class=container-footer><footer id=footer><div>&copy; 2025 <a href=https://DBL2017.github.io/>生如夏花 By
生如夏花</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>广电总局</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered
by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://DBL2017.github.io/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">生如夏花</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script src=/js/jquery.fancybox.min.min.9040007c0fd2a6cdc356495acb1c45ba3328b261b0d9f75d3da19bc47229189108aab8ca043864c1801d59431de72dec8d51ae50539f9ce1f5964bf5f38786c3.js integrity="sha512-kEAAfA/Sps3DVklayxxFujMosmGw2fddPaGbxHIpGJEIqrjKBDhkwYAdWUMd5y3sjVGuUFOfnOH1lkv184eGww==" crossorigin=anonymous></script><a id=rocket href=#top></a><script src=/js/totop.min.8c7573186baa30f09c49b5cf3176c3b105785324d961b3d5c2f7f099d14673160a29aeebdec25909d046aa14936cd43451e17664662d518550d5e8998dbec670.js integrity="sha512-jHVzGGuqMPCcSbXPMXbDsQV4UyTZYbPVwvfwmdFGcxYKKa7r3sJZCdBGqhSTbNQ0UeF2ZGYtUYVQ1eiZjb7GcA==" crossorigin=anonymous></script><script src=/js/clipboard.min.0765794be1674926c1a3810afcf039f605f367cb11cef727ad49e6aa70f9fca0a37d329d64c55822896869eb0960763e73e085ee7675cbc497e4d3256a6e6a67.js integrity="sha512-B2V5S+FnSSbBo4EK/PA59gXzZ8sRzvcnrUnmqnD5/KCjfTKdZMVYIoloaesJYHY+c+CF7nZ1y8SX5NMlam5qZw==" crossorigin=anonymous></script><script>var spy=new Gumshoe("#TableOfContents a",{nested:!0,nestedClass:"active"})</script><script>hljs.highlightAll()</script></div></div></body></html>