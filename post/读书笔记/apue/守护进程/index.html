<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>守护进程 | 生如夏花</title><meta property="og:title" content="守护进程 - 生如夏花"><meta property="og:type" content="article"><meta property="article:published_time" content='2024-03-30T22:26:53+08:00'><meta property="article:modified_time" content='2024-03-30T22:26:53+08:00'><meta name=Keywords content="C语言,Linux系统开发,物联网,博客,项目管理,软件架构"><meta name=description content="守护进程（dameon）控制终端，会话首进程，孤儿进程组，后台进程。编写守护进程（daemonize）的7个步骤（umask，fork，setsid，/dev/null），基于文件记录锁的单实例守护进程"><meta name=author content><meta property="og:url" content="https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css><link rel=stylesheet href=/css/badge.min.c6e6f065a59e7bd54d7bd6bf2f3998a1fcb485582aca59bb6257806f0d956d2f5785e1b9cadfe4452359086749d379aabe5bc50132b1bfcc994e5f9d7150ccbe.css integrity="sha512-xubwZaWee9VNe9a/LzmYofy0hVgqylm7YleAbw2VbS9XheG5yt/kRSNZCGdJ03mqvlvFATKxv8yZTl+dcVDMvg==" crossorigin=anonymous><link rel=stylesheet href=/css/header.min.9e74ad2f7e23fb54e2da3ef2f1eb6498897cd4139d181133b5e641f107980364ccfbcea731badb693b4a50819c388b6f8cab037346daf142114f86f14faa8766.css integrity="sha512-nnStL34j+1Ti2j7y8etkmIl81BOdGBEzteZB8QeYA2TM+86nMbrbaTtKUIGcOItvjKsDc0ba8UIRT4bxT6qHZg==" crossorigin=anonymous><link rel=stylesheet href=/css/table.min.c193c9134b7b9c6f88c84f2b6e189f1783056a6c6a7eab574e1ec8f1537bbbb4b3c44e130004fbb98e9e2f260c7485a74e96db4bd156e1f49a20013ab811e874.css integrity="sha512-wZPJE0t7nG+IyE8rbhifF4MFamxqfqtXTh7I8VN7u7SzxE4TAAT7uY6eLyYMdIWnTpbbS9FW4fSaIAE6uBHodA==" crossorigin=anonymous><link rel=stylesheet href=/css/baseof.min.7799d75bdec4c3ec6c9b5cc5291d9f452a0103bfe0f58e5d705baa7abe57f2e977a22fc3ff0b101c063d7f39931420391a0dc2b5ddc7b306110ef51ab01cb247.css integrity="sha512-d5nXW97Ew+xsm1zFKR2fRSoBA7/g9Y5dcFuqer5X8ul3oi/D/wsQHAY9fzmTFCA5Gg3Ctd3HswYRDvUasByyRw==" crossorigin=anonymous><link rel=stylesheet href=/css/rocket.min.96a6be31cd3df9dcd4e7e131e9fcb0e63149da1da6a23df5ed8c8e0ccf0436f4c95aad5ded6a69e7fba5c051f8cc00466fcedaa07e4c7f59492d4a15aba2e936.css integrity="sha512-lqa+Mc09+dzU5+Ex6fyw5jFJ2h2moj317YyODM8ENvTJWq1d7Wpp5/ulwFH4zABGb87aoH5Mf1lJLUoVq6LpNg==" crossorigin=anonymous><link rel=stylesheet href=/css/toc.min.37fe0fbda85f18e890be33d1e0a82b29b78f1266bfe17e63679d86b84af41b0124616f83d28227783c214e26bd8d70223d405128cc355d865d7016623a163068.css integrity="sha512-N/4PvahfGOiQvjPR4KgrKbePEma/4X5jZ52GuEr0GwEkYW+D0oIneDwhTia9jXAiPUBRKMw1XYZdcBZiOhYwaA==" crossorigin=anonymous><link rel=stylesheet href=/css/clipboard.min.5e6a0198e50c850ced7dc2ba6f282ecaab21a8daad9eee626b990120818361b4b0007128d73957d5682346c88a6f9831f5872051e5f12da830cc29ca75676403.css integrity="sha512-XmoBmOUMhQztfcK6byguyqshqNqtnu5ia5kBIIGDYbSwAHEo1zlX1WgjRsiKb5gx9YcgUeXxLagwzCnKdWdkAw==" crossorigin=anonymous><link rel=stylesheet href=/css/style.min.c3c6800c298f5369e9063d72a2b534abf64bf1ee7bec54c70f15a3219ad0ae104e388252951ef21ce76c1d3b7ec5eb40939179a89684e52034d885e6e002e1ea.css integrity="sha512-w8aADCmPU2npBj1yorU0q/ZL8e577FTHDxWjIZrQrhBOOIJSlR7yHOdsHTt+xetAk5F5qJaE5SA02IXm4ALh6g==" crossorigin=anonymous><link rel="shortcut icon" href=/img/favicon.png type=image/x-icon><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/vim.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/latex.min.js></script><script src=/js/gumshoe.min.min.9dec1df0371d73b03324ed4bb78a6d5b2e84af6a37b11ce799808a26d70dfd156595f8d23c42db9e4866f12b4c0de664cfd032fa6f95bdaaada1bacdb235e79e.js integrity="sha512-newd8Dcdc7AzJO1Lt4ptWy6Er2o3sRznmYCKJtcN/RVllfjSPELbnkhm8StMDeZkz9Ay+m+VvaqtobrNsjXnng==" crossorigin=anonymous></script></head><body><div class=container><div class=container-header><header><div class=header-main><div class=header-site-name><a id=header-title href=https://DBL2017.github.io/>生如夏花</a><p class=description>专注于工业物联网行业数据采集，嵌入式Linux系统裁剪，5G智慧网关软件开发等</p></div><div class=header-menu><nav id=header-nav-menu><a href=https://DBL2017.github.io/>首页</a>
<a href=https://DBL2017.github.io/series/ title=系列>系列</a>
<a href=https://DBL2017.github.io/categories/ title=分类>分类</a>
<a href=https://DBL2017.github.io/tags/ title=标签>标签</a>
<a href=https://DBL2017.github.io/archives/ title=归档>归档</a>
<a href=https://DBL2017.github.io/about/ title=关于>关于</a></nav></div></div></header></div><div class=container-content><div class=content-center><div class=main-single><div class=single-toc><div class=post-toc><h2 class=post-toc-title><a href=#>目录</a></h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#守护进程>守护进程</a><ul><li><a href=#守护进程示例>守护进程示例</a></li><li><a href=#守护进程特征>守护进程特征</a></li></ul></li><li><a href=#如何编写守护进程>如何编写守护进程</a><ul><li><a href=#守护进程示例-1>守护进程示例</a></li><li><a href=#遵循惯例>遵循惯例</a></li></ul></li><li><a href=#使用场景>使用场景</a><ul><li><a href=#单实例守护进程>单实例守护进程</a></li></ul></li><li><a href=#示例>示例</a><ul><li><a href=#示例1>示例1</a></li><li><a href=#示例2>示例2</a></li></ul></li></ul></nav></div></div></div><div class=single-article><article class=post><header><h1 class=post-title>守护进程</h1></header><date class="post-meta meta-date"><span class=meta-category><a href=/archives/#2024>2024年3月30日</a></span></date><div class=post-meta><span>|</span>
<span class=meta-category><a href=/categories/#%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0>读书笔记</a></span></div><div class=post-meta><span>|</span>
<span class=meta-category><a href=/series/#APUE>APUE</a></span></div><div class=post-meta><span>|</span>
<span>共4153字</span></div><div class=post-meta><span>|</span>
<span>阅读时长(9分钟)</span></div><div class=clear style=display:none><div class=toc-article><div class=toc-title>文章目录</div></div></div><div class=post-content><p>守护进程是生存期长的一种进程，在系统引导装入时启动，在系统关闭时终止。</p><p>守护进程没有控制终端，通常在后台运行，实际上是在后台的孤儿进程组中运行。</p><p>没有控制终端的原因在于<strong>不与用户交互，避免终端信号影响</strong>。</p><p>在孤儿进程组中运行的原因在于<strong>防止其获取控制终端（通过每次打开终端设备设置参数<code>O_NOCTTY</code>的方式不太靠谱）</strong>。</p><h2 id=守护进程><a href=#%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b>守护进程</a></h2><h3 id=守护进程示例><a href=#%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b%e7%a4%ba%e4%be%8b>守护进程示例</a></h3><p>下面是守护进程示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ps -ajx
</span></span><span class=line><span class=cl>UID    PID  PPID    PGID     SID TTY COMMAND
</span></span><span class=line><span class=cl>  <span class=m>0</span>      <span class=m>1</span>     <span class=m>0</span>       <span class=m>1</span>       <span class=m>1</span> ?   /lib/systemd/systemd --system --deserialize<span class=o>=</span><span class=m>43</span>
</span></span><span class=line><span class=cl>  <span class=m>0</span>      <span class=m>2</span>     <span class=m>0</span>       <span class=m>0</span>       <span class=m>0</span> ?   <span class=o>[</span>kthreadd<span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=m>0</span>     <span class=m>15</span>     <span class=m>2</span>       <span class=m>0</span>       <span class=m>0</span> ?   <span class=o>[</span>ksoftirqd/0<span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=m>0</span>     <span class=m>17</span>     <span class=m>2</span>       <span class=m>0</span>       <span class=m>0</span> ?   <span class=o>[</span>migration/0<span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=m>0</span>     <span class=m>59</span>     <span class=m>2</span>       <span class=m>0</span>       <span class=m>0</span> ?   <span class=o>[</span>watchdogd<span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=m>0</span>     <span class=m>62</span>     <span class=m>2</span>       <span class=m>0</span>       <span class=m>0</span> ?   <span class=o>[</span>kswapd0<span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=m>0</span>    <span class=m>107</span>     <span class=m>2</span>       <span class=m>0</span>       <span class=m>0</span> ?   <span class=o>[</span>kworker/0:1H-kblockd<span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=m>0</span>    <span class=m>365</span>     <span class=m>2</span>       <span class=m>0</span>       <span class=m>0</span> ?   <span class=o>[</span>jbd2/sda2-8<span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=m>0</span>    <span class=m>455</span>     <span class=m>2</span>       <span class=m>0</span>       <span class=m>0</span> ?   <span class=o>[</span>rpciod<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=m>108</span>    <span class=m>703</span>     <span class=m>1</span>     <span class=m>703</span>     <span class=m>703</span> ?   /sbin/rpcbind -f -w
</span></span><span class=line><span class=cl>  <span class=m>0</span>    <span class=m>736</span>     <span class=m>1</span>     <span class=m>736</span>     <span class=m>736</span> ?   /usr/sbin/nfsdcld
</span></span><span class=line><span class=cl>  <span class=m>0</span>    <span class=m>846</span>     <span class=m>1</span>     <span class=m>846</span>     <span class=m>846</span> ?   /usr/sbin/cron -f -P
</span></span><span class=line><span class=cl><span class=m>109</span>    <span class=m>863</span>     <span class=m>1</span>     <span class=m>863</span>     <span class=m>863</span> ?   /sbin/rpc.statd
</span></span><span class=line><span class=cl>  <span class=m>0</span>   <span class=m>6516</span>     <span class=m>1</span>    <span class=m>6516</span>    <span class=m>6516</span> ?   /usr/sbin/rsyslogd -n -iNONE
</span></span><span class=line><span class=cl>  <span class=m>0</span>   <span class=m>6560</span>     <span class=m>2</span>       <span class=m>0</span>       <span class=m>0</span> ?   <span class=o>[</span>nfsd<span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=m>0</span>   <span class=m>6546</span>     <span class=m>2</span>       <span class=m>0</span>       <span class=m>0</span> ?   <span class=o>[</span>lockd<span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=m>0</span>   <span class=m>6528</span>     <span class=m>1</span>    <span class=m>6528</span>    <span class=m>6528</span> ?   /usr/sbin/rpc.idmapd
</span></span><span class=line><span class=cl>  <span class=m>0</span>   <span class=m>6535</span>     <span class=m>1</span>    <span class=m>6535</span>    <span class=m>6535</span> ?   /usr/sbin/rpc.mountd
</span></span></code></pre></div><p><code>ps</code>参数<code>-a</code>显示所有用户进程，<code>-x</code>显示没有控制中断的进程状态，<code>-j</code>显示与作业控制相关的进程信息：会话ID、进程组ID、控制终端等。</p><p>父进程ID为0的进程通常是内核进程，在系统引导装入内存过程中启动，但<code>initd</code>与<code>systemd</code>进程除外，是系统引导过程中启动的第一个用户空间进程。</p><p><strong>内核进程存在于整个系统生命周期中，以超级用户权限运行，无控制终端，无命令行</strong>。</p><p>在上面的示例中，被方括号包裹的属于内核进程。<code>kthreadd</code>进程是第一个内核进程，其他内核进程通常由<code>kthreadd</code>进程来创建。</p><p><strong>对于需要在进程上下文执行工作，但不会被用户层进程上下文调用的每一个内核组件，通常都会有其自己的内核守护进程</strong>。例如：</p><ol><li><code>kswapd0</code>守护进程也称为<strong>内存换页守护进程</strong>（工作在内核的进程上下文中）。主要作用是将虚拟内存子系统中的脏页面写回磁盘。</li><li><code>jbd*</code>守护进程支持<code>ext4</code>文件系统中的日志功能。</li></ol><p><strong>进程ID为1的<code>initd</code>或<code>systemd</code>进程主要用于创建用户空间的守护进程</strong>。例如：</p><ol><li><code>rpcbind</code>守护进程提供将远程过程调用程序号映射为网络端口号的服务。</li><li><code>rsyslogd</code>守护进程可以被具有超级用户权限的进程在写入系统日志时使用。</li><li><code>nfsd, lockd, rpciod, rpc.idmapd, rpc.mountd, rpc.statd</code>等守护进程提供对NFS的支持（其中既有内核守护进程也有用户级守护进程）。</li><li><code>cron</code>守护进程在定期安排的日期和时间执行命令。</li><li><code>sshd</code>进程提供安全的远程登录和执行环境。</li></ol><h3 id=守护进程特征><a href=#%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b%e7%89%b9%e5%be%81>守护进程特征</a></h3><ol><li>大多数守护进程都以超级用户（<code>root</code>）特权运行。</li><li>所有守护进程都没有控制终端，其终端名设置为问号。</li><li>内核守护进程以无终端方式启动，用户层守护进程缺少控制终端可能是调用了<code>setsid</code>的结果。</li><li>大多数用户层守护进程都是进程组的组长进程以及会话的首进程，而且是这些进程组和会话中的唯一进程。</li><li>用户层守护进程的父进程都是<code>init</code>或<code>systemd</code>进程。</li></ol><h2 id=如何编写守护进程><a href=#%e5%a6%82%e4%bd%95%e7%bc%96%e5%86%99%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b>如何编写守护进程</a></h2><p>在写守护进程时需要遵循一些基本规则，可以防止不必要的交互。</p><ol><li><strong>调用<code>umask()</code>函数修改文件模式创建屏蔽字设置为一个已知值</strong>。因为从父进程继承来的文件模式创建屏蔽字可能会屏蔽某些需要的权限。</li><li><strong>调用<code>fork()</code>返回后使父进程<code>exit</code></strong>。原因有两点：1是如果该守护进程是通过shell命令启动的，那么父进程终止会使shell返回并认为该命令已经执行结束。2是可以确保子进程不是一个进程组的组长进程，可用于调用<code>setsid()</code>函数创建新会话。</li><li><strong>调用<code>setsid()</code>创建一个新会话</strong>。这么做的原因有三点：1是新会话没有控制终端，不会受到终端信号的干扰（控制终端通常用于交互式会话）。2是成为一个独立的进程组的组长进程，方便与其他进程进行通信。3是成为新会话的会话首进程，独立于其他会话和进程来运行。</li><li><strong>再次调用<code>fork()</code>返回后使父进程<code>exit</code></strong>。这是因为第3步执行结束之后，守护进程是会话首进程，可能会在调用外部函数时获取控制终端。这一步可以保证守护进程父进程终止，自身处于孤儿进程组中，再也无法获取控制终端。</li><li><strong>将当前工作目录改为根目录</strong>。因为从父进程继承的当前工作目录可能是一个挂载的文件系统中，而守护进程通常在系统再引导之前一直存在，这会导致该文件系统无法卸载。</li><li><strong>关闭不再需要的文件描述符</strong>。</li><li><strong>打开<code>/dev/null</code>使其具有文件描述符0，1，2</strong>。使得任何一个试图读标准输入、写标准输出或标准错误的调用都不会产生任何效果。</li></ol><p>通过以上步骤，可以确保守护进程不与控制终端相关联，无法输出，也无法从任何地方获取输入。即使守护进程是从交互式会话中启动的，但守护进程是在后台孤儿进程组中运行的，因此登录会话的终止也不会影响守护进程。</p><h3 id=守护进程示例-1><a href=#%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b%e7%a4%ba%e4%be%8b-1>守护进程示例</a></h3><p>参照上面提出的7个步骤，下面给出了一个接口，用于将当前进程设置为守护进程。</p><p>示例中设置<code>SIGHUP</code>信号的处理程序为忽略，事实上意义不大，但该信号通常用于通知守护进程重新加载配置文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/resource.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>daemonize</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>daemonize</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>daemonize</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>rlimit</span> <span class=n>rl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 设置文件模式创建屏蔽字
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>umask</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取最大描述符数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>getrlimit</span><span class=p>(</span><span class=n>RLIMIT_NOFILE</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rl</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;getrlimit&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 调用fork并使父进程退出，子进程不是进程组组长，可以调用setsid创建会话。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 成为会话首进程并放弃控制终端，称为新进程组长进程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sleep</span><span class=p>(</span><span class=mi>30</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>setsid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 子进程此时已经是会话首进程并且该会话也没有控制终端，但是该标准输出被发送到哪里取决于运行环境
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 大多数情况下，如果父进程是在终端中运行的，并且没有重定向子进程的标准输出，
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 那么子进程的输出仍然会显示在终端上，即使子进程本身没有控制终端。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;pid=%d ppid=%d sid==%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=nf>getppid</span><span class=p>(),</span> <span class=nf>getsid</span><span class=p>(</span><span class=nf>getpid</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>    <span class=nf>sleep</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// SIGHUP信号的处理可有可无，通常可以用来通知守护进程重新加载配置文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>sigaction</span> <span class=n>sa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>sa</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>SIG_IGN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sa</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sa</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGHUP</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sa</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigaction&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 4.再次调用fork使父进程退出，子进程为孤儿进程组，可确保不会获取控制终端
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 5. 更改工作目录为/，防止当前工作目录在一个挂载的文件系统中。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>chdir</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;chdir&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 6. 关闭所有文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>rl</span><span class=p>.</span><span class=n>rlim_max</span> <span class=o>==</span> <span class=n>RLIM_INFINITY</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>rl</span><span class=p>.</span><span class=n>rlim_max</span> <span class=o>=</span> <span class=mi>1024</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>rl</span><span class=p>.</span><span class=n>rlim_max</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 6. 重定向标准流
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>fd0</span><span class=p>,</span> <span class=n>fd1</span><span class=p>,</span> <span class=n>fd2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>fd0</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/null&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fd1</span> <span class=o>=</span> <span class=nf>dup</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fd2</span> <span class=o>=</span> <span class=nf>dup</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 处理业务
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 执行结果如下：
</span></span></span><span class=line><span class=cl><span class=c1>// $ ./daemonize
</span></span></span><span class=line><span class=cl><span class=c1>// $ pid=17941 ppid=1 sid==17941
</span></span></span><span class=line><span class=cl><span class=c1>//  PPID     PID    PGID     SID TTY   TPGID    COMMAND
</span></span></span><span class=line><span class=cl><span class=c1>//     1   16232   16221   16221 ?        -1    ./daemonize
</span></span></span></code></pre></div><p>从结果中可以看出守护进程的父进程为init进程，不是进程组的组长进程（也不是会话首进程，可以确保无法获取控制终端），同时也没有控制终端。</p><h3 id=遵循惯例><a href=#%e9%81%b5%e5%be%aa%e6%83%af%e4%be%8b>遵循惯例</a></h3><p>编写守护进程通常遵循以下几点惯例：</p><ol><li><strong>如果守护进程需要使用锁文件，那么通常该文件存储在<code>/var/run</code>目录下，命名为<code>name.pid</code>，<code>name</code>为守护进程名</strong>，但一般需要超级用户权限才能在该目录下创建文件。</li><li>如果守护进程支持配置选项，那么配置文件一般为<code>/etc/name.conf</code>，其中<code>name</code>为守护进程名。例如syslogd进程的配置文件名为<code>syslogd.conf</code>。</li><li>守护进程虽然可用命令行启动，但通常是<strong>通过系统启动脚本来启动</strong>，比如<code>/etc/init.d/*</code>、<code>/etc/rc*</code>以及<code>systemd</code>的<code>service</code>文件配置等。如果守护进程终止，通常应配置<strong>自动重启</strong>。</li><li>守护进程在启动后读取完配置文件，之后配置文件发生变更，通常<strong>通过捕捉<code>SIGHUP</code>信号，收到该信号后重新读取配置文件</strong>。</li></ol><p><a href=#%E7%A4%BA%E4%BE%8B2>示例2</a>遵循上述惯例并支持重新读取配置文件，同时在单独线程中进行信号处理。</p><h2 id=使用场景><a href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af>使用场景</a></h2><h3 id=单实例守护进程><a href=#%e5%8d%95%e5%ae%9e%e4%be%8b%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b>单实例守护进程</a></h3><p>由于业务需要，某些守护进程在任一时刻可能仅需运行一个副本。</p><p>例如<code>cron</code>守护进程，如果同时有多个副本运行，那么设置的定时任务就会运行多次导致出错。</p><p>那么如何保证守护进程仅有一个副本在运行呢？通过<strong>文件和记录锁机制</strong>可以实现这个功能。</p><p><strong>如果守护进程创建了一个指定名称的文件，并在该文件的整体上加一把写锁，那么在该文件上仅允许创建一把这样的写锁</strong>。之后再创建写锁的操作都会失败，这可以向后续启动的守护进程副本指示已经有该守护进程在运行中。</p><p><strong>该守护进程终止时，这把锁将会被自动删除</strong>，这就意味着新的守护进程不用对以前操作进行清理。</p><p><a href=#%E7%A4%BA%E4%BE%8B1>示例1</a>给出了使用文件记录锁来保证守护进程单实例运行的相关代码。</p><h2 id=示例><a href=#%e7%a4%ba%e4%be%8b>示例</a></h2><h3 id=示例1><a href=#%e7%a4%ba%e4%be%8b1>示例1</a></h3><p>在该示例中，当<code>LOCKFILE</code>指定的文件不存在时先创建文件，然后对文件进行加锁。</p><p>后面启动的守护进程再次对该文件加锁时就会出错，然后退出进程。</p><p>详细代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/syslog.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;syslog.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define LOCKFILE &#34;/var/run/single_daemon.pid&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define LOCKMOD (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>lockfile</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>flock</span> <span class=n>fl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>fl</span><span class=p>.</span><span class=n>l_type</span> <span class=o>=</span> <span class=n>F_WRLCK</span><span class=p>;</span> <span class=c1>// 写锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fl</span><span class=p>.</span><span class=n>l_start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>fl</span><span class=p>.</span><span class=n>l_whence</span> <span class=o>=</span> <span class=n>SEEK_SET</span><span class=p>;</span> <span class=c1>// 从开始位置锁定
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fl</span><span class=p>.</span><span class=n>l_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_SETLK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fl</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>already_running</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=n>LOCKFILE</span><span class=p>,</span> <span class=n>O_RDWR</span> <span class=o>|</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=n>LOCKMOD</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>syslog</span><span class=p>(</span><span class=n>LOG_ERR</span><span class=p>,</span> <span class=s>&#34;can&#39;t open %s: %s&#34;</span><span class=p>,</span> <span class=n>LOCKFILE</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>errno</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>lockfile</span><span class=p>(</span><span class=n>fd</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EACCES</span> <span class=o>||</span> <span class=n>errno</span> <span class=o>==</span> <span class=n>EAGAIN</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>syslog</span><span class=p>(</span><span class=n>LOG_ERR</span><span class=p>,</span> <span class=s>&#34;can&#39;t lock %s: %s&#34;</span><span class=p>,</span> <span class=n>LOCKFILE</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=nf>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>syslog</span><span class=p>(</span><span class=n>LOG_ERR</span><span class=p>,</span> <span class=s>&#34;can&#39;t lock %s: %s&#34;</span><span class=p>,</span> <span class=n>LOCKFILE</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 文件长度截断为0的原因在于存在之前的守护进程的ID长度大于当前守护进程ID
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>ftruncate</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sprintf</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=nf>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>already_running</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>30</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当第二次启动该进程时，日志中会提示报错（删除了不相关的日志）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ tail -f syslog
</span></span><span class=line><span class=cl>2024-04-10T23:16:46.706011+08:00 ubuntu-server single_daemon: can<span class=err>&#39;</span>t lock /var/run/single_daemon.pid: Resource temporarily unavailable
</span></span></code></pre></div><h3 id=示例2><a href=#%e7%a4%ba%e4%be%8b2>示例2</a></h3><p>在该示例中，通过调用之前实现的函数<code>daemonize</code>将当前进程设置为守护进程，调用函数<code>already_running</code>保证仅有一个实例运行。</p><p>同时在单独的线程中捕捉<code>SIGHUP</code>与<code>SIGTERM</code>信号，当收到<code>SIGHUP</code>信号后重新读取配置文件，收到<code>SIGTERM</code>信号进程退出。</p><p>详细代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/resource.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/syslog.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;syslog.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>sigset_t</span> <span class=n>mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=nf>already_running</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>void</span> <span class=nf>daemonize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>reread</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 该函数用于重新读取配置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>syslog</span><span class=p>(</span><span class=n>LOG_INFO</span><span class=p>,</span> <span class=s>&#34;Read configuration file&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>thr_fn</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>err</span><span class=p>,</span> <span class=n>signo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;;)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>err</span> <span class=o>=</span> <span class=nf>sigwait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mask</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>syslog</span><span class=p>(</span><span class=n>LOG_ERR</span><span class=p>,</span> <span class=s>&#34;sigwait failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span> <span class=p>(</span><span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>SIGHUP</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 捕捉到SIGHUP信号，则重新读取配置
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>syslog</span><span class=p>(</span><span class=n>LOG_INFO</span><span class=p>,</span> <span class=s>&#34;Re-reading configuration file&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>reread</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>SIGTERM</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 收到SIGTERM信号则打印日志并退出进程
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>syslog</span><span class=p>(</span><span class=n>LOG_INFO</span><span class=p>,</span> <span class=s>&#34;got SIGTERM; exiting&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>                <span class=nf>syslog</span><span class=p>(</span><span class=n>LOG_INFO</span><span class=p>,</span> <span class=s>&#34;unexpected signal %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>tid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>cmd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sigaction</span> <span class=n>sa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>cmd</span> <span class=o>=</span> <span class=nf>strrchr</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=sc>&#39;/&#39;</span><span class=p>))</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cmd</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>cmd</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>daemonize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>already_running</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>syslog</span><span class=p>(</span><span class=n>LOG_ERR</span><span class=p>,</span> <span class=s>&#34;daemon already running&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 恢复SIGHUP信号的默认处理行为，这是因为daemonize中忽略了该信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>sa</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>SIG_DFL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sa</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sa</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGHUP</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sa</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>syslog</span><span class=p>(</span><span class=n>LOG_ERR</span><span class=p>,</span> <span class=s>&#34;can&#39;t restore SIGHUP default&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 在当前线程中阻塞所有信号，防止在信号处理线程调用sigwait之前信号被发送给当前线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sigfillset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>err</span> <span class=o>=</span> <span class=nf>pthread_sigmask</span><span class=p>(</span><span class=n>SIG_BLOCK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mask</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>syslog</span><span class=p>(</span><span class=n>LOG_ERR</span><span class=p>,</span> <span class=s>&#34;SIG_BLOCK error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建新线程处理信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>err</span> <span class=o>=</span> <span class=nf>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>thr_fn</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>syslog</span><span class=p>(</span><span class=n>LOG_ERR</span><span class=p>,</span> <span class=s>&#34;can&#39;t create thread&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>30</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 执行结果如下:
</span></span></span><span class=line><span class=cl><span class=c1>// $ ps -ef | grep readconfig*
</span></span></span><span class=line><span class=cl><span class=c1>// root       76681       1  0 23:13 ?        00:00:00 ./readconfig_daemon
</span></span></span><span class=line><span class=cl><span class=c1>// $ sudo kill -1 76681
</span></span></span><span class=line><span class=cl><span class=c1>// $ ps -ef | grep readconfig*
</span></span></span><span class=line><span class=cl><span class=c1>// root       76681       1  0 23:13 ?        00:00:00 ./readconfig_daemon
</span></span></span><span class=line><span class=cl><span class=c1>// $ sudo kill -15 76681
</span></span></span><span class=line><span class=cl><span class=c1>// $ ps -ef | grep readconfig*
</span></span></span><span class=line><span class=cl><span class=c1>// $
</span></span></span><span class=line><span class=cl><span class=c1>// 日志输出如下
</span></span></span><span class=line><span class=cl><span class=c1>// $ tail -f syslog
</span></span></span><span class=line><span class=cl><span class=c1>// 2024-04-11T23:14:15.303630+08:00 ubuntu-server readconfig_daemon: Re-reading configuration file
</span></span></span><span class=line><span class=cl><span class=c1>// 2024-04-11T23:14:15.303772+08:00 ubuntu-server readconfig_daemon: Read configuration file
</span></span></span><span class=line><span class=cl><span class=c1>// 2024-04-11T23:14:49.629462+08:00 ubuntu-server readconfig_daemon: got SIGTERM; exiting
</span></span></span></code></pre></div><p>在该示例中，信号处理线程通过在循环中调用<code>sigwait</code>来捕捉并处理信号。捕捉到<code>SIGHUP</code>信号则重新读取配置。</p><p>同时在设置单独线程捕捉<code>SIGHUP</code>信号之前，对所有信号都进行了阻塞，用以<strong>防止在调用<code>sigwait</code>函数之前的时间窗口中信号丢失或者被发送给当前线程而非专门的信号处理线程</strong>。</p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://DBL2017.github.io/>生如夏花</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br><div class=post-archive><h2>相关文章</h2><ul class=listing><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/>进程环境</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/>异常控制流</a></li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a href=/tags/%E8%BF%9B%E7%A8%8B>进程</a></li><li><a href=/tags/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B>守护进程</a></li><li><a href=/tags/%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B>后台进程</a></li><li><a href=/tags/%E5%87%BA%E9%94%99%E7%AE%A1%E7%90%86>出错管理</a></li></ul></div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=DBL2017/DBL2017.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></div></div></div><div class=content-right><div class=sidebar><section class=widget><form id=form-search action=https://DBL2017.github.io/search/ method=get accept-charset=utf-8 _lpchecked=1><input type=text name=q maxlength=20 placeholder=请输入查找关键字 required>
<button type=submit class=submit title=提交>
<svg t="1714448321870" class="icon" style="width:22px;height:22px" viewBox="0 0 1024 1024" p-id="1771" width="200" height="200"><path d="M781.9264 691.1232l236.928 236.9216-90.816 90.8032-236.9152-236.9216c-72.032 53.3568-161.184 84.9088-257.7088 84.9088C194.048 866.8352.0 672.7872.0 433.408.0 194.048 194.048.0 433.4144.0c239.3728.0 433.4208 194.048 433.4208 433.4144.0 96.5248-31.552 185.6768-84.9088 257.7088zm-348.512 47.2896c168.448.0 304.9984-136.5504 304.9984-304.9984s-136.5504-304.992-304.9984-304.992-304.992 136.5504-304.992 304.9856c0 168.448 136.5504 304.9984 304.992 304.9984z" fill="#4A4A4A" p-id="1772"/></svg></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/neovim/diagnostic/ title=Diagnostic>Diagnostic</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/libubox/uloop%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/ title=uloop源码剖析>uloop源码剖析</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/tikz%E7%BB%98%E5%88%B6%E6%8A%98%E7%BA%BF%E5%9B%BE/ title=TiKZ绘制折线图>TiKZ绘制折线图</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ubuntu18%E6%B0%B8%E4%B9%85%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%90%8D%E7%A7%B0/ title=Ubuntu18永久修改网络接口名称>Ubuntu18永久修改网络接口名称</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8Bdocumentclass/ title=LaTeX之documentclass>LaTeX之documentclass</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8Bctex%E5%AE%8F%E9%9B%86%E4%B9%8B%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%E7%B1%BB/ title=LaTeX之CTeX宏集之中文文档类>LaTeX之CTeX宏集之中文文档类</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8B%E4%B8%AD%E6%96%87%E6%94%AF%E6%8C%81/ title=LaTex之中文支持>LaTex之中文支持</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/dibbler-server%E7%9A%84dhcpv6-pd%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D56%E4%BD%8D%E5%89%8D%E7%BC%80/ title=dibbler-server的DHCPv6-PD如何分配56位前缀>dibbler-server的DHCPv6-PD如何分配56位前缀</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/ipv6%E8%BF%87%E6%B8%A1%E6%8A%80%E6%9C%AF/ipip%E9%9A%A7%E9%81%93%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/ title=IPIP隧道创建实例>IPIP隧道创建实例</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%B1%82/tcp%E4%B9%8Bmss%E5%AD%97%E6%AE%B5%E5%A4%87%E6%B3%A8/ title=TCP之MSS字段备注>TCP之MSS字段备注</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=https://DBL2017.github.io/categories/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/>传输协议 (17)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/>工具使用 (24)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/>开源三方 (2)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统 (14)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/>数字安全 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/>数据结构和算法 (5)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言 (14)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/>网络工程师 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记 (56)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/>问题排查 (5)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%BB%98%E8%AE%A4/>默认 (2)</a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://mermaid.live/ title=Mermaid>Mermaid 编辑</a></li><li><a target=_blank href=https://excalidraw.com/ title=EXCALIDRAW>Excalidraw 绘图</a></li><li><a target=_blank href=https://git-scm.com/docs title=Git命令参考手册>Git命令参考手册</a></li><li><a target=_blank href=https://www.gnu.org/software/make/manual/make.html title="GNU make官方文档">GNU make官方文档</a></li><li><a target=_blank href=https://www.emojiall.com/ title=Emojiall表情网站>Emojiall表情网站</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/index.xml>文章 RSS</a></li></ul></section></div></div></div><div class=container-footer><footer id=footer><div>&copy; 2025 <a href=https://DBL2017.github.io/>生如夏花 By
生如夏花</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>广电总局</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered
by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://DBL2017.github.io/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">生如夏花</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script src=/js/jquery.fancybox.min.min.7fa821ee946e58947030e5d007d358378119205e16b74ab4d0c60560a36d0414a775f9dbe0586ce12723c75cea8794fabadd1f33100a9ee22f6da3826256c0ef.js integrity="sha512-f6gh7pRuWJRwMOXQB9NYN4EZIF4Wt0q00MYFYKNtBBSndfnb4Fhs4Scjx1zqh5T6ut0fMxAKnuIvbaOCYlbA7w==" crossorigin=anonymous></script><a id=rocket href=#top></a><script src=/js/totop.min.8c7573186baa30f09c49b5cf3176c3b105785324d961b3d5c2f7f099d14673160a29aeebdec25909d046aa14936cd43451e17664662d518550d5e8998dbec670.js integrity="sha512-jHVzGGuqMPCcSbXPMXbDsQV4UyTZYbPVwvfwmdFGcxYKKa7r3sJZCdBGqhSTbNQ0UeF2ZGYtUYVQ1eiZjb7GcA==" crossorigin=anonymous></script><script src=/js/clipboard.min.0765794be1674926c1a3810afcf039f605f367cb11cef727ad49e6aa70f9fca0a37d329d64c55822896869eb0960763e73e085ee7675cbc497e4d3256a6e6a67.js integrity="sha512-B2V5S+FnSSbBo4EK/PA59gXzZ8sRzvcnrUnmqnD5/KCjfTKdZMVYIoloaesJYHY+c+CF7nZ1y8SX5NMlam5qZw==" crossorigin=anonymous></script><script>var spy=new Gumshoe("#TableOfContents a",{nested:!0,nestedClass:"active"})</script><script>hljs.highlightAll()</script></div></div></body></html>