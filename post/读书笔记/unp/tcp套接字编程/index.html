<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>TCP套接字编程 | 生如夏花</title><meta property="og:title" content="TCP套接字编程 - 生如夏花"><meta property="og:type" content="article"><meta property="article:published_time" content='2026-01-03T15:45:23+08:00'><meta property="article:modified_time" content='2026-01-03T15:45:23+08:00'><meta name=Keywords content="C语言,Linux系统开发,物联网,博客,项目管理,软件架构"><meta name=description content="TCP套接字编程"><meta name=author content><meta property="og:url" content="https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/unp/tcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css><link rel=stylesheet href=/css/badge.min.dc57f0a9d275742b1e2d17f204ae0b829361b5dd0df99d3d356615830fb223936c054d31a888c5f369975da90586601e2666ddbbbb36e98510b814a70826e874.css integrity="sha512-3FfwqdJ1dCseLRfyBK4LgpNhtd0N+Z09NWYVgw+yI5NsBU0xqIjF82mXXakFhmAeJmbdu7s26YUQuBSnCCbodA==" crossorigin=anonymous><link rel=stylesheet href=/css/header.min.9e74ad2f7e23fb54e2da3ef2f1eb6498897cd4139d181133b5e641f107980364ccfbcea731badb693b4a50819c388b6f8cab037346daf142114f86f14faa8766.css integrity="sha512-nnStL34j+1Ti2j7y8etkmIl81BOdGBEzteZB8QeYA2TM+86nMbrbaTtKUIGcOItvjKsDc0ba8UIRT4bxT6qHZg==" crossorigin=anonymous><link rel=stylesheet href=/css/table.min.c193c9134b7b9c6f88c84f2b6e189f1783056a6c6a7eab574e1ec8f1537bbbb4b3c44e130004fbb98e9e2f260c7485a74e96db4bd156e1f49a20013ab811e874.css integrity="sha512-wZPJE0t7nG+IyE8rbhifF4MFamxqfqtXTh7I8VN7u7SzxE4TAAT7uY6eLyYMdIWnTpbbS9FW4fSaIAE6uBHodA==" crossorigin=anonymous><link rel=stylesheet href=/css/baseof.min.5e04a6c8338c3c57aedaaae91320971e148651ac160d51bb58ebfec7757346a177331ac5646bbb1b2664b1c8cc405939125785c138935bc0d29a805b11791691.css integrity="sha512-XgSmyDOMPFeu2qrpEyCXHhSGUawWDVG7WOv+x3VzRqF3MxrFZGu7GyZkscjMQFk5EleFwTiTW8DSmoBbEXkWkQ==" crossorigin=anonymous><link rel=stylesheet href=/css/rocket.min.96a6be31cd3df9dcd4e7e131e9fcb0e63149da1da6a23df5ed8c8e0ccf0436f4c95aad5ded6a69e7fba5c051f8cc00466fcedaa07e4c7f59492d4a15aba2e936.css integrity="sha512-lqa+Mc09+dzU5+Ex6fyw5jFJ2h2moj317YyODM8ENvTJWq1d7Wpp5/ulwFH4zABGb87aoH5Mf1lJLUoVq6LpNg==" crossorigin=anonymous><link rel=stylesheet href=/css/toc.min.d258716c8e1217faa5525b82fb1a32c1980ba7419cb92684a219afc52bd8eb1034c9281e43ccd7bff11764339c91a03777eaa6d36e863f1c69a45fd05fbeaf7f.css integrity="sha512-0lhxbI4SF/qlUluC+xoywZgLp0GcuSaEohmvxSvY6xA0ySgeQ8zXv/EXZDOckaA3d+qm026GPxxppF/QX76vfw==" crossorigin=anonymous><link rel=stylesheet href=/css/clipboard.min.5e6a0198e50c850ced7dc2ba6f282ecaab21a8daad9eee626b990120818361b4b0007128d73957d5682346c88a6f9831f5872051e5f12da830cc29ca75676403.css integrity="sha512-XmoBmOUMhQztfcK6byguyqshqNqtnu5ia5kBIIGDYbSwAHEo1zlX1WgjRsiKb5gx9YcgUeXxLagwzCnKdWdkAw==" crossorigin=anonymous><link rel=stylesheet href=/css/style.min.578ca33085c2a1fbdbaa4560d60ba2988a35469db6220306455f1d0e84bece0a661501e6536fc84ccbf5b6cb795d5e9c177595804d5aa204861f80ff4003bd73.css integrity="sha512-V4yjMIXCofvbqkVg1guimIo1Rp22IgMGRV8dDoS+zgpmFQHmU2/ITMv1tst5XV6cF3WVgE1aogSGH4D/QAO9cw==" crossorigin=anonymous><link rel="shortcut icon" href=/img/favicon.png type=image/x-icon><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/vim.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/latex.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/dos.min.js></script><script src=/js/gumshoe.min.min.9dec1df0371d73b03324ed4bb78a6d5b2e84af6a37b11ce799808a26d70dfd156595f8d23c42db9e4866f12b4c0de664cfd032fa6f95bdaaada1bacdb235e79e.js integrity="sha512-newd8Dcdc7AzJO1Lt4ptWy6Er2o3sRznmYCKJtcN/RVllfjSPELbnkhm8StMDeZkz9Ay+m+VvaqtobrNsjXnng==" crossorigin=anonymous></script></head><body><div class=container><div class=container-header><header><div class=header-main><div class=header-site-name><a id=header-title href=https://DBL2017.github.io/>生如夏花</a><p class=description>专注于工业物联网行业数据采集，嵌入式Linux系统裁剪，5G智慧网关软件开发等</p></div><div class=header-menu><nav id=header-nav-menu><a href=https://DBL2017.github.io/>首页</a>
<a href=https://DBL2017.github.io/series/ title=系列>系列</a>
<a href=https://DBL2017.github.io/categories/ title=分类>分类</a>
<a href=https://DBL2017.github.io/tags/ title=标签>标签</a>
<a href=https://DBL2017.github.io/archives/ title=归档>归档</a>
<a href=https://DBL2017.github.io/about/ title=关于>关于</a></nav></div></div></header></div><div class=container-content><div class=content-center><div class=main-single><div class=single-toc><div class=post-toc><h2 class=post-toc-title><a href=#>目录</a></h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#socket>socket</a></li><li><a href=#connect>connect</a></li><li><a href=#bind>bind</a></li><li><a href=#listen>listen</a></li><li><a href=#accept>accept</a></li><li><a href=#fork和exec>fork和exec</a></li><li><a href=#close>close</a></li><li><a href=#getsockname和getpeername函数>getsockname和getpeername函数</a><ul><li><a href=#示例>示例</a></li></ul></li><li><a href=#示例-1>示例</a></li></ul></nav></div></div></div><div class=single-article><article class=post><header><h1 class=post-title>TCP套接字编程</h1></header><date class="post-meta meta-date"><span class=meta-category><a href=/archives/#2026>2026年1月3日</a></span></date><div class=post-meta><span>|</span>
<span class=meta-category><a href=/categories/#%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0>读书笔记</a></span></div><div class=post-meta><span>|</span>
<span class=meta-category><a href=/series/#UNP>UNP</a></span></div><div class=post-meta><span>|</span>
<span>共6613字</span></div><div class=post-meta><span>|</span>
<span>阅读时长(14分钟)</span></div><div class=clear style=display:none><div class=toc-article><div class=toc-title>文章目录</div></div></div><div class=post-content><p>TCP套接字编程函数流程如下图所示：</p><p><a data-fancybox=gallery href=%e5%9f%ba%e6%9c%acTCP%e5%ae%a2%e6%88%b7%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%a5%97%e6%8e%a5%e5%ad%97%e5%87%bd%e6%95%b0.svg><img class=mx-auto alt=基本TCP客户服务器程序的套接字函数 src=%e5%9f%ba%e6%9c%acTCP%e5%ae%a2%e6%88%b7%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%a5%97%e6%8e%a5%e5%ad%97%e5%87%bd%e6%95%b0.svg></a></p><h2 id=socket><a href=#socket>socket</a></h2><p>为了进行网络I/O，进程做的第一件事就是调用<code>socket</code>函数，指定期望的通信协议类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>socket</span><span class=p>(</span><span class=kt>int</span> <span class=n>family</span><span class=p>,</span> <span class=kt>int</span> <span class=n>type</span><span class=p>,</span> <span class=kt>int</span> <span class=n>protocol</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：成功则为非负的描述符，出错则为-1
</span></span></span></code></pre></div><p>参数<code>family</code>指明协议族，常见协议族如下：</p><table><thead><tr><th><code>family</code></th><th>说明</th></tr></thead><tbody><tr><td><code>AF_INET</code></td><td>IPv4协议</td></tr><tr><td><code>AF_INET6</code></td><td>IPv6协议</td></tr><tr><td><code>AF_LOCAL</code></td><td>Unix域协议</td></tr><tr><td><code>AF_ROUTE</code></td><td>路由套接字</td></tr></tbody></table><p>参数<code>type</code>指定套接字类型，常见套接字类型如下：</p><table><thead><tr><th><code>type</code></th><th>说明</th></tr></thead><tbody><tr><td><code>SOCK_STREAM</code></td><td>字节流套接字</td></tr><tr><td><code>SOCK_DGRAM</code></td><td>数据报套接字</td></tr><tr><td><code>SOCK_SEQPACKET</code></td><td>有序分组套接字</td></tr><tr><td><code>SOCK_RAW</code></td><td>原始套接字</td></tr></tbody></table><p>参数<code>protocol</code>用来指定协议类型，但常被设置为0，以选择给定<code>family</code>和<code>type</code>后的系统默认值。然而并非所有套接字的<code>family</code>和<code>type</code>的组合都是有效的，下面给出一些有效的组合和对应的协议（空白选项是无效组合，“是”表示是有效组合但无具体协议名称）。</p><table><thead><tr><th style=text-align:center>协议族/类型</th><th style=text-align:center><code>AF_INET</code></th><th style=text-align:center><code>AF_INET6</code></th><th style=text-align:center><code>AF_LOCAL</code></th><th style=text-align:center><code>AF_ROUTE</code></th></tr></thead><tbody><tr><td style=text-align:center><code>SOCK_STREAM</code></td><td style=text-align:center><code>TCP/SCTP</code></td><td style=text-align:center><code>TCP|SCTP</code></td><td style=text-align:center>是</td><td style=text-align:center></td></tr><tr><td style=text-align:center><code>SOCK_DGRAN</code></td><td style=text-align:center><code>UDP</code></td><td style=text-align:center><code>UDP</code></td><td style=text-align:center>是</td><td style=text-align:center></td></tr><tr><td style=text-align:center><code>SOCK_SEQPACKET</code></td><td style=text-align:center><code>SCTP</code></td><td style=text-align:center><code>SCTP</code></td><td style=text-align:center>是</td><td style=text-align:center></td></tr><tr><td style=text-align:center><code>SOCK_RAW</code></td><td style=text-align:center><code>IPv4</code></td><td style=text-align:center><code>IPv6</code></td><td style=text-align:center></td><td style=text-align:center>是</td></tr><tr><td style=text-align:center>为什么<code>protocol</code>参数常被设置为0呢？</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>最开始<code>AF_</code>前缀表示地址族，<code>PF_</code>前缀表示协议族，并且设计上单个协议族可以支持多个地址族，<code>PF_</code>值用来创建套接字，<code>AF_</code>值用于套接字地址结构。然而实际上，支持多个地址族的协议族从来都没有实现过，而且头文件<code>&lt;sys/socket.h></code>中为一给定协议定义的<code>PF_</code>值总是与该协议的<code>AF_</code>值相等，因此就默认采用<code>AF_</code>值了。</p><h2 id=connect><a href=#connect>connect</a></h2><p>TCP客户端使用<code>connect</code>函数建立与TCP服务器的连接。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>connect</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>servaddr</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：若连接建立成功则为0，若出错则为-1并设置errno
</span></span></span></code></pre></div><p>参数<code>sockfd</code>是由<code>socket</code>函数返回的套接字描述符。<code>servaddr</code>和<code>addrlen</code>分别是指向套接字地址结构的指针和该结构的大小。套接字地址结构必须包含服务器的IP地址和端口号。</p><p>客户端在调用<code>connect</code>函数之前无需调用<code>bind</code>函数，因为内核会确定源IP地址，并选择一个临时端口作为源端口。</p><p>如果是TCP套接字，<strong>调用<code>connect</code>函数会触发TCP的三路握手过程，而且仅在连接建立成功或出错时返回</strong>。</p><p><code>connect</code>函数调用后会发出SYN报文，服务器或网络对SYN报文的响应有如下结果：</p><table><thead><tr><th>场景</th><th>客户端收到对SYN报文的响应</th><th>客户端<code>connect()</code>返回值</th><th>常见<code>errno</code></th><th>含义说明</th></tr></thead><tbody><tr><td>正常连接</td><td>收到SYN+ACK，完成三次握手</td><td>0</td><td>无</td><td>连接成功</td></tr><tr><td>无响应</td><td>没有任何响应</td><td>-1</td><td><code>ETIMEDOUNT</code></td><td>TCP客户端未收到服务器对SYN报文的响应，默认Linux等待63s</td></tr><tr><td>端口未监听</td><td>RST</td><td>-1</td><td><code>ECONNREFUSED</code></td><td>服务器主机存在但是该端口上没有进程监听，无法建立连接</td></tr><tr><td>网络不可达</td><td>中间路由返回的ICMP网络不可达报文</td><td>-1</td><td><code>ENETUNREACH</code></td><td>网络不可达</td></tr><tr><td>主机不可达</td><td>中间路由返回的ICMP主机不可达报文</td><td>-1</td><td><code>EHOSTUNREACH</code></td><td>主机不可达</td></tr></tbody></table><p>在Linux的默认配置（<code>cat /proc/sys/net/ipv4/tcp_syn_retries</code>为6）下，如果<code>connect()</code>函数发出的SYN报文一直没有得到响应，它会按照指数退避的方式重传6次，总计大约63s（1+2+4+8+16+32=63）后才会返回错误。</p><p>从TCP状态图来看，<code>connect</code>函数会导致当前套接字从CLOSED状态转移到SYN_SENT状态，若成功在转移到ESTABLISHED状态。</p><p>如果<code>connect</code>函数失败，套接字必须关闭，不能用来再次调用<code>connect</code>函数。这是因为内核会标记该套接字为错误状态。</p><h2 id=bind><a href=#bind>bind</a></h2><p><code>bind</code>函数的作用是将一个本地协议地址赋予一个套接字。对于网际协议，协议地址是<strong>32位的IPv4地址或128位的IPv6地址</strong>与<strong>16位的TCP或UDP端口号</strong>的组合。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>bind</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：若成功则为0，失败则为-1并设置errno指示错误
</span></span></span></code></pre></div><p><code>addr</code>和<code>addrlen</code>参数分别是指向特定协议的套接字地址结构的指针和地址结构的长度。</p><p>调用<code>bind</code>函数可以同时指定端口号+IP地址，也可以都不指定，也可以指定其中任意一个。</p><p>对于端口号，服务器进程在启动时通常都会绑定它们公开的端口号，客户端进程一般不绑定端口号，在连接时有内核随即选择端口号。</p><p>对于IP地址，服务器或客户端进程都可以把一个特定的IP地址绑定到它的套接字上，前提是这个IP地址必须属于其所在主机的网络接口上。对于TCP客户端来说，这为在该套接字上发送的IP数据报指定了源IP地址。对于TCP服务器，这限定了该套接字仅接受目的地址为这个IP地址的客户端连接。</p><p><strong>TCP客户端通常不需要绑定IP地址到它的套接字上，当连接套接字时，内核会根据所用外出网络接口来选择源IP地址，而所用外出接口则取决于到达服务器所需的路径</strong>。</p><p><strong>TCP服务器通常会绑定统配地址和指定端口到它的套接字上，表示接收本机所有网卡上到达该端口的报文</strong>。</p><p><strong>如果TCP服务器没有绑定指定IP地址到其套接字上，那么内核就把客户端发送的SYN的目的IP地址当作服务器的源IP地址（在回包时）</strong>。</p><p>下表给出设置<code>sin_addr</code>和<code>sin_port</code>或<code>sin6_addr</code>和<code>sin6_port</code>的值产生的预期结果：</p><table><thead><tr><th>进程指定IP地址</th><th>进程指定端口号</th><th>结果</th></tr></thead><tbody><tr><td>通配地址</td><td>0</td><td>内核选择IP地址和端口</td></tr><tr><td>通配地址</td><td>非0</td><td>内核选择IP地址，进程指定端口</td></tr><tr><td>本地IP地址</td><td>0</td><td>进程指定IP地址，内核选择端口</td></tr><tr><td>本地IP地址</td><td>非0</td><td>进程指定IP地址和端口</td></tr></tbody></table><p>如果指定端口号为0，那么内核在<code>bind</code>函数调用时就会选择一个临时端口。如果指定IP地址为通配地址，那么内核要等到套接字已连接（TCP）或在该套接字上发出数据报（UDP）时才选择一个本地IP地址。</p><p>对于IPv4来说，通配地址通常为<code>INADDR_ANY</code>，用法如：<code>servaddr.sin_addr.s_addr=htonl(INADDR_ANY)</code>。</p><p>对于IPv6，系统会在头文件<code>&lt;netinet/in.h></code>中预先分配<code>in6addr_any</code>变量并将其初始化为常值<code>IN6ADDR_ANY_INIT</code>，用法为：<code>servaddr6.sin6_addr=in6addr_any</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// &lt;netinet/in.h&gt;中的定义如下
</span></span></span><span class=line><span class=cl><span class=k>extern</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>in6_addr</span> <span class=n>in6addr_any</span><span class=p>;</span>        <span class=cm>/* :: */</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>in6_addr</span> <span class=n>in6addr_loopback</span><span class=p>;</span>   <span class=cm>/* ::1 */</span>
</span></span><span class=line><span class=cl><span class=cp>#define IN6ADDR_ANY_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
</span></span></span><span class=line><span class=cl><span class=cp>#define IN6ADDR_LOOPBACK_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }
</span></span></span></code></pre></div><p>调用<code>bind</code>函数还有一点需要注意，如果让内核选择端口号，那么该函数是不会返回选择的端口号的。</p><h2 id=listen><a href=#listen>listen</a></h2><p>当使用<code>socket</code>函数创建一个套接字时，默认创建的套接字是主动套接字，即调用<code>connect</code>发起连接的套接字。</p><p><code>listen</code>函数<strong>把一个未连接的主动套接字转换为一个被动套接字，指示内核应该接受指向该套接字的连接请求</strong>，因此该函数仅由TCP服务器调用。调用<code>listen</code>函数会导致套接字从CLOSED状态切换为LISTEN状态。</p><p>从状态转换图可以看出，TCP连接从LISTEN状态切换到ESTABLISHED状态分为两个过程，分别是：</p><ol><li>TCP服务器接收到客户端发送的SYN并响应SYN+ACK，此时称为SYN_RCVD状态。</li><li>TCP服务器接收到客户端的ACK，此时称为ESTABLISTED状态。</li><li>这两种状态之间间隔时间为RTT。</li></ol><p>内核为一个给定的监听套接字的TCP连接各维护一个队列：</p><ol><li>为处于SYN_RCVD状态的TCP连接维护的队列称为<strong>半连接队列</strong>，其中存储的是轻量级的<code>request_sock</code>，对应SYN_RCVD状态。</li><li>为处于ESTABLISHED状态的TCP连接维护的队列称为<strong>全连接队列</strong>，其中存储的是完整的连接套接字（<code>struct sock</code>），对应ESTABLISHED状态。</li></ol><p>半连接队列中存储的只是处于握手中间态的请求对象。</p><p><a data-fancybox=gallery href=TCP%e4%b8%89%e8%b7%af%e6%8f%a1%e6%89%8b%e5%92%8c%e7%9b%91%e5%90%ac%e5%a5%97%e6%8e%a5%e5%ad%97%e7%9a%84%e4%b8%a4%e4%b8%aa%e9%98%9f%e5%88%97.svg><img class=mx-auto alt=TCP三路握手和监听套接字的两个队列 src=TCP%e4%b8%89%e8%b7%af%e6%8f%a1%e6%89%8b%e5%92%8c%e7%9b%91%e5%90%ac%e5%a5%97%e6%8e%a5%e5%ad%97%e7%9a%84%e4%b8%a4%e4%b8%aa%e9%98%9f%e5%88%97.svg></a></p><p>当来自TCP客户端的SYN到达时，内核在半连接队列中创建一个新项，然后响应三路握手的第2个分节：SYN+ACK。该项一直保留在半连接队列中，直到三路握手的第3个分节（客户端对服务器SYN的ACK）到达或该项超时为止。如果三路握手正常完成，该项就从半连接队列转移到全连接队列的队尾。</p><p>当进程调用<code>accept</code>函数时，全连接队列的对头项将返回给调用进程，或者如果该队列为空，那么进程将进入睡眠，直到TCP在该队列中放入一项才唤醒。</p><p>介绍完了上面的基础知识之后，下面给出<code>listen</code>函数的原型：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>listen</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>backlog</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：成功为0，失败为-1并设置对应的errno
</span></span></span></code></pre></div><p>参数说明：<code>sockfd</code>参数表示要转为监听的套接字。<code>backlog</code>参数表示全连接队列的长度。</p><p>为什么<code>backlog</code>表示全连接队列的长度而不是半连接队列的长度呢？内核对全连接队列的长度做出限制的原因在于，<strong>在监听某个给定套接字的应用进程停止接受连接的时候，防止内核在该套接字上继续接受新的连接</strong>。而把半连接交由内核处理，用来解决SYN泛洪攻击。</p><p>在Linux中，<code>backlog</code>参数用来限制全连接队列的长度（即等待<code>accept()</code>的ESTABLISHED的套接字数）。半连接队列的大小由内核参数（如<code>tcp_max_syn_backlog</code>）控制，不受<code>backlog</code>参数的影响。</p><ol><li>如果未启用<code>SYN cookies</code>（<code>net.ipv4.tcp_syncookies=0</code>），半连接队列已满时SYN会被丢弃，客户端只能重试。</li><li>如果启用了<code>SYN cookies</code>（<code>net.ipv4.tcp_syncookies=1</code>），半连接队列已满时，服务器不在分配半连接队列条目，但仍然会回复SYN+ACK，其中的初始序列号ISN会被特殊编码，当客户端返回ACK时会检查ACK中的确认号是否匹配之前发出的SYN cookie，如果匹配则直接在全连接队列中创建条目，等待<code>accept()</code>。</li></ol><p>SYN cookies的本质是使用序列号代替半连接存储，防御半连接队列溢出攻击，可以用来解决SYN泛洪攻击。</p><p>默认情况下Linux的半连接队列大小如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ cat /proc/sys/net/ipv4/tcp_max_syn_backlog
</span></span><span class=line><span class=cl><span class=m>512</span>
</span></span><span class=line><span class=cl>$ cat /proc/sys/net/ipv4/tcp_syncookies
</span></span><span class=line><span class=cl><span class=m>1</span>
</span></span></code></pre></div><h2 id=accept><a href=#accept>accept</a></h2><p><code>accept</code>函数用于从全连接队列中队头返回下一个已完成队列，因此只能被TCP服务器调用。如果全连接队列为空，那么调用进程<strong>默认阻塞</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>accept</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=o>*</span><span class=n>addrlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//返回值：成功为已连接套接字，出错为-1
</span></span></span></code></pre></div><p>参数说明：<code>sockfd</code>为<strong>监听套接字描述符</strong>，<code>addr</code>和<code>addrlen</code>参数用来返回已连接的对端进程的协议地址。<code>addrlen</code>表示返回时内核在<code>addr</code>套接字地址结构中存储的具体字节数。</p><p>返回值说明：如果<code>accept</code>函数调用成功，其返回值是由内核自动生成的一个全新描述符，代表与所返回客户端的TCP连接，被称为<strong>已连接套接字描述符</strong>。</p><p>对于监听套接字描述符而言，服务器进程通常仅仅创建一个，存在于服务器的整个生命周期。</p><p>对于已连接套接字描述符，内核为每个由服务器接受的客户端连接创建一个已连接套接字（全连接队列中存储就是已连接套接字）。当服务器完成对某个给定客户端的服务时，相应的已连接套接字就被关闭。</p><h2 id=fork和exec><a href=#fork%e5%92%8cexec>fork和exec</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>fork</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p><code>fork</code>函数是Unix中派生新进程的唯一方法。<code>fork</code>函数返回两次，在调用进程中返回一次，返回值是新派生的进程的进程ID；在子进程中返回一次，返回值为0。</p><p><code>fork</code>函数在子进程中返回0而不是父进程的进程ID的原因在于：<strong>任何子进程仅有一个父进程，而且子进程可以通过调用<code>getppid()</code>函数获取父进程的进程ID</strong>。父进程有许多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID，那么它必须记录每次调用<code>fork</code>的返回值。</p><p>父进程中调用<code>fork</code>之前打开的所有文件描述符在<code>fork</code>返回之后由子进程共享。</p><p><code>fork</code>函数的两个典型用法如下：</p><ol><li>一个进程创建自身的副本。这样每个副本都可以在其他副本执行其他任务处理各自的操作。网络服务器的典型用法。</li><li>一个进程想要执行另一个程序。既然创建新进程的唯一办法是<code>fork</code>，那么该进程首先调用<code>fork</code>创建自身的副本，然后其中一个副本调用<code>exec</code>把自身替换为新的程序。这是shell之类程序的典型用法。</li></ol><p><code>exec</code>函数共有六个，作用是把当前进程映像替换为新的程序，而且该新程序从<code>main</code>函数开始执行，进程ID不变</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>char</span> <span class=o>**</span><span class=n>environ</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span>	      <span class=nf>execl</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg</span><span class=p>,</span> <span class=p>...</span> <span class=cm>/*, (char *)</span> <span class=nb>NULL</span> <span class=err>*/</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span>	      <span class=nf>execlp</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg</span><span class=p>,</span> <span class=p>...</span> <span class=cm>/*, (char *)</span> <span class=nb>NULL</span> <span class=err>*/</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span>	      <span class=nf>execle</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg</span><span class=p>,</span> <span class=p>...</span> <span class=cm>/*, (char *)</span> <span class=nb>NULL</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>envp</span><span class=p>[]</span> <span class=err>*/</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span>	      <span class=nf>execv</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span>	      <span class=nf>execvp</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span>	      <span class=nf>execvpe</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span><span class=p>[],</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>envp</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span>	      <span class=nf>execve</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>_Nullable</span> <span class=n>argv</span><span class=p>[],</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>_Nullable</span> <span class=n>envp</span><span class=p>[]);</span>
</span></span></code></pre></div><p>这些函数中只有<code>execve</code>函数是内核的系统调用，其他函数都是<code>execve</code>函数的库函数。</p><p>6个<code>exec</code>函数之间的区别在于：</p><ol><li>待执行的程序文件是由文件名还是路径名指定。由p来决定，如果函数后缀中携带p，则使用当前的PATH环境变量把该文件名参数转换为一个路径名（前提是文件名参数中没有/）。</li><li>新程序的参数是一一列出还是由一个指针数组来引用。由l和v来决定，l表示参数一一列出，v表示使用<code>argv[]</code>。</li><li>把调用进程的环境传递给新程序还是给新程序指定新的环境。由e来决定，表示通过<code>envp[]</code>参数传入给新进程的环境变量。</li></ol><p><strong>这些函数只有在出错时才会返回给调用者</strong>。进程在调用<code>exec</code>之前打开的文件描述符通常跨<code>exec</code>继续保持打开，这个默认行为可以通过<code>fcntl</code>设置<code>FD_CLOEXEC</code>描述符标志禁止。</p><h2 id=close><a href=#close>close</a></h2><p><code>close</code>函数用来关闭套接字，并终止TCP连接。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>close</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：成功返回0，出错返回-1
</span></span></span></code></pre></div><p><code>close</code>关闭套接字的默认行为是将该套接字标记为已关闭，然后立即返回调用进程。内核TCP协议栈将尝试发送已排队等待发送到对端的任何数据，发送完毕之后是正常的TCP连接终止序列。</p><p>如果套接字的引用计数值大于0，那么<code>close</code>调用就不会引发TCP的四分组连接终止序列。如果想要在某个TCP连接上发送一个FIN，那么可以采用<code>shutdown</code>函数代替<code>close</code>函数。</p><h2 id=getsockname和getpeername函数><a href=#getsockname%e5%92%8cgetpeername%e5%87%bd%e6%95%b0>getsockname和getpeername函数</a></h2><p>这两个函数用于获取与某个套接字关联的本地协议地址（<code>getsockname</code>）或对端协议地址（<code>getpeername</code>），函数原型如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>getsockname</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>getpeername</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：成功为0，失败为-1并设置对应的errno
</span></span></span></code></pre></div><p><code>getsockname</code>函数的两个用途：</p><ol><li>在一个没有调用<code>bind</code>函数的TCP客户端上，<code>connect</code>函数成功返回后，<code>getsockname</code>函数用于返回由内核赋予该连接的本地IP地址和本地端口号。</li><li>在以端口号0调用<code>bind</code>函数（让内核自由选择本地端口号）后，<code>getsockname</code>函数用于返回内核赋予的本地端口号。</li></ol><p>当一个服务器是由调用过<code>accept</code>函数的某个进程通过调用<code>exec</code>执行程序产生的，它能够获取客户端身份的唯一途径就是调用<code>getpeername</code>。例如inetd进程<code>fork</code>并<code>exec</code>某个TCP服务器程序。</p><h3 id=示例><a href=#%e7%a4%ba%e4%be%8b>示例</a></h3><p>下面的例子给出了一个没有调用<code>bind</code>函数的TCP客户端，并在<code>connect</code>函数返回后，通过<code>getsockname</code>获取内核分配的IP地址和端口号。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;netinet/in.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;strings.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>		       <span class=n>connfd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>socklen_t</span>	       <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>servaddr</span><span class=p>,</span> <span class=n>cliaddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>time_t</span>	       <span class=n>ticks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>connfd</span> <span class=o>=</span> <span class=nf>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=n>IPPROTO_TCP</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>connfd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>perror</span><span class=p>(</span><span class=s>&#34;socket error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>bzero</span><span class=p>(</span><span class=o>&amp;</span><span class=n>servaddr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>servaddr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>servaddr</span><span class=p>.</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>servaddr</span><span class=p>.</span><span class=n>sin_port</span>	<span class=o>=</span> <span class=nf>htons</span><span class=p>(</span><span class=mi>13</span><span class=p>);</span>  <span class=c1>// host to network short
</span></span></span><span class=line><span class=cl>    <span class=nf>inet_pton</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=s>&#34;127.0.0.1&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>servaddr</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>connect</span><span class=p>(</span><span class=n>connfd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>servaddr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>servaddr</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>len</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>cliaddr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>getsockname</span><span class=p>(</span><span class=n>connfd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>cliaddr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s %d&#34;</span><span class=p>,</span> <span class=nf>inet_ntoa</span><span class=p>(</span><span class=n>cliaddr</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>),</span> <span class=nf>ntohs</span><span class=p>(</span><span class=n>cliaddr</span><span class=p>.</span><span class=n>sin_port</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出结果：127.0.0.1 56994
</span></span></span></code></pre></div><p>下面的示例用来获取套接字的协议族：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;netinet/in.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sockfd_to_family</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_storage</span> <span class=n>ss</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>socklen_t</span>		    <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>len</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ss</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>getsockname</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>ss</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ss</span><span class=p>.</span><span class=n>ss_family</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sockfd</span> <span class=o>=</span> <span class=nf>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_DGRAM</span><span class=p>,</span> <span class=n>IPPROTO_UDP</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;AF_INET=%d %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>AF_INET</span><span class=p>,</span> <span class=nf>sockfd_to_family</span><span class=p>(</span><span class=n>sockfd</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>sockfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sockfd</span> <span class=o>=</span> <span class=nf>socket</span><span class=p>(</span><span class=n>AF_INET6</span><span class=p>,</span> <span class=n>SOCK_DGRAM</span><span class=p>,</span> <span class=n>IPPROTO_UDP</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;AF_INET6=%d %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>AF_INET6</span><span class=p>,</span> <span class=nf>sockfd_to_family</span><span class=p>(</span><span class=n>sockfd</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>sockfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出：
</span></span></span><span class=line><span class=cl><span class=c1>// AF_INET=2 2
</span></span></span><span class=line><span class=cl><span class=c1>// AF_INET6=10 10
</span></span></span></code></pre></div><h2 id=示例-1><a href=#%e7%a4%ba%e4%be%8b-1>示例</a></h2><p>下面是一个典型的并发服务器的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;netinet/in.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;strings.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define MAXLINE 1024
</span></span></span><span class=line><span class=cl><span class=cp>#define LISTENQ 5
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span>	       <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>		       <span class=n>listenfd</span><span class=p>,</span> <span class=n>connfd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>socklen_t</span>	       <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>servaddr</span><span class=p>,</span> <span class=n>cliaddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 创建套接字
</span></span></span><span class=line><span class=cl>    <span class=n>listenfd</span> <span class=o>=</span> <span class=nf>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=n>IPPROTO_TCP</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>listenfd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>perror</span><span class=p>(</span><span class=s>&#34;socket error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 绑定监听套接字到服务器地址
</span></span></span><span class=line><span class=cl>    <span class=nf>bzero</span><span class=p>(</span><span class=o>&amp;</span><span class=n>servaddr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>servaddr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>servaddr</span><span class=p>.</span><span class=n>sin_family</span>	     <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>servaddr</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=nf>htonl</span><span class=p>(</span><span class=n>INADDR_ANY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>servaddr</span><span class=p>.</span><span class=n>sin_port</span>	     <span class=o>=</span> <span class=nf>htons</span><span class=p>(</span><span class=mi>13</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>bind</span><span class=p>(</span><span class=n>listenfd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>servaddr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>servaddr</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>perror</span><span class=p>(</span><span class=s>&#34;bind error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 将套接字转换为被动监听套接字，指示内核接收该套接字上的连接
</span></span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>listen</span><span class=p>(</span><span class=n>listenfd</span><span class=p>,</span> <span class=n>LISTENQ</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>perror</span><span class=p>(</span><span class=s>&#34;listen error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;;)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 4. 接收连接，并使用cliaddr接收对端地址
</span></span></span><span class=line><span class=cl>	<span class=n>connfd</span> <span class=o>=</span> <span class=nf>accept</span><span class=p>(</span><span class=n>listenfd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>cliaddr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>connfd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>	    <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;accept error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	    <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 5.在子进程中接收处理业务
</span></span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>	    <span class=nf>close</span><span class=p>(</span><span class=n>listenfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	    <span class=cm>/* 处理业务 */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	    <span class=cm>/* 关闭已连接套接字，并非必须，因为exit之后所有套接字都会被关闭 */</span>
</span></span><span class=line><span class=cl>	    <span class=nf>close</span><span class=p>(</span><span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	    <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>close</span><span class=p>(</span><span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在上面的示例中父进程<code>close</code>已连接套接字并不会终止与客户端的连接，这是因为每个文件或套接字都有一个引用计数，维护在文件表项中。</p><p><code>socket</code>函数返回后，与<code>listenfd</code>关联的文件表项的引用计数值为1，<code>accept</code>函数返回后与<code>connfd</code>关联的文件表项的引用计数值为1。然而<code>fork</code>返回后，这两个描述符在父子进程间共享，因此与这两个套接字关联的文件表项的引用计数值为2。父进程关闭<code>connfd</code>，只是把相应的引用计数值从2减到1。</p><p>该套接字真正的清理和资源释放要等到其引用计数达到0时才发生，这会在稍后子进程也关闭<code>connfd</code>时发生。</p><p>如果父进程对每个调用<code>accept</code>返回的已连接套接字都不调用<code>close</code>函数，那么会造成什么结果？</p><ol><li>父进程会耗尽可用描述符。</li><li>没有一个客户端的连接会被终止。</li></ol></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://DBL2017.github.io/>生如夏花</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/unp/tcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/unp/tcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br><div class=post-archive><h2>相关文章</h2><ul class=listing><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/unp/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E7%A1%80/>套接字基础</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/apue/unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/>UNIX域套接字</a></li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a href=/tags/%E5%A5%97%E6%8E%A5%E5%AD%97>套接字</a></li><li><a href=/tags/connect>connect</a></li><li><a href=/tags/listen>listen</a></li><li><a href=/tags/getsockname>getsockname</a></li><li><a href=/tags/getpeername>getpeername</a></li><li><a href=/tags/socket>socket</a></li></ul></div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=DBL2017/DBL2017.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></div></div></div><div class=content-right><div class=sidebar><section class=widget><form id=form-search action=https://DBL2017.github.io/search/ method=get accept-charset=utf-8 _lpchecked=1><input type=text name=q maxlength=20 placeholder=请输入查找关键字 required>
<button type=submit class=submit title=提交>
<svg t="1714448321870" class="icon" style="width:22px;height:22px" viewBox="0 0 1024 1024" p-id="1771" width="200" height="200"><path d="M781.9264 691.1232l236.928 236.9216-90.816 90.8032-236.9152-236.9216c-72.032 53.3568-161.184 84.9088-257.7088 84.9088C194.048 866.8352.0 672.7872.0 433.408.0 194.048 194.048.0 433.4144.0c239.3728.0 433.4208 194.048 433.4208 433.4144.0 96.5248-31.552 185.6768-84.9088 257.7088zm-348.512 47.2896c168.448.0 304.9984-136.5504 304.9984-304.9984s-136.5504-304.992-304.9984-304.992-304.992 136.5504-304.992 304.9856c0 168.448 136.5504 304.9984 304.992 304.9984z" fill="#4A4A4A" p-id="1772"/></svg></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/unp/tcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/ title=TCP套接字编程>TCP套接字编程</a></li><li><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/unp/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E7%A1%80/ title=套接字基础>套接字基础</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/windowsterminal%E9%85%8D%E7%BD%AE/ title=WindowsTerminal配置>WindowsTerminal配置</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%BF%98%E8%AE%B0ubuntu14.04%E7%9A%84%E7%99%BB%E5%BD%95%E8%B4%A6%E5%AF%86%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/ title=记录一次忘记Ubuntu14.04的登录账密的处理方式>记录一次忘记Ubuntu14.04的登录账密的处理方式</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/neovim/diagnostic/ title=Diagnostic>Diagnostic</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/libubox/uloop%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/ title=uloop源码剖析>uloop源码剖析</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/tikz%E7%BB%98%E5%88%B6%E6%8A%98%E7%BA%BF%E5%9B%BE/ title=TiKZ绘制折线图>TiKZ绘制折线图</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ubuntu18%E6%B0%B8%E4%B9%85%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%90%8D%E7%A7%B0/ title=Ubuntu18永久修改网络接口名称>Ubuntu18永久修改网络接口名称</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8Bdocumentclass/ title=LaTeX之documentclass>LaTeX之documentclass</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8Bctex%E5%AE%8F%E9%9B%86%E4%B9%8B%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%E7%B1%BB/ title=LaTeX之CTeX宏集之中文文档类>LaTeX之CTeX宏集之中文文档类</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=https://DBL2017.github.io/categories/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/>传输协议 (17)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/>工具使用 (25)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/>开源三方 (2)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统 (14)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/>数字安全 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/>数据结构和算法 (5)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言 (14)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/>网络工程师 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记 (58)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/>问题排查 (6)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%BB%98%E8%AE%A4/>默认 (2)</a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://mermaid.live/ title=Mermaid>Mermaid 编辑</a></li><li><a target=_blank href=https://excalidraw.com/ title=EXCALIDRAW>Excalidraw 绘图</a></li><li><a target=_blank href=https://git-scm.com/docs title=Git命令参考手册>Git命令参考手册</a></li><li><a target=_blank href=https://www.gnu.org/software/make/manual/make.html title="GNU make官方文档">GNU make官方文档</a></li><li><a target=_blank href=https://www.emojiall.com/ title=Emojiall表情网站>Emojiall表情网站</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/index.xml>文章 RSS</a></li></ul></section></div></div></div><div class=container-footer><footer id=footer><div>&copy; 2026 <a href=https://DBL2017.github.io/>生如夏花 By
生如夏花</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>广电总局</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered
by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://DBL2017.github.io/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">生如夏花</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script src=/js/jquery.fancybox.min.min.65c12100ca45d31006ad262cbdfa339fe0849703b18dfd74dd0156de627f0a1dc42eba3364e03876562117d2fa7722d8153cee03bdf747264c3c029102e154f6.js integrity="sha512-ZcEhAMpF0xAGrSYsvfozn+CElwOxjf103QFW3mJ/Ch3ELrozZOA4dlYhF9L6dyLYFTzuA733RyZMPAKRAuFU9g==" crossorigin=anonymous></script><a id=rocket href=#top></a><script src=/js/totop.min.8c7573186baa30f09c49b5cf3176c3b105785324d961b3d5c2f7f099d14673160a29aeebdec25909d046aa14936cd43451e17664662d518550d5e8998dbec670.js integrity="sha512-jHVzGGuqMPCcSbXPMXbDsQV4UyTZYbPVwvfwmdFGcxYKKa7r3sJZCdBGqhSTbNQ0UeF2ZGYtUYVQ1eiZjb7GcA==" crossorigin=anonymous></script><script src=/js/clipboard.min.0765794be1674926c1a3810afcf039f605f367cb11cef727ad49e6aa70f9fca0a37d329d64c55822896869eb0960763e73e085ee7675cbc497e4d3256a6e6a67.js integrity="sha512-B2V5S+FnSSbBo4EK/PA59gXzZ8sRzvcnrUnmqnD5/KCjfTKdZMVYIoloaesJYHY+c+CF7nZ1y8SX5NMlam5qZw==" crossorigin=anonymous></script><script>var spy=new Gumshoe("#TableOfContents a",{nested:!0,nestedClass:"active"})</script><script>hljs.highlightAll()</script></div></div></body></html>