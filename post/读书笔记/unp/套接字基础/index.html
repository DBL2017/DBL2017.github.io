<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>套接字基础 | 生如夏花</title><meta property="og:title" content="套接字基础 - 生如夏花"><meta property="og:type" content="article"><meta property="article:published_time" content='2026-01-01T19:38:50+08:00'><meta property="article:modified_time" content='2026-01-01T19:38:50+08:00'><meta name=Keywords content="C语言,Linux系统开发,物联网,博客,项目管理,软件架构"><meta name=description content="套接字地址结构的传递既有用户态到内核态（如bind函数）也有内核态传递到用户态（如accept函数），对于应用程序来说，传给内核的套接字地址结构需要类型强制转换为struct sockaddr*，而接收内核传出的套接字地址结构时需要采用struct sockaddr_storage*。对于ASCII字符串格式的地址转换建议有线采用inet_pton和inet_ntop这两个函数，因为同时兼容IPv4和IPv6。"><meta name=author content><meta property="og:url" content="https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/unp/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E7%A1%80/"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css><link rel=stylesheet href=/css/badge.min.dc57f0a9d275742b1e2d17f204ae0b829361b5dd0df99d3d356615830fb223936c054d31a888c5f369975da90586601e2666ddbbbb36e98510b814a70826e874.css integrity="sha512-3FfwqdJ1dCseLRfyBK4LgpNhtd0N+Z09NWYVgw+yI5NsBU0xqIjF82mXXakFhmAeJmbdu7s26YUQuBSnCCbodA==" crossorigin=anonymous><link rel=stylesheet href=/css/header.min.9e74ad2f7e23fb54e2da3ef2f1eb6498897cd4139d181133b5e641f107980364ccfbcea731badb693b4a50819c388b6f8cab037346daf142114f86f14faa8766.css integrity="sha512-nnStL34j+1Ti2j7y8etkmIl81BOdGBEzteZB8QeYA2TM+86nMbrbaTtKUIGcOItvjKsDc0ba8UIRT4bxT6qHZg==" crossorigin=anonymous><link rel=stylesheet href=/css/table.min.c193c9134b7b9c6f88c84f2b6e189f1783056a6c6a7eab574e1ec8f1537bbbb4b3c44e130004fbb98e9e2f260c7485a74e96db4bd156e1f49a20013ab811e874.css integrity="sha512-wZPJE0t7nG+IyE8rbhifF4MFamxqfqtXTh7I8VN7u7SzxE4TAAT7uY6eLyYMdIWnTpbbS9FW4fSaIAE6uBHodA==" crossorigin=anonymous><link rel=stylesheet href=/css/baseof.min.5e04a6c8338c3c57aedaaae91320971e148651ac160d51bb58ebfec7757346a177331ac5646bbb1b2664b1c8cc405939125785c138935bc0d29a805b11791691.css integrity="sha512-XgSmyDOMPFeu2qrpEyCXHhSGUawWDVG7WOv+x3VzRqF3MxrFZGu7GyZkscjMQFk5EleFwTiTW8DSmoBbEXkWkQ==" crossorigin=anonymous><link rel=stylesheet href=/css/rocket.min.96a6be31cd3df9dcd4e7e131e9fcb0e63149da1da6a23df5ed8c8e0ccf0436f4c95aad5ded6a69e7fba5c051f8cc00466fcedaa07e4c7f59492d4a15aba2e936.css integrity="sha512-lqa+Mc09+dzU5+Ex6fyw5jFJ2h2moj317YyODM8ENvTJWq1d7Wpp5/ulwFH4zABGb87aoH5Mf1lJLUoVq6LpNg==" crossorigin=anonymous><link rel=stylesheet href=/css/toc.min.d258716c8e1217faa5525b82fb1a32c1980ba7419cb92684a219afc52bd8eb1034c9281e43ccd7bff11764339c91a03777eaa6d36e863f1c69a45fd05fbeaf7f.css integrity="sha512-0lhxbI4SF/qlUluC+xoywZgLp0GcuSaEohmvxSvY6xA0ySgeQ8zXv/EXZDOckaA3d+qm026GPxxppF/QX76vfw==" crossorigin=anonymous><link rel=stylesheet href=/css/clipboard.min.5e6a0198e50c850ced7dc2ba6f282ecaab21a8daad9eee626b990120818361b4b0007128d73957d5682346c88a6f9831f5872051e5f12da830cc29ca75676403.css integrity="sha512-XmoBmOUMhQztfcK6byguyqshqNqtnu5ia5kBIIGDYbSwAHEo1zlX1WgjRsiKb5gx9YcgUeXxLagwzCnKdWdkAw==" crossorigin=anonymous><link rel=stylesheet href=/css/style.min.578ca33085c2a1fbdbaa4560d60ba2988a35469db6220306455f1d0e84bece0a661501e6536fc84ccbf5b6cb795d5e9c177595804d5aa204861f80ff4003bd73.css integrity="sha512-V4yjMIXCofvbqkVg1guimIo1Rp22IgMGRV8dDoS+zgpmFQHmU2/ITMv1tst5XV6cF3WVgE1aogSGH4D/QAO9cw==" crossorigin=anonymous><link rel="shortcut icon" href=/img/favicon.png type=image/x-icon><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/vim.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/latex.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/dos.min.js></script><script src=/js/gumshoe.min.min.9dec1df0371d73b03324ed4bb78a6d5b2e84af6a37b11ce799808a26d70dfd156595f8d23c42db9e4866f12b4c0de664cfd032fa6f95bdaaada1bacdb235e79e.js integrity="sha512-newd8Dcdc7AzJO1Lt4ptWy6Er2o3sRznmYCKJtcN/RVllfjSPELbnkhm8StMDeZkz9Ay+m+VvaqtobrNsjXnng==" crossorigin=anonymous></script></head><body><div class=container><div class=container-header><header><div class=header-main><div class=header-site-name><a id=header-title href=https://DBL2017.github.io/>生如夏花</a><p class=description>专注于工业物联网行业数据采集，嵌入式Linux系统裁剪，5G智慧网关软件开发等</p></div><div class=header-menu><nav id=header-nav-menu><a href=https://DBL2017.github.io/>首页</a>
<a href=https://DBL2017.github.io/series/ title=系列>系列</a>
<a href=https://DBL2017.github.io/categories/ title=分类>分类</a>
<a href=https://DBL2017.github.io/tags/ title=标签>标签</a>
<a href=https://DBL2017.github.io/archives/ title=归档>归档</a>
<a href=https://DBL2017.github.io/about/ title=关于>关于</a></nav></div></div></header></div><div class=container-content><div class=content-center><div class=main-single><div class=single-toc><div class=post-toc><h2 class=post-toc-title><a href=#>目录</a></h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#套接字地址结构>套接字地址结构</a><ul><li><a href=#ipv4>IPv4</a></li><li><a href=#通用地址结构>通用地址结构</a></li><li><a href=#ipv6>IPv6</a></li><li><a href=#通用存储套接字地址结构>通用存储套接字地址结构</a></li></ul></li><li><a href=#字节序函数>字节序函数</a></li><li><a href=#地址转换函数>地址转换函数</a></li><li><a href=#常用函数封装>常用函数封装</a></li></ul></nav></div></div></div><div class=single-article><article class=post><header><h1 class=post-title>套接字基础</h1></header><date class="post-meta meta-date"><span class=meta-category><a href=/archives/#2026>2026年1月1日</a></span></date><div class=post-meta><span>|</span>
<span class=meta-category><a href=/categories/#%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0>读书笔记</a></span></div><div class=post-meta><span>|</span>
<span class=meta-category><a href=/series/#UNP>UNP</a></span></div><div class=post-meta><span>|</span>
<span>共4821字</span></div><div class=post-meta><span>|</span>
<span>阅读时长(10分钟)</span></div><div class=clear style=display:none><div class=toc-article><div class=toc-title>文章目录</div></div></div><div class=post-content><p>套接字地址结构的传递既有用户态到内核态（如<code>bind</code>函数）也有内核态传递到用户态（如<code>accept</code>函数），对于应用程序来说，传给内核的套接字地址结构需要类型强制转换为<code>struct sockaddr*</code>，而接收内核传出的套接字地址结构时需要采用<code>struct sockaddr_storage*</code>。</p><p>对于ASCII字符串格式的地址转换建议有线采用<code>inet_pton</code>和<code>inet_ntop</code>这两个函数，因为同时兼容IPv4和IPv6。</p><h2 id=套接字地址结构><a href=#%e5%a5%97%e6%8e%a5%e5%ad%97%e5%9c%b0%e5%9d%80%e7%bb%93%e6%9e%84>套接字地址结构</a></h2><p>大多数套接字函数都需要一个指向套接字地址结构的指针作为参数。</p><p>每个协议族都定义了它自己的套接字地址结构。这些结构的名称均以<code>sockaddr_</code>开头，并以对应每个协议族的唯一后缀结尾。</p><p>在BSD系列的系统中，套接字地址结构中都存在一个<code>len</code>字段，用于避免依赖外部参数，而在Linux系统中，采用的是单独的<code>socklen_t</code>类型的函数参数来表示套接字长度。</p><h3 id=ipv4><a href=#ipv4>IPv4</a></h3><p>网际套接字地址结构，定义在<code>&lt;netinet/in.h></code>头文件中，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Internet address.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint32_t</span>   <span class=kt>in_addr_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cm>/* Type to represent a port.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint16_t</span>   <span class=kt>in_port_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cm>/* POSIX.1g specifies this type name for the `sa_family&#39; member.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=kt>short</span> <span class=kt>int</span> <span class=kt>sa_family_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>in_addr</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>in_addr_t</span> <span class=n>s_addr</span><span class=p>;</span> <span class=cm>/* 32 bit IPv4 address. network byte ordered */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=cm>/* Structure describing an Internet socket address.  */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_in</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sa_family_t</span>	   <span class=n>sa_family</span><span class=p>;</span>	<span class=cm>/* AF_INET */</span>
</span></span><span class=line><span class=cl>    <span class=kt>in_port_t</span>	   <span class=n>sin_port</span><span class=p>;</span>	<span class=cm>/* 16 bit TCP or UDP Port number.  network byte ordered*/</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>in_addr</span> <span class=n>sin_addr</span><span class=p>;</span>	<span class=cm>/* 32 bit IPv4 address.  network byte ordered*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>sin_zero</span><span class=p>[</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span><span class=p>)</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>short</span> <span class=kt>int</span><span class=p>)</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>in_port_t</span><span class=p>)</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>in_addr</span><span class=p>)];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>POSIX规范只需要该结构中的3个字段：<code>sin_family</code>、<code>sin_addr</code>和<code>sin_port</code>。但几乎所有的实现都增加了<code>sin_zero</code>字段，所有所有的套接字地址结构大小都至少是16字节。</p><p>对于该结构中的<code>sin_prot</code>和<code>sin_addr</code>都是以网络字节序存储。</p><p>为什么<code>sin_addr</code>是一个结构体，而不是一个<code>in_addr_t</code>类型的无符号整型变量呢？这是因为早期的<code>in_addr</code>被定义为多种结构的union，允许访问32位IPv4地址中的所有4个字节，或者2个16位的值，用在IPv4地址被划分为A、B、C类地址时期。由于子网地址划分方式的升级和无类别域间路由的出现，各种地址类正在消失，union结构不在被需要。</p><p>套接字地址结构仅在戈丁主机上使用，虽然地址和端口口字段用在不同主机之间的通信，但是地址本身不在主机间传递。</p><h3 id=通用地址结构><a href=#%e9%80%9a%e7%94%a8%e5%9c%b0%e5%9d%80%e7%bb%93%e6%9e%84>通用地址结构</a></h3><p>当套接字地址结构以指针形式作为参数之一传入到任何套接字函数时，支持协议族的套接字函数就必须能够处理对应协议族的套接字地址结构。例如<code>bind</code>函数支持<code>AF_INET</code>和<code>AF_INET6</code>两种协议族，那么该函数就需要能够处理这两种协议族对应的套接字地址结构。</p><p>当时是如何声明这个指针的数据类型的呢？因为套接字函数出现在ANSI C之后，无法使用其中提供的void类型。因此当时采用的办法是在<code>&lt;sys/socket.h></code>头文件中定义一个通用的套接字地址结构，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Structure describing a generic socket address.  */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sa_family_t</span> <span class=n>sa_family</span><span class=p>;</span>   <span class=cm>/* Common data: address family and length.  */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>	<span class=n>sa_data</span><span class=p>[</span><span class=mi>14</span><span class=p>];</span> <span class=cm>/* Address data.  */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>于是套接字函数被定义为<strong>以指向通用套接字地址结构的一个指针</strong>作为其参数之一，例如<code>bind</code>函数的ANSI C函数原型所示：<code>extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len);</code></p><p>因此对这些套接字函数的任何调用都必须要将指向特定于协议的套接字地址结构的指针进行类型强制转换，变成指向通用套接字地址结构的指针。</p><p>从应用程序开发的角度来看，这个通用套接字地址结构的唯一用途就是对指向特定于协议的套接字地址结构的指针执行类型强制转换。从内核的调度看，内核必须取调用者的指针，把它类型强制转换为<code>struct sockaddr*</code>类型，然后检查其中<code>sa_family</code>字段的值来去顶这个结构的真实类型。</p><h3 id=ipv6><a href=#ipv6>IPv6</a></h3><p>IPv6的套接字地址结构在<code>&lt;netinet/in.h></code>头文件中定义，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* POSIX.1g specifies this type name for the `sa_family&#39; member.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=kt>short</span> <span class=kt>int</span> <span class=kt>sa_family_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cm>/* Type to represent a port.  */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint16_t</span>	   <span class=kt>in_port_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cm>/* IPv6 address */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>in6_addr</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=kt>uint8_t</span>	 <span class=n>u6_addr8</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    	<span class=kt>uint16_t</span> <span class=n>u6_addr16</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    	<span class=kt>uint32_t</span> <span class=n>u6_addr32</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>in6_u</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#define s6_addr in6_u.u6_addr8
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_in6</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sa_family_t</span>	    <span class=n>sin6_family</span><span class=p>;</span>    <span class=c1>// 地址族，必须为 AF_INET6
</span></span></span><span class=line><span class=cl>    <span class=kt>in_port_t</span>	    <span class=n>sin6_port</span><span class=p>;</span>	    <span class=c1>// 端口号（网络字节序）
</span></span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span>	    <span class=n>sin6_flowinfo</span><span class=p>;</span>  <span class=c1>// IPv6 流信息（QoS/流标签）
</span></span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>in6_addr</span> <span class=n>sin6_addr</span><span class=p>;</span>	    <span class=c1>// IPv6 地址结构
</span></span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span>	    <span class=n>sin6_scope_id</span><span class=p>;</span>  <span class=c1>// 作用域 ID（如链路本地地址的接口索引）
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>#define s6_addr in6_u.u6_addr8</code>这个宏的作用是可以使用<code>sin6_addr.s6_addr</code>来访问IPv6地址，和IPv4的<code>sin_addr.s_addr</code>保持风格一致。</p><p><code>sin6_flowinfo</code>字段可以用来设置自定义流标签支持QoS功能，<code>sin6_scope_id</code>可以用来指定在特定接口上使用链路本地地址进行通信，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>addr</span><span class=p>.</span><span class=n>sin6_family</span>   <span class=o>=</span> <span class=n>AF_INET6</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>addr</span><span class=p>.</span><span class=n>sin6_port</span>     <span class=o>=</span> <span class=nf>htons</span><span class=p>(</span><span class=mi>8080</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>addr</span><span class=p>.</span><span class=n>sin6_flowinfo</span> <span class=o>=</span> <span class=nf>htonl</span><span class=p>(</span><span class=mh>0x12345</span><span class=p>);</span>  <span class=c1>// 设置流标签
</span></span></span><span class=line><span class=cl><span class=nf>inet_pton</span><span class=p>(</span><span class=n>AF_INET6</span><span class=p>,</span> <span class=s>&#34;fe80::1&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addr</span><span class=p>.</span><span class=n>sin6_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>addr</span><span class=p>.</span><span class=n>sin6_scope_id</span> <span class=o>=</span> <span class=nf>if_nametoindex</span><span class=p>(</span><span class=s>&#34;eth0&#34;</span><span class=p>);</span>  <span class=c1>// 指定链路本地接口
</span></span></span></code></pre></div><p>为什么会有<code>sin6_scope_id</code>这个字段呢？在IPv4上以<code>169.254.x.x</code>开头的链路本地地址在主机范围内是唯一的，指定了链路本地地址，内核就可以确定使用哪个接口进行通信。然而IPv6没有这个要求，主机范围内以<code>FE80</code>开头的链路本地地址可以重复（仅需要在链路上唯一），内核无法去推断使用哪个接口通信，因此需要该字段明确指出。</p><h3 id=通用存储套接字地址结构><a href=#%e9%80%9a%e7%94%a8%e5%ad%98%e5%82%a8%e5%a5%97%e6%8e%a5%e5%ad%97%e5%9c%b0%e5%9d%80%e7%bb%93%e6%9e%84>通用存储套接字地址结构</a></h3><p><code>struct sockaddr_storage</code>是一个通用的套接字地址结构，可以容纳所有类型的<code>sockaddr_*</code>结构。定义在<code>&lt;sys/socket.h></code>头文件中，所辖所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_storage</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sa_family_t</span>	      <span class=n>ss_family</span><span class=p>;</span>  <span class=cm>/* Address family, etc.  */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>	      <span class=n>__ss_padding</span><span class=p>[</span><span class=n>_SS_PADSIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span> <span class=n>__ss_align</span><span class=p>;</span> <span class=cm>/* Force desired alignment.  */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>struct sockaddr_storage</code>结构主要用来解决如下几个问题：</p><ol><li>套接字API（例如<code>accept()</code>、<code>recvfrom()</code>）返回的地址类型不确定，可能是IPv4（<code>struct sockaddr_in</code>）、IPv6（<code>struct sockaddr_in6</code>），甚至是其他协议族。<code>struct sockaddr_storage</code>提供一个统一的容器来接收这些地址。</li><li>传统的<code>struct sockaddr</code>结构太小（只有16字节），无法存放IPv6地址，<code>struct sockaddr_storage</code>足够大，可以避免缓冲区溢出。</li><li>不同平台对结构体对齐要求不同。<code>struct sockaddr_storage</code>内部通过填充和对齐字段，可以确保跨平台访问安全。</li><li><code>struct sockaddr_storage</code>可以写出协议无关的代码，避免硬编码具体结构大小。</li></ol><p>使用方法如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_storage</span> <span class=n>ss</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>socklen_t</span>		    <span class=n>addrlen</span>   <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ss</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>			    <span class=n>client_fd</span> <span class=o>=</span> <span class=nf>accept</span><span class=p>(</span><span class=n>server_fd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>ss</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addrlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ss</span><span class=p>.</span><span class=n>ss_family</span> <span class=o>==</span> <span class=n>AF_INET</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span><span class=n>addr4</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>ss</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 处理 IPv4 地址
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>ss</span><span class=p>.</span><span class=n>ss_family</span> <span class=o>==</span> <span class=n>AF_INET6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=o>*</span><span class=n>addr6</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>ss</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 处理 IPv6 地址
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>一句话概括就是<strong>在通用网络编程中提供一个安全的“万能地址缓冲区”</strong>。</p><h2 id=字节序函数><a href=#%e5%ad%97%e8%8a%82%e5%ba%8f%e5%87%bd%e6%95%b0>字节序函数</a></h2><p>对于多字节数据类型来说，内存中存储时有两种方法：一种是将低序字节存储在地址起始位置，称为小端字节序；另一种方法是将高序字节存储在起始地址，称为大端法。</p><p>例如对于一个4字节整型数据<code>0x12345678</code>，其中低序字节指的是<code>0x78</code>，高序字节指的是<code>0x12</code>，因此当内存地址的增长顺序为从左到右时，小端字节序为<code>0x78 0x56 0x34 0x12</code>，大端字节序为<code>0x12 0x34 0x56 0x78</code>。</p><p>由于网络协议中存在多字节字段的端口号、IP地址等，因此需要明确指定一个网络字节序，用于发送协议栈和接收协议栈就这些多字节字段各个字节的传送顺序达成一致。</p><p>由于大端字节序符合人的阅读习惯，因此网络协议使用大端字节序来传送多字节字段。</p><p><strong>从理论上来说，具体实现上可以按照主机字节序存储套接字地址结构中的各个字段，等到需要在这些字段和协议首部响应字段进行移动时，再在主机字节序和网络字节序之间进行互转，避免在用户态处理转换细节</strong>。然而由于历史原因，套接字地址结构中的字段在用户态填充时就需要按照网络字节序进行维护。</p><p>因此POSIX规定了如下几个函数，用于两种字节序之间的转换：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>htonl</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>hostlong</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint16_t</span> <span class=nf>htons</span><span class=p>(</span><span class=kt>uint16_t</span> <span class=n>hostshort</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回：网络字节序的值
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>ntohl</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>netlong</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint16_t</span> <span class=nf>ntohs</span><span class=p>(</span><span class=kt>uint16_t</span> <span class=n>netshort</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回主机字节序的值
</span></span></span></code></pre></div><p>函数名称中，h表示<code>host</code>，n表示<code>network</code>，s表示<code>short</code>，l表示<code>long</code>。由于历史原因，这里分别转换的是16位和32位整型。</p><h2 id=地址转换函数><a href=#%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e5%87%bd%e6%95%b0>地址转换函数</a></h2><p>这几个函数用于在ASCII字符串和网络字节序的二进制值之间转换网络地址。</p><p><code>inet_aton</code>、<code>inet_addr</code>以及<code>inet_ntoa</code>函数在点分十进制与长度为32位的网络字节序二进制值之间转换IPv4地址。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/in.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span>	  <span class=nf>inet_aton</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>strptr</span><span class=p>,</span> <span class=k>struct</span> <span class=n>in_addr</span> <span class=o>*</span><span class=n>addrptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：字符串有效则返回1，否则返回0 
</span></span></span><span class=line><span class=cl><span class=kt>char</span>	 <span class=o>*</span><span class=nf>inet_ntoa</span><span class=p>(</span><span class=k>struct</span> <span class=n>in_addr</span> <span class=n>inaddr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>in_addr_t</span> <span class=nf>inet_addr</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>strptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：若字符串有效则为32位的二进制网络字节序的IPv4地址，否则位INADDR_NONE
</span></span></span></code></pre></div><p><code>inet_aton</code>函数用于将参数<code>strptr</code>中保存的点分十进制格式的IPv4地址转换为32位的网络字节序的二进制值。</p><p><code>inet_addr</code>的返回值为32位的网络字节序二进制值。但是该函数存在问题，不能转换<code>255.255.255.255</code>地址，因为该地址的转换结果被错误标识占用，用来指示参数出错，即<code>INADDR_NONE</code>。因此要尽量避免使用该函数。</p><p><code>inet_ntoa</code>函数用于将32位的网络字节序的IPv4地址转换为点分十进制的IPv4地址字符串。</p><p>上面三个函数都是针对IPv4地址进行转换处理的，下面两个函数是随着IPv6出现的新函数，同时支持IPv4和IPv6。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span>		<span class=nf>inet_pton</span><span class=p>(</span><span class=kt>int</span> <span class=n>af</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>cp</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>addrptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：成功则为1，若输入不是有效的表达格式则为0，若出错则为-1
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>inet_ntop</span><span class=p>(</span><span class=kt>int</span> <span class=n>af</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>addrptr</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>cp</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：若成功则为指向结果的指针，若出错则为NULL
</span></span></span></code></pre></div><p>参数<code>af</code>值得是协议族，可取值为<code>AF_INET</code>和<code>AF_INET6</code>。如果传入的协议族不支持，则返回错误并设置<code>errno</code>为<code>EAFNOSUPPORT</code>。</p><p>参数<code>addrptr</code>用于保存转换前或转换后的网络字节序的二进制值，采用<code>void*</code>类型的原因是其既可以处理<code>struct in_addr</code>类型也可以处理<code>struct in6_addr</code>类型。</p><p><code>inet_pton</code>函数用来转换参数<code>cp</code>指向的字符串为，并通过<code>addrptr</code>存放二进制结果。如果转换成功则返回1，如果对协议族而言不是有效的字符串格式则返回0，其他情况返回-1。</p><p>针对协议族的有效字符串格式包括几种：点分十进制的IPv4地址，IPv4映射的IPv6地址（<code>x:x:x:x:x:x:a.b.c.d</code>）以及IPv6地址（<code>x:x:x:x:x:x:x:x:x</code>）</p><p><code>inet_ntop</code>函数则进行相反的转换，用于将地址从数值格式转为表达格式。<code>len</code>参数用于指定缓冲区的大小，定义在<code>&lt;netinet/in.h></code>中的参考值如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define INET_ADDRSTRLEN 16
</span></span></span><span class=line><span class=cl><span class=cp>#define INET6_ADDRSTRLEN 46
</span></span></span></code></pre></div><p>示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span>	       <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=s>&#34;2001:db8::1&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=n>servaddr6</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>bzero</span><span class=p>(</span><span class=o>&amp;</span><span class=n>servaddr6</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_in6</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>inet_pton</span><span class=p>(</span><span class=n>AF_INET6</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>servaddr6</span><span class=p>.</span><span class=n>sin6_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>INET6_ADDRSTRLEN</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nf>inet_ntop</span><span class=p>(</span><span class=n>AF_INET6</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>servaddr6</span><span class=p>.</span><span class=n>sin6_addr</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span> <span class=c1>// 2001:db8::1
</span></span></span></code></pre></div><h2 id=常用函数封装><a href=#%e5%b8%b8%e7%94%a8%e5%87%bd%e6%95%b0%e5%b0%81%e8%a3%85>常用函数封装</a></h2><p>考虑到代码在IPv4和IPv6之间的通用性，<code>inet_ntop</code>函数存在一个问题：它要求调用者传入一个指向某个二进制地址的指针，而该地址通常包含在套接字地址的结构中，这就要求调用者必须知道这个结构的格式和地址族。</p><p>所以为了使用这个函数，需要分别为IPv4和IPv6编写如下代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>inet_ntop</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addr</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>str</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=n>addr6</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>inet_ntop</span><span class=p>(</span><span class=n>AF_INET6</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addr6</span><span class=p>.</span><span class=n>sin6_addr</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>str</span><span class=p>));</span>
</span></span></code></pre></div><p>为了解决这种代码通用问题，下面提供一个函数<code>sock_ntop</code>，它以指向通用套接字地址结构作为参数，然后调用适当的函数返回该地址的表达方式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=nf>sock_ntop</span><span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span><span class=o>*</span> <span class=n>sa</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>sa</span><span class=o>-&gt;</span><span class=n>sa_family</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nl>AF_INET</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>	    <span class=k>struct</span> <span class=n>sockaddr_in</span><span class=o>*</span> <span class=n>sin</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_in</span><span class=o>*</span><span class=p>)</span><span class=n>sa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	    <span class=k>if</span> <span class=p>(</span><span class=nf>inet_ntop</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sin</span><span class=o>-&gt;</span><span class=n>sin_addr</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>len</span><span class=p>)</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	    <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	    <span class=p>}</span>
</span></span><span class=line><span class=cl>	    <span class=k>return</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nl>AF_INET6</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>	    <span class=k>struct</span> <span class=n>sockaddr_in6</span><span class=o>*</span> <span class=n>sin6</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_in6</span><span class=o>*</span><span class=p>)</span><span class=n>sa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	    <span class=k>if</span> <span class=p>(</span><span class=nf>inet_ntop</span><span class=p>(</span><span class=n>AF_INET6</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sin6</span><span class=o>-&gt;</span><span class=n>sin6_addr</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>len</span><span class=p>)</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	    <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	    <span class=p>}</span>
</span></span><span class=line><span class=cl>	    <span class=k>return</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span>		<span class=n>str</span> <span class=o>=</span> <span class=s>&#34;2001:db8::1&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=n>servaddr6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>bzero</span><span class=p>(</span><span class=o>&amp;</span><span class=n>servaddr6</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_in6</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>servaddr6</span><span class=p>.</span><span class=n>sin6_family</span> <span class=o>=</span> <span class=n>AF_INET6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>inet_pton</span><span class=p>(</span><span class=n>AF_INET6</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>servaddr6</span><span class=p>.</span><span class=n>sin6_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>INET6_ADDRSTRLEN</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>sock_ntop</span><span class=p>((</span><span class=k>struct</span> <span class=n>sockaddr</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>servaddr6</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>)));</span>	<span class=c1>// 2001:db8::1
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在TCP流套接字调用<code>read</code>和<code>write</code>读取或写入的字节数可能比请求的数量少，然而这并不代表出错，原因可能在于内核用于套接字的缓冲区已经被占满，此时则需要再次调用<code>read</code>或<code>write</code>函数再次读取或写入剩余的字节。</p><p>下面提供了两个函数<code>readn</code>和<code>writen</code>，用于一次尽可能读取或写入<code>n</code>个字节，函数的返回值为实际读取或写入的字节数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>readn</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>vptr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span>  <span class=n>nleft</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=n>nread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span>   <span class=n>ptr</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ptr</span>		<span class=o>=</span> <span class=n>vptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nleft</span>	<span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>nleft</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>((</span><span class=n>nread</span> <span class=o>=</span> <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>nleft</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>	    <span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EINTR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	    <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	    <span class=p>}</span>
</span></span><span class=line><span class=cl>	    <span class=k>else</span>
</span></span><span class=line><span class=cl>	    <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 其它错误：如果已经读取部分数据，返回已读取的字节数；若尚未读取则返回 -1
</span></span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=p>(</span><span class=n>nleft</span> <span class=o>==</span> <span class=n>n</span><span class=p>)</span> <span class=o>?</span> <span class=o>-</span><span class=mi>1</span> <span class=o>:</span> <span class=p>(</span><span class=kt>ssize_t</span><span class=p>)(</span><span class=n>n</span> <span class=o>-</span> <span class=n>nleft</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	    <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>nread</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>	    <span class=k>break</span><span class=p>;</span> <span class=cm>/* EOF */</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>nleft</span> <span class=o>-=</span> <span class=n>nread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>ptr</span>   <span class=o>+=</span> <span class=n>nread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>nleft</span> <span class=o>==</span> <span class=n>n</span><span class=p>)</span> <span class=o>?</span> <span class=o>-</span><span class=mi>1</span> <span class=o>:</span> <span class=p>(</span><span class=kt>ssize_t</span><span class=p>)(</span><span class=n>n</span> <span class=o>-</span> <span class=n>nleft</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>writen</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span><span class=o>*</span> <span class=n>vptr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span>	<span class=n>nleft</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span>	<span class=n>nwritten</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ptr</span>	  <span class=o>=</span> <span class=n>vptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nleft</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>nleft</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>((</span><span class=n>nwritten</span> <span class=o>=</span> <span class=nf>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>nleft</span><span class=p>))</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>	    <span class=k>if</span> <span class=p>(</span><span class=n>nwritten</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>errno</span> <span class=o>==</span> <span class=n>EINTR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	    <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	    <span class=p>}</span>
</span></span><span class=line><span class=cl>	    <span class=k>else</span>
</span></span><span class=line><span class=cl>	    <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 其它错误：如果已经写入部分数据，返回已写入；若尚未写入则返回 -1
</span></span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=p>(</span><span class=n>nleft</span> <span class=o>==</span> <span class=n>n</span><span class=p>)</span> <span class=o>?</span> <span class=o>-</span><span class=mi>1</span> <span class=o>:</span> <span class=p>(</span><span class=kt>ssize_t</span><span class=p>)(</span><span class=n>n</span> <span class=o>-</span> <span class=n>nleft</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	    <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>nleft</span> <span class=o>-=</span> <span class=n>nwritten</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>ptr</span>   <span class=o>+=</span> <span class=n>nwritten</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>nleft</span> <span class=o>==</span> <span class=n>n</span><span class=p>)</span> <span class=o>?</span> <span class=o>-</span><span class=mi>1</span> <span class=o>:</span> <span class=p>(</span><span class=kt>ssize_t</span><span class=p>)(</span><span class=n>n</span> <span class=o>-</span> <span class=n>nleft</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://DBL2017.github.io/>生如夏花</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/unp/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E7%A1%80/>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/unp/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E7%A1%80/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br><div class="post-meta meta-tags"><ul class=clearfix><li><a href=/tags/%E5%A5%97%E6%8E%A5%E5%AD%97>套接字</a></li><li><a href=/tags/sockaddr>sockaddr</a></li><li><a href=/tags/inet_pton>inet_pton</a></li><li><a href=/tags/%E5%AD%97%E8%8A%82%E5%BA%8F>字节序</a></li><li><a href=/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF>大小端</a></li></ul></div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=DBL2017/DBL2017.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></div></div></div><div class=content-right><div class=sidebar><section class=widget><form id=form-search action=https://DBL2017.github.io/search/ method=get accept-charset=utf-8 _lpchecked=1><input type=text name=q maxlength=20 placeholder=请输入查找关键字 required>
<button type=submit class=submit title=提交>
<svg t="1714448321870" class="icon" style="width:22px;height:22px" viewBox="0 0 1024 1024" p-id="1771" width="200" height="200"><path d="M781.9264 691.1232l236.928 236.9216-90.816 90.8032-236.9152-236.9216c-72.032 53.3568-161.184 84.9088-257.7088 84.9088C194.048 866.8352.0 672.7872.0 433.408.0 194.048 194.048.0 433.4144.0c239.3728.0 433.4208 194.048 433.4208 433.4144.0 96.5248-31.552 185.6768-84.9088 257.7088zm-348.512 47.2896c168.448.0 304.9984-136.5504 304.9984-304.9984s-136.5504-304.992-304.9984-304.992-304.992 136.5504-304.992 304.9856c0 168.448 136.5504 304.9984 304.992 304.9984z" fill="#4A4A4A" p-id="1772"/></svg></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/unp/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E7%A1%80/ title=套接字基础>套接字基础</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/windowsterminal%E9%85%8D%E7%BD%AE/ title=WindowsTerminal配置>WindowsTerminal配置</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%BF%98%E8%AE%B0ubuntu14.04%E7%9A%84%E7%99%BB%E5%BD%95%E8%B4%A6%E5%AF%86%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/ title=记录一次忘记Ubuntu14.04的登录账密的处理方式>记录一次忘记Ubuntu14.04的登录账密的处理方式</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/neovim/diagnostic/ title=Diagnostic>Diagnostic</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/openwrt/libubox/uloop%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/ title=uloop源码剖析>uloop源码剖析</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/tikz%E7%BB%98%E5%88%B6%E6%8A%98%E7%BA%BF%E5%9B%BE/ title=TiKZ绘制折线图>TiKZ绘制折线图</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ubuntu18%E6%B0%B8%E4%B9%85%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%90%8D%E7%A7%B0/ title=Ubuntu18永久修改网络接口名称>Ubuntu18永久修改网络接口名称</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8Bdocumentclass/ title=LaTeX之documentclass>LaTeX之documentclass</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8Bctex%E5%AE%8F%E9%9B%86%E4%B9%8B%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%E7%B1%BB/ title=LaTeX之CTeX宏集之中文文档类>LaTeX之CTeX宏集之中文文档类</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8B%E4%B8%AD%E6%96%87%E6%94%AF%E6%8C%81/ title=LaTex之中文支持>LaTex之中文支持</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=https://DBL2017.github.io/categories/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/>传输协议 (17)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/>工具使用 (25)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/>开源三方 (2)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统 (14)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/>数字安全 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/>数据结构和算法 (5)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言 (14)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/>网络工程师 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记 (57)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/>问题排查 (6)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%BB%98%E8%AE%A4/>默认 (2)</a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://mermaid.live/ title=Mermaid>Mermaid 编辑</a></li><li><a target=_blank href=https://excalidraw.com/ title=EXCALIDRAW>Excalidraw 绘图</a></li><li><a target=_blank href=https://git-scm.com/docs title=Git命令参考手册>Git命令参考手册</a></li><li><a target=_blank href=https://www.gnu.org/software/make/manual/make.html title="GNU make官方文档">GNU make官方文档</a></li><li><a target=_blank href=https://www.emojiall.com/ title=Emojiall表情网站>Emojiall表情网站</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/index.xml>文章 RSS</a></li></ul></section></div></div></div><div class=container-footer><footer id=footer><div>&copy; 2026 <a href=https://DBL2017.github.io/>生如夏花 By
生如夏花</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>广电总局</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered
by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://DBL2017.github.io/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">生如夏花</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script src=/js/jquery.fancybox.min.min.65c12100ca45d31006ad262cbdfa339fe0849703b18dfd74dd0156de627f0a1dc42eba3364e03876562117d2fa7722d8153cee03bdf747264c3c029102e154f6.js integrity="sha512-ZcEhAMpF0xAGrSYsvfozn+CElwOxjf103QFW3mJ/Ch3ELrozZOA4dlYhF9L6dyLYFTzuA733RyZMPAKRAuFU9g==" crossorigin=anonymous></script><a id=rocket href=#top></a><script src=/js/totop.min.8c7573186baa30f09c49b5cf3176c3b105785324d961b3d5c2f7f099d14673160a29aeebdec25909d046aa14936cd43451e17664662d518550d5e8998dbec670.js integrity="sha512-jHVzGGuqMPCcSbXPMXbDsQV4UyTZYbPVwvfwmdFGcxYKKa7r3sJZCdBGqhSTbNQ0UeF2ZGYtUYVQ1eiZjb7GcA==" crossorigin=anonymous></script><script src=/js/clipboard.min.0765794be1674926c1a3810afcf039f605f367cb11cef727ad49e6aa70f9fca0a37d329d64c55822896869eb0960763e73e085ee7675cbc497e4d3256a6e6a67.js integrity="sha512-B2V5S+FnSSbBo4EK/PA59gXzZ8sRzvcnrUnmqnD5/KCjfTKdZMVYIoloaesJYHY+c+CF7nZ1y8SX5NMlam5qZw==" crossorigin=anonymous></script><script>var spy=new Gumshoe("#TableOfContents a",{nested:!0,nestedClass:"active"})</script><script>hljs.highlightAll()</script></div></div></body></html>