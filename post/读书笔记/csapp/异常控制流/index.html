<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>异常控制流 | 生如夏花</title><meta property="og:title" content="异常控制流 - 生如夏花"><meta property="og:type" content="article"><meta property="article:published_time" content='2020-05-24T14:07:37+08:00'><meta property="article:modified_time" content='2020-05-24T14:07:37+08:00'><meta name=Keywords content="C语言,Linux系统开发,物联网,博客,项目管理,软件架构"><meta name=description content="异常控制流，创建以及控制进程，信号的发送和接收"><meta name=author content><meta property="og:url" content="https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css><link rel=stylesheet href=/css/badge.min.c6e6f065a59e7bd54d7bd6bf2f3998a1fcb485582aca59bb6257806f0d956d2f5785e1b9cadfe4452359086749d379aabe5bc50132b1bfcc994e5f9d7150ccbe.css integrity="sha512-xubwZaWee9VNe9a/LzmYofy0hVgqylm7YleAbw2VbS9XheG5yt/kRSNZCGdJ03mqvlvFATKxv8yZTl+dcVDMvg==" crossorigin=anonymous><link rel=stylesheet href=/css/header.min.9e74ad2f7e23fb54e2da3ef2f1eb6498897cd4139d181133b5e641f107980364ccfbcea731badb693b4a50819c388b6f8cab037346daf142114f86f14faa8766.css integrity="sha512-nnStL34j+1Ti2j7y8etkmIl81BOdGBEzteZB8QeYA2TM+86nMbrbaTtKUIGcOItvjKsDc0ba8UIRT4bxT6qHZg==" crossorigin=anonymous><link rel=stylesheet href=/css/table.min.032852d8d049c55be5cd0a27bf8c7b09c8ea549fb719c2fd0231ebd262fdddb5aaaf391dabeb89ce33bcbe49f13ee8a530822a26f76b675af23473ed07b95d2e.css integrity="sha512-AyhS2NBJxVvlzQonv4x7CcjqVJ+3GcL9AjHr0mL93bWqrzkdq+uJzjO8vknxPuilMIIqJvdrZ1ryNHPtB7ldLg==" crossorigin=anonymous><link rel=stylesheet href=/css/baseof.min.7799d75bdec4c3ec6c9b5cc5291d9f452a0103bfe0f58e5d705baa7abe57f2e977a22fc3ff0b101c063d7f39931420391a0dc2b5ddc7b306110ef51ab01cb247.css integrity="sha512-d5nXW97Ew+xsm1zFKR2fRSoBA7/g9Y5dcFuqer5X8ul3oi/D/wsQHAY9fzmTFCA5Gg3Ctd3HswYRDvUasByyRw==" crossorigin=anonymous><link rel=stylesheet href=/css/rocket.min.96a6be31cd3df9dcd4e7e131e9fcb0e63149da1da6a23df5ed8c8e0ccf0436f4c95aad5ded6a69e7fba5c051f8cc00466fcedaa07e4c7f59492d4a15aba2e936.css integrity="sha512-lqa+Mc09+dzU5+Ex6fyw5jFJ2h2moj317YyODM8ENvTJWq1d7Wpp5/ulwFH4zABGb87aoH5Mf1lJLUoVq6LpNg==" crossorigin=anonymous><link rel=stylesheet href=/css/toc.min.37fe0fbda85f18e890be33d1e0a82b29b78f1266bfe17e63679d86b84af41b0124616f83d28227783c214e26bd8d70223d405128cc355d865d7016623a163068.css integrity="sha512-N/4PvahfGOiQvjPR4KgrKbePEma/4X5jZ52GuEr0GwEkYW+D0oIneDwhTia9jXAiPUBRKMw1XYZdcBZiOhYwaA==" crossorigin=anonymous><link rel=stylesheet href=/css/clipboard.min.5e6a0198e50c850ced7dc2ba6f282ecaab21a8daad9eee626b990120818361b4b0007128d73957d5682346c88a6f9831f5872051e5f12da830cc29ca75676403.css integrity="sha512-XmoBmOUMhQztfcK6byguyqshqNqtnu5ia5kBIIGDYbSwAHEo1zlX1WgjRsiKb5gx9YcgUeXxLagwzCnKdWdkAw==" crossorigin=anonymous><link rel=stylesheet href=/css/style.min.c3c6800c298f5369e9063d72a2b534abf64bf1ee7bec54c70f15a3219ad0ae104e388252951ef21ce76c1d3b7ec5eb40939179a89684e52034d885e6e002e1ea.css integrity="sha512-w8aADCmPU2npBj1yorU0q/ZL8e577FTHDxWjIZrQrhBOOIJSlR7yHOdsHTt+xetAk5F5qJaE5SA02IXm4ALh6g==" crossorigin=anonymous><link rel="shortcut icon" href=/img/favicon.png type=image/x-icon><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/vim.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/latex.min.js></script><script src=/js/gumshoe.min.min.9dec1df0371d73b03324ed4bb78a6d5b2e84af6a37b11ce799808a26d70dfd156595f8d23c42db9e4866f12b4c0de664cfd032fa6f95bdaaada1bacdb235e79e.js integrity="sha512-newd8Dcdc7AzJO1Lt4ptWy6Er2o3sRznmYCKJtcN/RVllfjSPELbnkhm8StMDeZkz9Ay+m+VvaqtobrNsjXnng==" crossorigin=anonymous></script></head><body><div class=container><div class=container-header><header><div class=header-main><div class=header-site-name><a id=header-title href=https://DBL2017.github.io/>生如夏花</a><p class=description>专注于工业物联网行业数据采集，嵌入式Linux系统裁剪，5G智慧网关软件开发等</p></div><div class=header-menu><nav id=header-nav-menu><a href=https://DBL2017.github.io/>首页</a>
<a href=https://DBL2017.github.io/series/ title=系列>系列</a>
<a href=https://DBL2017.github.io/categories/ title=分类>分类</a>
<a href=https://DBL2017.github.io/tags/ title=标签>标签</a>
<a href=https://DBL2017.github.io/archives/ title=归档>归档</a>
<a href=https://DBL2017.github.io/about/ title=关于>关于</a></nav></div></div></header></div><div class=container-content><div class=content-center><div class=main-single><div class=single-toc><div class=post-toc><h2 class=post-toc-title><a href=#>目录</a></h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#异常>异常</a><ul><li><a href=#异常处理>异常处理</a></li><li><a href=#异常的类别>异常的类别</a></li><li><a href=#linuxx86_64系统中的异常>Linux/x86_64系统中的异常</a></li></ul></li><li><a href=#进程>进程</a><ul><li><a href=#逻辑控制流>逻辑控制流</a></li><li><a href=#并发流>并发流</a></li><li><a href=#私有地址空间>私有地址空间</a></li><li><a href=#用户模式和内核模式>用户模式和内核模式</a></li><li><a href=#上下文切换>上下文切换</a></li></ul></li><li><a href=#系统调用错误处理>系统调用错误处理</a></li><li><a href=#进程控制>进程控制</a><ul><li><a href=#获取进程id>获取进程ID</a></li><li><a href=#创建和终止进程>创建和终止进程</a></li><li><a href=#回收子进程>回收子进程</a></li><li><a href=#让进程休眠>让进程休眠</a></li><li><a href=#加载并运行程序>加载并运行程序</a></li></ul></li><li><a href=#信号>信号</a><ul><li><a href=#信号术语>信号术语</a></li><li><a href=#发送信号>发送信号</a></li><li><a href=#接收信号>接收信号</a></li><li><a href=#阻塞和解除阻塞信号>阻塞和解除阻塞信号</a></li><li><a href=#编写信号处理程序>编写信号处理程序</a></li></ul></li><li><a href=#操作进程的工具>操作进程的工具</a></li></ul></nav></div></div></div><div class=single-article><article class=post><header><h1 class=post-title>异常控制流</h1></header><date class="post-meta meta-date"><span class=meta-category><a href=/archives/#2020>2020年5月24日</a></span></date><div class=post-meta><span>|</span>
<span class=meta-category><a href=/categories/#%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0>读书笔记</a></span></div><div class=post-meta><span>|</span>
<span class=meta-category><a href=/series/#CSAPP>CSAPP</a></span></div><div class=post-meta><span>|</span>
<span>共8581字</span></div><div class=post-meta><span>|</span>
<span>阅读时长(18分钟)</span></div><div class=clear style=display:none><div class=toc-article><div class=toc-title>文章目录</div></div></div><div class=post-content><p>从给处理器加电开始，直到断电为止，程序计数器假设一个值的序列$a_0,a_1,&mldr;,a_{n-1}$，其中，每个$a_k$是某个相应指令$I_k$的地址。每次从$a_k$到$a_{k+1}$的过渡称为<strong>控制转移</strong>。这样的控制转移序列叫做处理器的控制流。</p><h2 id=异常><a href=#%e5%bc%82%e5%b8%b8>异常</a></h2><ul><li>异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。因为它们有一部分是由硬件实现的，所以具体细节将随操作系统的不同而有所不同。</li><li><strong>异常</strong>就是控制流中的突变，用来相应处理器状态中的某些变化。
<a data-fancybox=gallery href=8-1.png><img class=mx-auto alt src=8-1.png></a></li><li>在图中，当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令$I_{curr}$。在处理器中，状态被编码为不同的位和信号。状态变化称为<strong>事件</strong>。事件可能和当前指令的执行直接相关。</li><li>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>的跳转表，进行一个间接过程调用，到一个专门设计用来处理这类事件的操作系统子进程（异常处理程序）。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下3种情况的一种：<ul><li>处理程序将控制返回给当前指令$I_{curr}$，即当事件发生时正在执行的指令。</li><li>处理程序将控制权返回给$I_{next}$，如果没有发生异常将会执行下一条指令。</li><li>处理程序终止被中断的程序。</li></ul></li></ul><h3 id=异常处理><a href=#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86>异常处理</a></h3><ul><li>系统中可能的每种类型的异常都分配了一个唯一的非负整数的<strong>异常号</strong>。其中一些号码时有处理器的设计者分配的，其他号码时有操作系统内核的设计者分配的。前者的示例包括被零除，缺页，内存访问违例，断点以及算术运算溢出。后者的示例包括系统调用和来自外部I/O设备的信号。</li><li>在系统启动时，操作系统分配和初始化一张称为异常表的跳转表，使得标目k包含异常k的处理程序的地址。</li><li>在运行时，处理器检测到发生了一个事件，并且确定了相应的异常号k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的标目k，转到相应的处理程序。
<a data-fancybox=gallery href=8-3.png><img class=mx-auto alt src=8-3.png></a></li></ul><h3 id=异常的类别><a href=#%e5%bc%82%e5%b8%b8%e7%9a%84%e7%b1%bb%e5%88%ab>异常的类别</a></h3><ul><li>异常可以分为4类：中断（interrupt），陷阱（trap），故障（fault）和终止（abort）。
<a data-fancybox=gallery href=8-4.png><img class=mx-auto alt src=8-4.png></a></li><li><strong>中断</strong>： 中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。</li><li><strong>陷阱和系统调用</strong>： 陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是在用户程序和内核之间提供一个向过程一样的接口，叫做系统调用。</li><li><strong>故障</strong>： 故障有错误情况引起，它可能能够被故障处理程序修正，</li><li><strong>终止</strong>： 终止是不可恢复的致命错误造成的结果。</li></ul><h3 id=linuxx86_64系统中的异常><a href=#linuxx86_64%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e5%bc%82%e5%b8%b8>Linux/x86_64系统中的异常</a></h3><ul><li>256中不同的异常类型。0～31的号码对应的是由Intel架构师定义的异常，因此对任何x86_64系统都是一样的。32～255的号码对应的是操作系统定义的中断和陷阱。![](8-9.png%}</li><li><strong>Linux/x86_64故障和终止</strong></li><li><strong>Linux/x86_64系统调用</strong>： Linux提供了几百种系统调用，当应用程序想要请求内核服务时可以使用，包括读写文件或创建一个新进程。每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量。</li><li>C程序用<code>syscall</code>函数可以直接调用任何系统调用。对于大多数系统调用，标准C库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。</li></ul><h2 id=进程><a href=#%e8%bf%9b%e7%a8%8b>进程</a></h2><ul><li>异常是允许操作系统内核提供进程概念的基本构造块。</li><li>进程的经典定义就是<strong>一个执行中程序的实例</strong>。系统中的每个程序都运行在某个进程的<strong>上下文</strong>中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器，程序计数器，环境变量以及打开文件描述符的集合。</li><li>每次用户通过向shell输入一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在新进程的上下文中运行它们自己的代码或其他应用程序。<ul><li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。</li><li>一个私有的地址空间，它提供一个假象，好像我们的程序独占的使用内存系统。</li></ul></li></ul><h3 id=逻辑控制流><a href=#%e9%80%bb%e8%be%91%e6%8e%a7%e5%88%b6%e6%b5%81>逻辑控制流</a></h3><ul><li>即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它们在独占地使用处理器。如果想用调式器单步执行程序，我们会看到一系列的程序计数器（PC）的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做<strong>逻辑控制流</strong>。
<a data-fancybox=gallery href=8-12.png><img class=mx-auto alt src=8-12.png></a></li></ul><h3 id=并发流><a href=#%e5%b9%b6%e5%8f%91%e6%b5%81>并发流</a></h3><ul><li>计算机系统中逻辑流有许多不同的形式。异常处理程序，进程，信号处理程序，线程和Java进程都是逻辑流的例子。</li><li>一个逻辑流的执行在时间上与另一个流重叠，称为<strong>并发流</strong>，这两个流被称为<strong>并发地运行</strong>。</li><li>多个流并发地执行的一般现象被称为<strong>并发</strong>。一个进程和其他进程轮流运行的概念称为<strong>多任务</strong>。一个进程执行它的控制流的一部分的每一时间段叫做<strong>时间片</strong>。因此，多任务也叫做<strong>时间分片</strong>。</li><li>并发流的思想和流运行的处理器核数无关。如果两个流在时间上重叠，那么它们就是并发的。</li></ul><h3 id=私有地址空间><a href=#%e7%a7%81%e6%9c%89%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4>私有地址空间</a></h3><ul><li>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。在一台n位地址的机器上，<strong>地址空间</strong>是$2^n$个可能地址的集合，$0,1,&mldr;,2^n-1$。进程为每个程序提供它自己的<strong>私有地址空间</strong>。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上来说，这个地址空间是私有的。
<a data-fancybox=gallery href=8-13.png><img class=mx-auto alt src=8-13.png></a></li></ul><h3 id=用户模式和内核模式><a href=#%e7%94%a8%e6%88%b7%e6%a8%a1%e5%bc%8f%e5%92%8c%e5%86%85%e6%a0%b8%e6%a8%a1%e5%bc%8f>用户模式和内核模式</a></h3><ul><li>为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。</li><li>处理器通常是用某个寄存器中的一个<strong>位模式</strong>来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了位模式时，进程就运行在内核模式中。一个运行在内核模式中的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。没有设置位模式时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令。</li><li>运行应用程序代码的进程初始时是在用户模式中的，进程从用户模式变为内核模式的唯一方法是通过诸如中断，故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。</li><li>Linux提供了一种聪明的机制，叫做<code>/proc</code>文件系统，它允许用户模式进程访问内核数据结构的内容。<code>/proc</code>文件系统将许多内核数据结构的内容输出为一个用户进程可以读的文本文件的层次结构。比如，你可以使用<code>/proc</code>文件系统找出一般的系统属性，比如CPU类型<code>cat /proc/cpuinfo</code>。</li></ul><h3 id=上下文切换><a href=#%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2>上下文切换</a></h3><ul><li>操作系统内核使用一种称为<strong>上下文切换</strong>的较高层次形式的异常控制流来实现多任务。</li><li>内核为每个进程维持一个<strong>上下文</strong>。上下文就是内核启动一个进程所需的状态。它有一些对象的值组成，这些对象包括通用目的寄存器，浮点寄存器，程序计数器，用户栈，状态寄存器，内核栈和各种内核数据结构。</li><li>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做<strong>调度</strong>，是由内核中称为<strong>调度器</strong>的代码处理的。在内核调度了一个新的进程运行时，他就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。</li><li>上下文切换：<ul><li>保存当前进程的上下文</li><li>恢复某个先前被抢占的进程被保存的上下文</li><li>将控制传递给这个新恢复的进程。
<a data-fancybox=gallery href=8-14.png><img class=mx-auto alt src=8-14.png></a></li></ul></li></ul><h2 id=系统调用错误处理><a href=#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e9%94%99%e8%af%af%e5%a4%84%e7%90%86>系统调用错误处理</a></h2><ul><li>当Unix系统级函数遇到错误时，它们通常会返回-1，并设置全局整数变量errno来表示什么出错了，strerror(errno)返回错误字符串。</li></ul><h2 id=进程控制><a href=#%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6>进程控制</a></h2><ul><li>Uinx提供了大量从C程序中操作进程的系统调用。</li></ul><h3 id=获取进程id><a href=#%e8%8e%b7%e5%8f%96%e8%bf%9b%e7%a8%8bid>获取进程ID</a></h3><ul><li>每个进程都有一个唯一的正数<strong>进程ID</strong>。<code>getpid</code>函数返回调用进程的PID。<code>getppid</code>函数返回它的附近成的PID（创建调用进程的进程）。<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>  <span class=kt>pid_t</span> <span class=nf>getpid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>pid_t</span> <span class=nf>getppid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div></li><li><code>getpid</code>和<code>getppid</code>函数返回一个类型为<code>pid_t</code>的整数值，在Linux系统上它在<code>types.h</code>中被定义为<code>int</code>。</li></ul><h3 id=创建和终止进程><a href=#%e5%88%9b%e5%bb%ba%e5%92%8c%e7%bb%88%e6%ad%a2%e8%bf%9b%e7%a8%8b>创建和终止进程</a></h3><ul><li>进程总是处于下面三种状态之一：<ul><li><strong>运行</strong>。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。</li><li><strong>停止</strong>。进程的执行被<strong>挂起</strong>，且不会被调度。当收到SIGSTOP，SIGTSTP，SIGTTIN或者SIGTTOU信号时，进程就停止，并且保持停止直到它受到一个SIGCONT信号，在这个时刻，进程再次开始运行。</li><li><strong>终止</strong>。进程永远停止。进程会因为三种原因终止：<ul><li>收到一个信号，该信号的默认行为是终止进程。</li><li>从主程序返回。</li><li>调用<code>exit</code>函数。<code>void exit(int status)</code></li></ul></li></ul></li><li><code>exit</code>函数以<code>status</code>退出状态来终止进程。</li><li><strong>父进程</strong>通过调用<code>fork</code>函数创建一个新的运行的<strong>子进程</strong>。<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>  <span class=kt>pid_t</span> <span class=nf>fork</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>//返回： 子进程返回0，父进程返回子进程的PID，如果出错，则为-1。
</span></span></span></code></pre></div></li><li>新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的一份副本，包含代码和数据段，堆，共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用<code>fork</code>时，子进程可以读取父进程中打开的任何文件。父进程和新创建的子进程之间的最大区别在于它们有不同的PID。</li><li><code>fork</code>函数被调用一次，却会返回两次：一次在父进程中，一次在新创建的子进程中。在父进程中，<code>fork</code>返回子进程的PID。在子进程中，<code>fork</code>返回0。因为子进程的PID总是非0，返回值就提供了一个明确的方法分辨程序是在父进程还是子进程中执行。<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>      <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=n>x</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>pid</span><span class=o>=</span><span class=nf>Fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>pid</span><span class=o>==</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child: x=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=o>++</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;parent: x=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=o>--</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div></li><li><strong>调用一次，返回两次</strong>。<code>fork</code>函数被父进程调用一次，但是却返回两次。一次是返回到父进程中，一次是返回到新创建的子进程中。</li><li><strong>并发执行</strong>。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。</li><li><strong>相同但是独立的地址空间</strong>。父进程和子进程对<code>x</code>所作的任何改变都是独立的，不会反映在另一个进程的内存中。</li><li><strong>共享文件</strong>。当运行这个示例程序时，父进程和子进程都把它们的输出显示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用<code>fork</code>时，<code>stdout</code>文件是打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。</li></ul><h3 id=回收子进程><a href=#%e5%9b%9e%e6%94%b6%e5%ad%90%e8%bf%9b%e7%a8%8b>回收子进程</a></h3><ul><li>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态，直到它被父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为<strong>僵死进程</strong>。</li><li>如果父进程没有回收它的僵死子进程就终止了，那么内核会安排<code>init</code>进程去回收它们。</li><li>一个进程可以通过调用<code>waitpid</code>函数来等待它的子进程终止或者停止。<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=kt>pid_t</span> <span class=nf>waitpid</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>statusp</span><span class=p>,</span> <span class=kt>int</span> <span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>//返回：如果成功，则为子进程的PID，如果WNOHANG，则为0，如果其他错误，则为-1
</span></span></span></code></pre></div></li><li><code>waitpid</code>函数，默认情况下（当<code>options=0</code>时），<code>waitpid</code>挂起调用进程的执行，直到它的等待集合中的一个子进程终止。如果等待集合中的一个进程在刚开始调用就已经终止了，那么<code>waitpid</code>就立即返回。在这两种情况下，<code>waitpid</code>返回导致<code>waitpid</code>返回的已终止子进程的PID。此时，已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹。</li><li>判定等待集合中的成员:<ul><li>等待集合中成员是由参数<code>pid</code>来确定的。</li><li>如果<code>pid>0</code>，那么等待集合就是一个单独的子进程，它的进程ID就是<code>pid</code>。</li><li>如果<code>pid=-1</code>， 那么等待集合就是父进程所有的子进程组成的。</li></ul></li><li>修改默认行为：<ul><li>可以通过将<code>options</code>设置为常量WNOHANG，WUNTRACED和WCONTINUED的各种组合来修改默认行为。</li><li>WNOHANG： 如果等待集合中的任何子进程都还没有终止，那么就立即返回。默认的行为是挂起调用进程，直到有子进程终止，</li><li>WUNTRACED： 挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。默认的行为是只返回已终止的子进程。</li><li>WCONTINUED： 挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或者等待集合中一个被停止的进程收到SIGCONT信号重新开始执行。</li></ul></li><li>检查已回收进程的退出状态：<ul><li>如果<code>statusp</code>参数是非空的，那么<code>waitpid</code>就会在<code>status</code>中放上关于导致返回的子进程的状态信息，<code>status</code>是<code>statusp</code>指向的值。<code>wait.h</code>头文件定义了解释<code>status</code>参数的几个宏。</li><li>WIFEXITED(status): 如果子进程通过调用<code>exit</code>或者一个返回正常终止，就返回真。</li><li>WEXITSTATUS(status): 返回一个正常终止的子进程的退出状态。只有在WIFEXITED(status)返回为真时，才会定义这个状态。</li><li>WIFSIGNALED(status): 如果子进程是因为一个未被捕获的信号终止的，那么就返回真。</li><li>WTERMSIG(status): 返回导致子进程终止的信号的编号。只有在WIFSIGNALED(status)为真时，才定义这个状态。</li><li>WIFSTOPPED(status)： 如果引起返回的子进程当前是停止的，那么就返回真。</li><li>WSTOPSIG(status)： 返回引起子进程停止的信号的编号。只有在WIFSTOPPED(status)返回为真时，才定义这个状态。</li></ul></li><li>错误条件：<ul><li>如果调用进程没有子进程，那么<code>waitpid</code>返回-1，并且设置<code>errno</code>为ECHILD。如果<code>waitpid</code>函数被一个信号中断，那么它返回-1，并设置<code>errno</code>为EINTR。</li></ul></li></ul><h3 id=让进程休眠><a href=#%e8%ae%a9%e8%bf%9b%e7%a8%8b%e4%bc%91%e7%9c%a0>让进程休眠</a></h3><ul><li><code>sleep</code>函数将一个进程挂起一段指定的事件。<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>sleep</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>secs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>//返回: 还要休眠的秒数
</span></span></span></code></pre></div></li><li>如果请求的时间量已经到了，<code>sleep</code>返回0，否则返回还剩下的要休眠的秒数。</li><li><code>pause</code>函数，让调用函数休眠，直到该进程收到一个信号。<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=kt>int</span> <span class=nf>pause</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span></code></pre></div></li></ul><h3 id=加载并运行程序><a href=#%e5%8a%a0%e8%bd%bd%e5%b9%b6%e8%bf%90%e8%a1%8c%e7%a8%8b%e5%ba%8f>加载并运行程序</a></h3><ul><li><code>execve</code>函数在当前进程的上下文中加载并运行一个新程序。<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=kt>int</span> <span class=nf>execve</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>filename</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[],</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>envp</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl>  <span class=c1>//如果成功，则不返回，如果错误，则返回-1。
</span></span></span></code></pre></div></li><li><code>execve</code>函数加载并运行可执行目标文件<code>filename</code>，且带参数列表<code>argv</code>和环境变量列表<code>envp</code>。<code>envp</code>变量指向一个以<code>null</code>结尾的指针数组，其中每个指针指向一个环境变量字符串，其中每个指针指向一个环境变量字符串，每个串都是形如<code>name=value</code>的名-值对。</li><li><code>execve</code>函数启动的主函数原型如<code>int main(int argc, char**argv, char **envp)</code>。</li><li>Linux下操作环境变量函数：<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=kt>char</span><span class=o>*</span> <span class=nf>getenv</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>setenv</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>name</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>newvalue</span><span class=p>,</span> <span class=kt>int</span> <span class=n>overwrite</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>unsetenv</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>name</span><span class=p>);</span>
</span></span></code></pre></div></li></ul><h2 id=信号><a href=#%e4%bf%a1%e5%8f%b7>信号</a></h2><ul><li>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。</li></ul><h3 id=信号术语><a href=#%e4%bf%a1%e5%8f%b7%e6%9c%af%e8%af%ad>信号术语</a></h3><ul><li>传送一个信号的目的进程是由两个不同步骤组成的：<ul><li><strong>发送信号</strong>。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号可以有如下两种原因：<ul><li>内核检测到一个系统事件，比如除0错误或子进程终止。</li><li>一个进程调用了<code>kill</code>函数，显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给自己。</li></ul></li><li><strong>接受信号</strong>。当目的进程被内核强制以某种方式对信号的发送作出反应时，它就接受了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号。</li><li>一个发出而没有被接受的信号叫做待处理信号。在任何时刻，一种类型至多只会有一个待处理信号。一个待处理信号最多只能被接受一次。内核为每个进程在<code>pending</code>位向量中维护者待处理信号的集合，而在<code>blocked</code>位向量中维护者被阻塞的信号集合。</li></ul></li></ul><h3 id=发送信号><a href=#%e5%8f%91%e9%80%81%e4%bf%a1%e5%8f%b7>发送信号</a></h3><ul><li>Unix系统提供了大量向进程发送信号的机制，所有这些机制都是基于<strong>进程组</strong>。</li><li><strong>进程组</strong>：<ul><li>每个进程都只属于一个进程组，进程组是由一个正整数进程ID来标识的。<code>getpgrp</code>函数返回当前进程的进程组ID：<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=kt>pid_t</span> <span class=nf>getpgrp</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>//返回： 调用进程的进程组ID
</span></span></span></code></pre></div></li><li>默认地，一个子进程和它的父进程统属于一个进程组。一个进程可以通过使用<code>setpgid</code>函数来改变自己和其他进程的进程组：<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=kt>int</span> <span class=nf>setpgid</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>pid_t</span> <span class=n>pgid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>//返回：成功返回0，失败返回-1
</span></span></span></code></pre></div></li><li><code>setpgid</code>函数将进程<code>pid</code>的进程组该为<code>pgid</code>。如果<code>pid</code>是0，那么就使用当前进程的PID，如果<code>pgid</code>是0，那么就用<code>pid</code>指定的进程PID作为进程组的ID。</li></ul></li><li><strong>用/bin/kill程序发送信号</strong><ul><li><code>/bin/kill</code>程序可以向另外的进程发送任意的信号。<code>$ /bin/kill -9 pid</code>发送信号9（SIGKILL）给进程pid。</li><li>一个为负的PID会导致信号被发送到进程组PID中的每个进程。<code>$ /bin/kill -9 -pid</code>发送一个SIGKILL信号给进程组为pid的每个进程。</li></ul></li><li><strong>用键盘发送信号</strong><ul><li>Unix shell使用作业这个抽象概念来表示为对一个命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和0个或多个后台作业。</li><li>在键盘上输入<code>Ctrl+C</code>会导致内核发送一个SIGINT信号到前台进程组中的每个进程。默认情况下，结果是终止前它作业。类似地，输入<code>Ctrl+Z</code>会发送一个SIGISTP信号到前台进程组中的每个进程。默认情况下，结果是停止前台作业。</li></ul></li><li><strong>用kill函数发送信号</strong><ul><li>进程通过调用<code>kill</code>函数发送信号给其他进程（包括它们自己）。<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=kt>int</span> <span class=nf>kill</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sig</span><span class=p>);</span>
</span></span></code></pre></div></li><li>如果<code>pid</code>大于0，那么<code>kill</code>函数发送信号码<code>sig</code>给进程<code>pid</code>。如果<code>pid</code>等于0，那么<code>kill</code>发送信号<code>sig</code>给调用进程所在进程组的所有进程。</li></ul></li><li><strong>用alarm函数发送信号</strong><ul><li>进程可以通过调用<code>alarm</code>函数向它自己发送SIGALARM信号。<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>alarm</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>secs</span><span class=p>);</span>
</span></span></code></pre></div></li><li><code>alarm</code>函数会在<code>secs</code>秒后发送一个SIGALARM信号给调用进程。</li></ul></li></ul><h3 id=接收信号><a href=#%e6%8e%a5%e6%94%b6%e4%bf%a1%e5%8f%b7>接收信号</a></h3><ul><li>当内核把进程p从内核模式切换到用户模式时，它会检查进程p的未被阻塞的待处理信号的集合。如果这个集合为空，那么内核将控制传递到p的逻辑控制流的下一条指令，然而如果集合是非空的，那么内核选择集合中的某个信号k，并且强制p接受信号k。收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回p的逻辑控制流的下一条指令。每个信号类型都有一个预定以的默认行为，是下面的一种：<ul><li>进程终止。</li><li>进程终止并转储内存。</li><li>进程停止（挂起）直到被SIGCONT信号重启。</li><li>进程忽略该信号。</li></ul></li><li>进程可以通过使用<code>signal</code>函数修改和信号相关联的默认行为。唯一的例外就是SIGSTOP和SIGKILL，它们的默认行为是不能改变的。<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=kt>sighandler_t</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>sighandler_t</span> <span class=nf>signal</span><span class=p>(</span><span class=kt>int</span> <span class=n>signum</span><span class=p>,</span> <span class=kt>sighandler_t</span> <span class=n>handler</span><span class=p>);</span>
</span></span></code></pre></div></li><li><code>signal</code>函数可以通过三种方法之一来改变和信号<code>signum</code>相关联的行为：<ul><li>如果<code>handler</code>是SIG_IGN，那么忽略类型为<code>signum</code>的信号。</li><li>如果<code>handler</code>是SIG_DFL，那么类型为<code>signum</code>的信号行为恢复为默认行为。</li><li>否则，<code>handler</code>就是用户定义的函数的地址，这个函数称为信号处理程序，只要进程收到一个类型为<code>signum</code>的信号，就会调用这个程序。通过把处理程序的地址传递到<code>signal</code>函数从而改变默认行为，这叫做设置信号处理程序。调用信号处理程序被称为捕获信号。执行信号处理程序被称为处理信号。</li></ul></li><li>当一个进程捕获了一个类型为k的信号时，会调用为信号k设置的处理程序，一个正数参数被设置为k。这个参数允许同一个处理函数捕获不同类型的信号。</li><li>下面的例子用来捕获<code>Ctrl+C</code>时发送的SIGINT信号：<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>sigint_handler</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Caught SIGINT!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span><span class=n>sigint_handler</span><span class=p>)</span><span class=o>==</span><span class=n>SIG_ERR</span><span class=p>){</span>
</span></span><span class=line><span class=cl>          <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;SIG_ERR</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=nf>pause</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div></li><li>执行流程如下：
<a data-fancybox=gallery href=8-31.png><img class=mx-auto alt src=8-31.png></a></li></ul><h3 id=阻塞和解除阻塞信号><a href=#%e9%98%bb%e5%a1%9e%e5%92%8c%e8%a7%a3%e9%99%a4%e9%98%bb%e5%a1%9e%e4%bf%a1%e5%8f%b7>阻塞和解除阻塞信号</a></h3><ul><li>Linux提供阻塞信号的隐式和显式的机制：<ul><li>隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。假设程序捕获了信号s，当前正在运行处理程序S。如果发送给该进程另一个信号s，那么直到处理程序S返回，s会变成待处理而没有被接收。</li><li>显示阻塞机制。应用程序可以使用<code>sigprocmask</code>函数和它的辅助函数，明确的阻塞和解除阻塞选定的信号。<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=kt>int</span> <span class=nf>sigprocmask</span><span class=p>(</span><span class=kt>int</span> <span class=n>how</span><span class=p>,</span> <span class=k>const</span> <span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>sigset_t</span> <span class=o>*</span><span class=n>oldset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>sigemptyset</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>sigfillset</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>sigaddset</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>sigdelset</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>sigismember</span><span class=p>(</span><span class=k>const</span> <span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signum</span><span class=p>);</span>
</span></span></code></pre></div></li><li><code>sigprocmask</code>函数改变当前阻塞的信号集合。具体行为依赖于<code>how</code>的值：<ul><li>SIG_BLOCK： 把<code>set</code>中的信号添加到<code>blocked</code>中。</li><li>SIG_BLOCK： 从<code>blocked</code>中删除<code>set</code>中的信号。</li><li>SIG_SETMASK: <code>block=set</code></li><li>如果<code>oldset</code>非空，那么<code>blocked</code>位向量之前的值保存在<code>oldset</code>中。</li></ul></li><li><code>sigemptyset</code>初始化<code>set</code>为空集合。<code>sigfillset</code>函数把每个信号都添加到<code>set</code>中。<code>sigaddset</code>函数把<code>signum</code>添加到<code>set</code>，<code>sigdelset</code>从<code>set</code>中删除<code>signum</code>，如果<code>signum</code>是<code>set</code>的成员，那么<code>sigismember</code>返回1，否则返回0。</li></ul></li></ul><h3 id=编写信号处理程序><a href=#%e7%bc%96%e5%86%99%e4%bf%a1%e5%8f%b7%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f>编写信号处理程序</a></h3><ul><li>信号处理是Linux系统编程最棘手的一个问题：<ul><li>处理程序和主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序相互干扰</li><li>如何以及何时接受信号</li><li>不同的系统有不同的信号处理语义</li></ul></li><li>安全的信号处理：<ul><li>处理程序要尽可能简单</li><li>在处理程序中只调用异步信号安全的函数</li><li>保存和恢复errno</li><li>阻塞所有的信号，保护对共享全局数据结构的访问</li><li>用<code>volatile</code>声明全局变量</li><li>用sig_atomic_t声明标志</li></ul></li><li>正确的信号处理</li><li>可移植的信号处理</li></ul><h2 id=操作进程的工具><a href=#%e6%93%8d%e4%bd%9c%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%b7%a5%e5%85%b7>操作进程的工具</a></h2><ul><li>strace: 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹.</li><li>ps： 列出当前系统中的进程</li><li>top：打印出关于当前进程资源使用的信息。</li><li>pmap： 显示进程的内存映射。</li><li>/proc: 一个虚拟文件系统，以ASCII文本个是输出大量内核数据结构的内容，用户程序可以读取这些内容。<code>cat /proc/loadavg</code></li></ul></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://DBL2017.github.io/>生如夏花</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br><div class=post-archive><h2>相关文章</h2><ul class=listing><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E9%93%BE%E6%8E%A5/>链接</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/>存储器层次结构</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/>程序的机器级表示</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%92%8C%E6%95%B0%E5%80%BC%E5%8A%A0%E6%B3%95%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/>二进制加法和数值加法的对应关系</a></li><li><a href=/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E5%85%B3%E4%BA%8Eieee754%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/>关于IEEE754浮点数的一点思考</a></li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a href=/tags/%E5%BC%82%E5%B8%B8>异常</a></li><li><a href=/tags/%E8%BF%9B%E7%A8%8B>进程</a></li><li><a href=/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4>地址空间</a></li><li><a href=/tags/csapp>CSAPP</a></li></ul></div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=DBL2017/DBL2017.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></div></div></div><div class=content-right><div class=sidebar><section class=widget><form id=form-search action=https://DBL2017.github.io/search/ method=get accept-charset=utf-8 _lpchecked=1><input type=text name=q maxlength=20 placeholder=请输入查找关键字 required>
<button type=submit class=submit title=提交>
<svg t="1714448321870" class="icon" style="width:22px;height:22px" viewBox="0 0 1024 1024" p-id="1771" width="200" height="200"><path d="M781.9264 691.1232l236.928 236.9216-90.816 90.8032-236.9152-236.9216c-72.032 53.3568-161.184 84.9088-257.7088 84.9088C194.048 866.8352.0 672.7872.0 433.408.0 194.048 194.048.0 433.4144.0c239.3728.0 433.4208 194.048 433.4208 433.4144.0 96.5248-31.552 185.6768-84.9088 257.7088zm-348.512 47.2896c168.448.0 304.9984-136.5504 304.9984-304.9984s-136.5504-304.992-304.9984-304.992-304.992 136.5504-304.992 304.9856c0 168.448 136.5504 304.9984 304.992 304.9984z" fill="#4A4A4A" p-id="1772"/></svg></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ubuntu18%E6%B0%B8%E4%B9%85%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%90%8D%E7%A7%B0/ title=Ubuntu18永久修改网络接口名称>Ubuntu18永久修改网络接口名称</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8Bdocumentclass/ title=LaTeX之documentclass>LaTeX之documentclass</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8Bctex%E5%AE%8F%E9%9B%86%E4%B9%8B%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%E7%B1%BB/ title=LaTeX之CTeX宏集之中文文档类>LaTeX之CTeX宏集之中文文档类</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/latex%E4%B9%8B%E4%B8%AD%E6%96%87%E6%94%AF%E6%8C%81/ title=LaTex之中文支持>LaTex之中文支持</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/dibbler-server%E7%9A%84dhcpv6-pd%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D56%E4%BD%8D%E5%89%8D%E7%BC%80/ title=dibbler-server的DHCPv6-PD如何分配56位前缀>dibbler-server的DHCPv6-PD如何分配56位前缀</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/ipv6%E8%BF%87%E6%B8%A1%E6%8A%80%E6%9C%AF/ipip%E9%9A%A7%E9%81%93%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/ title=IPIP隧道创建实例>IPIP隧道创建实例</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%B1%82/tcp%E4%B9%8Bmss%E5%AD%97%E6%AE%B5%E5%A4%87%E6%B3%A8/ title=TCP之MSS字段备注>TCP之MSS字段备注</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bcontainer_of/ title=内核数据结构之container_of>内核数据结构之container_of</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/eve-ng/eve-ng%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ title=EVE-NG环境搭建>EVE-NG环境搭建</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/ns-3/ns-3%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ title=NS-3环境搭建>NS-3环境搭建</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=https://DBL2017.github.io/categories/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/>传输协议 (17)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/>工具使用 (23)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/>开源三方 (2)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统 (13)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/>数字安全 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/>数据结构和算法 (5)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言 (13)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/>网络工程师 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记 (56)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/>问题排查 (5)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%BB%98%E8%AE%A4/>默认 (2)</a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://mermaid.live/ title=Mermaid>Mermaid 编辑</a></li><li><a target=_blank href=https://excalidraw.com/ title=EXCALIDRAW>Excalidraw 绘图</a></li><li><a target=_blank href=https://git-scm.com/docs title=Git命令参考手册>Git命令参考手册</a></li><li><a target=_blank href=https://www.gnu.org/software/make/manual/make.html title="GNU make官方文档">GNU make官方文档</a></li><li><a target=_blank href=https://www.emojiall.com/ title=Emojiall表情网站>Emojiall表情网站</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/index.xml>文章 RSS</a></li></ul></section></div></div></div><div class=container-footer><footer id=footer><div>&copy; 2025 <a href=https://DBL2017.github.io/>生如夏花 By
生如夏花</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>广电总局</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered
by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://DBL2017.github.io/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">生如夏花</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"]}}</script><script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=/js/jquery.fancybox.min.min.7fa821ee946e58947030e5d007d358378119205e16b74ab4d0c60560a36d0414a775f9dbe0586ce12723c75cea8794fabadd1f33100a9ee22f6da3826256c0ef.js integrity="sha512-f6gh7pRuWJRwMOXQB9NYN4EZIF4Wt0q00MYFYKNtBBSndfnb4Fhs4Scjx1zqh5T6ut0fMxAKnuIvbaOCYlbA7w==" crossorigin=anonymous></script><a id=rocket href=#top></a><script src=/js/totop.min.8c7573186baa30f09c49b5cf3176c3b105785324d961b3d5c2f7f099d14673160a29aeebdec25909d046aa14936cd43451e17664662d518550d5e8998dbec670.js integrity="sha512-jHVzGGuqMPCcSbXPMXbDsQV4UyTZYbPVwvfwmdFGcxYKKa7r3sJZCdBGqhSTbNQ0UeF2ZGYtUYVQ1eiZjb7GcA==" crossorigin=anonymous></script><script src=/js/clipboard.min.0765794be1674926c1a3810afcf039f605f367cb11cef727ad49e6aa70f9fca0a37d329d64c55822896869eb0960763e73e085ee7675cbc497e4d3256a6e6a67.js integrity="sha512-B2V5S+FnSSbBo4EK/PA59gXzZ8sRzvcnrUnmqnD5/KCjfTKdZMVYIoloaesJYHY+c+CF7nZ1y8SX5NMlam5qZw==" crossorigin=anonymous></script><script>var spy=new Gumshoe("#TableOfContents a",{nested:!0,nestedClass:"active"})</script><script>hljs.highlightAll()</script></div></div></body></html>