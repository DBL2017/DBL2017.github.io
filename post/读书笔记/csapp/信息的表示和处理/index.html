<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>信息的表示和处理 | 生如夏花</title>
<meta property="og:title" content="信息的表示和处理 - 生如夏花"><meta property="og:type" content="article"><meta property="article:published_time" content='2020-04-17T00:04:10+08:00'><meta property="article:modified_time" content='2020-04-17T00:04:10+08:00'><meta name=Keywords content="C语言,Linux系统开发,物联网,博客,项目管理,软件架构"><meta name=description content="CS-APP中的信息的表示和处理章节的阅读笔记，可以用来回顾"><meta name=author content><meta property="og:url" content="https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai.min.css integrity="sha512-RLF8eOxhuwsRINc7r56dpl9a3VStqrXD+udWahutJrYdyh++2Ghnf+s4jFsOyryKZt/GNjPwbXVPH3MJpKrn2g==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/badge.min.dc57f0a9d275742b1e2d17f204ae0b829361b5dd0df99d3d356615830fb223936c054d31a888c5f369975da90586601e2666ddbbbb36e98510b814a70826e874.css integrity="sha512-3FfwqdJ1dCseLRfyBK4LgpNhtd0N+Z09NWYVgw+yI5NsBU0xqIjF82mXXakFhmAeJmbdu7s26YUQuBSnCCbodA==" crossorigin=anonymous><link rel=stylesheet href=/css/header.min.9e74ad2f7e23fb54e2da3ef2f1eb6498897cd4139d181133b5e641f107980364ccfbcea731badb693b4a50819c388b6f8cab037346daf142114f86f14faa8766.css integrity="sha512-nnStL34j+1Ti2j7y8etkmIl81BOdGBEzteZB8QeYA2TM+86nMbrbaTtKUIGcOItvjKsDc0ba8UIRT4bxT6qHZg==" crossorigin=anonymous><link rel=stylesheet href=/css/table.min.032852d8d049c55be5cd0a27bf8c7b09c8ea549fb719c2fd0231ebd262fdddb5aaaf391dabeb89ce33bcbe49f13ee8a530822a26f76b675af23473ed07b95d2e.css integrity="sha512-AyhS2NBJxVvlzQonv4x7CcjqVJ+3GcL9AjHr0mL93bWqrzkdq+uJzjO8vknxPuilMIIqJvdrZ1ryNHPtB7ldLg==" crossorigin=anonymous><link rel=stylesheet href=/css/baseof.min.e78724d0b9c6d515ee22f97ac39b8898ad417d6f0b47977db4981358565ae050fdb352dfca9a019ce22403d9580bc837bfe3e3287b039b96af75939c1071e9e4.css integrity="sha512-54ck0LnG1RXuIvl6w5uImK1BfW8LR5d9tJgTWFZa4FD9s1LfypoBnOIkA9lYC8g3v+PjKHsDm5avdZOcEHHp5A==" crossorigin=anonymous><link rel=stylesheet href=/css/rocket.min.96a6be31cd3df9dcd4e7e131e9fcb0e63149da1da6a23df5ed8c8e0ccf0436f4c95aad5ded6a69e7fba5c051f8cc00466fcedaa07e4c7f59492d4a15aba2e936.css integrity="sha512-lqa+Mc09+dzU5+Ex6fyw5jFJ2h2moj317YyODM8ENvTJWq1d7Wpp5/ulwFH4zABGb87aoH5Mf1lJLUoVq6LpNg==" crossorigin=anonymous><link rel=stylesheet href=/css/toc.min.cc966f24bfde5608a7e63066d31db9943c15156ef9cbb936f9f022eb998d941648fd23cd07b96a0b74dd5e76048764cc033cee10639f11faa98b37682ffb3a16.css integrity="sha512-zJZvJL/eVgin5jBm0x25lDwVFW75y7k2+fAi65mNlBZI/SPNB7lqC3TdXnYEh2TMAzzuEGOfEfqpizdoL/s6Fg==" crossorigin=anonymous><link rel=stylesheet href=/css/clipboard.min.5e6a0198e50c850ced7dc2ba6f282ecaab21a8daad9eee626b990120818361b4b0007128d73957d5682346c88a6f9831f5872051e5f12da830cc29ca75676403.css integrity="sha512-XmoBmOUMhQztfcK6byguyqshqNqtnu5ia5kBIIGDYbSwAHEo1zlX1WgjRsiKb5gx9YcgUeXxLagwzCnKdWdkAw==" crossorigin=anonymous><link rel=stylesheet href=/css/style.min.0ee927227dc0f181f293a851db44642879c59ab0e5e6dfaae42f3402d8e06810cb2c8fe30201142d9f8205e46f706cf646ccba5e8ee7695327d888861ddaf10d.css integrity="sha512-DuknIn3A8YHyk6hR20RkKHnFmrDl5t+q5C80AtjgaBDLLI/jAgEULZ+CBeRvcGz2Rsy6Xo7naVMn2IiGHdrxDQ==" crossorigin=anonymous><link rel="shortcut icon" href=/img/favicon.png type=image/x-icon><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vim.min.js></script><script src=/js/gumshoe.min.min.9dec1df0371d73b03324ed4bb78a6d5b2e84af6a37b11ce799808a26d70dfd156595f8d23c42db9e4866f12b4c0de664cfd032fa6f95bdaaada1bacdb235e79e.js integrity="sha512-newd8Dcdc7AzJO1Lt4ptWy6Er2o3sRznmYCKJtcN/RVllfjSPELbnkhm8StMDeZkz9Ay+m+VvaqtobrNsjXnng==" crossorigin=anonymous></script></head><body><div class=container><div class=container-header><header><div class=header-main><div class=header-site-name><a id=header-title href=https://DBL2017.github.io/>生如夏花</a><p class=description>专注于工业物联网行业数据采集，嵌入式Linux系统裁剪，5G智慧网关软件开发等</p></div><div class=header-menu><nav id=header-nav-menu><a href=https://DBL2017.github.io/>首页</a>
<a href=https://DBL2017.github.io/series/ title=系列>系列</a>
<a href=https://DBL2017.github.io/categories/ title=分类>分类</a>
<a href=https://DBL2017.github.io/tags/ title=标签>标签</a>
<a href=https://DBL2017.github.io/archives/ title=归档>归档</a>
<a href=https://DBL2017.github.io/about/ title=关于>关于</a></nav></div></div></header></div><div class=container-content><div class=content-center><div class=main-single><div class=single-toc><div class=post-toc><h2 class=post-toc-title><a href=#>目录</a></h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#信息存储>信息存储</a></li><li><a href=#整数表示>整数表示</a><ul><li><a href=#无符号数的编码>无符号数的编码</a><ul><li><a href=#无符号数编码的定义>无符号数编码的定义</a></li></ul></li><li><a href=#补码编码>补码编码</a><ul><li><a href=#补码编码的定义>补码编码的定义</a></li></ul></li><li><a href=#无符号和补码的转换>无符号和补码的转换</a><ul><li><a href=#补码转换为无符号数>补码转换为无符号数</a></li><li><a href=#无符号数转换为补码>无符号数转换为补码</a></li></ul></li><li><a href=#扩展数>扩展数</a><ul><li><a href=#无符号数的零扩展>无符号数的零扩展</a></li><li><a href=#补码的符号扩展>补码的符号扩展</a></li></ul></li><li><a href=#截断数>截断数</a><ul><li><a href=#截断无符号数>截断无符号数</a></li><li><a href=#截断补码数值>截断补码数值</a></li></ul></li></ul></li><li><a href=#整数运算>整数运算</a><ul><li><a href=#无符号数加法>无符号数加法</a><ul><li><a href=#检测无符号数加法中的溢出>检测无符号数加法中的溢出</a></li></ul></li><li><a href=#无符号数求反>无符号数求反</a><ul><li><a href=#阿贝尔群>阿贝尔群</a></li><li><a href=#无符号数求反-1>无符号数求反</a></li></ul></li><li><a href=#补码加法>补码加法</a><ul><li><a href=#推导>推导</a></li></ul></li><li><a href=#补码的非>补码的非</a></li><li><a href=#无符号数乘法>无符号数乘法</a></li><li><a href=#补码乘法>补码乘法</a><ul><li><a href=#乘以2的幂>乘以2的幂</a></li></ul></li><li><a href=#除2的幂>除2的幂</a><ul><li><a href=#无符号数除法>无符号数除法</a></li><li><a href=#补码除法>补码除法</a></li></ul></li></ul></li><li><a href=#浮点数>浮点数</a></li></ul></nav></div></div></div><div class=single-article><article class=post><header><h1 class=post-title>信息的表示和处理</h1></header><date class="post-meta meta-date"><span class=meta-category><a href=/archives/#2020>2020年4月17日</a></span></date><div class=post-meta><span>|</span>
<span class=meta-category><a href=/categories/#%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0>读书笔记</a></span></div><div class=post-meta><span>|</span>
<span class=meta-category><a href=/series/#CSAPP>CSAPP</a></span></div><div class=post-meta><span>|</span>
<span>共9801字</span></div><div class=post-meta><span>|</span>
<span>阅读时长(20分钟)</span></div><div class=clear style=display:none><div class=toc-article><div class=toc-title>文章目录</div></div></div><div class=post-content><h2 id=信息存储><a href=#%e4%bf%a1%e6%81%af%e5%ad%98%e5%82%a8>信息存储</a></h2><table><thead><tr><th>术语</th><th>说明</th></tr></thead><tbody><tr><td><strong>无符号编码</strong><code>unsigned</code></td><td>基于传统的二进制表示法，表示大于或这等于零的数字</td></tr><tr><td><strong>补码编码</strong><code>two's-complement</code></td><td>表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字</td></tr><tr><td><strong>浮点数</strong><code>floating-point</code></td><td>表示实数的科学计数法，以2为基数</td></tr><tr><td><strong>溢出</strong></td><td>计算机表示法使用有限数量的位来对一个数字编码，当结果太大不能表示时，部分运算会溢出</td></tr><tr><td><strong>字节</strong></td><td>8比特位的块，最小可寻址的内存单位</td></tr><tr><td><strong>虚拟内存</strong></td><td>机器级程序将内存视为一个非常大的数组，称为虚拟内存。</td></tr><tr><td><strong>虚拟地址空间</strong></td><td>内存的每个字节都有唯一的数字表示，称为地址，所有的地址集合称为虚拟地址空间（virtual address space）</td></tr><tr><td><strong>字长</strong></td><td>指针数据的标称大小，决定虚拟地址空间的大小</td></tr></tbody></table><p><strong>虚拟地址空间只是一个展现给机器级程序的概念性映像</strong>。实际是将动态随机访问存储器（DRAM），闪存，磁盘存储器，特殊硬件和操作系统结合起来，为程序提供一个看上去统一的字节数组。</p><p>C语言中一个指针的值（无论它指向一个整数、一个结构或某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。</p><p>C编译器还把每个指针和<strong>类型</strong>信息绑定起来，这样就可以根据指针的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。</p><p><strong>对一个字长为$w$位的机器而言，虚拟地址的范围为$0$~$2^{w}-1$，程序最多访问$2^w$个字节。</strong>（64位机器<code>sizeof(char *) //8</code>）</p><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。</p><table><thead><tr><th>术语</th><th>说明</th></tr></thead><tbody><tr><td><strong>小端法</strong>（little endian）</td><td>在内存中按照从最低有效字节到最高有效字节的顺序存储对象</td></tr><tr><td><strong>大端法</strong>（big endian）</td><td>在内存中按照从最高有效字节到最低有效字节的顺序存储对象</td></tr><tr><td><strong>位向量</strong></td><td>固定长度为$w$，由0和1组成的串</td></tr><tr><td><strong>位向量的运算</strong></td><td>参数的每个对应元素之间的运算</td></tr><tr><td><strong>逻辑右移</strong></td><td>左端补0</td></tr><tr><td><strong>算术右移</strong></td><td>左端补最高有效位的值</td></tr></tbody></table><p>位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。</p><h2 id=整数表示><a href=#%e6%95%b4%e6%95%b0%e8%a1%a8%e7%a4%ba>整数表示</a></h2><p>用位来编码整数有两种形式：一种只能表示非负数，而另一种能够表示负数、零和整数。</p><p>下图的数学术语，用于精确定义和描述计算机如何编码和操作整数：
<a data-fancybox=gallery href=2-8.png><img class=mx-auto alt src=2-8.png></a></p><p>C和C++都支持有符号（默认）和无符号数。Java只支持有符号数。</p><p><a data-fancybox=gallery href=64%e4%bd%8dC%e6%95%b4%e6%95%b0%e5%8f%96%e5%80%bc%e8%8c%83%e5%9b%b4.png><img class=mx-auto alt src=64%e4%bd%8dC%e6%95%b4%e6%95%b0%e5%8f%96%e5%80%bc%e8%8c%83%e5%9b%b4.png></a></p><h3 id=无符号数的编码><a href=#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0%e7%9a%84%e7%bc%96%e7%a0%81>无符号数的编码</a></h3><p>假设有一个整数数据类型有 $w$ 位。</p><p>可以使用位向量 $\vec{x}$，表示整个向量；或者使用 $[x_ {w-1},x_ {w-2}, &mldr;, x_ 0]$ 表示向量中的每一位。</p><p>把 $\vec{x}$ 看做一个二进制表示的数，就获得了 $\vec{x}$ 的无符号表示。在这个编码中， 每个位 $x_ i$ 都取值 $0$ 或 $1$ 。</p><h4 id=无符号数编码的定义><a href=#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0%e7%bc%96%e7%a0%81%e7%9a%84%e5%ae%9a%e4%b9%89>无符号数编码的定义</a></h4><p><strong>$B2U_ w(\vec{x})$ 函数是用于将 $\vec{x}$ 表示的二进制无符号数转换为十进制无符号数。</strong></p><p>对向量 $\vec{x}=[x_ {w-1}, x_ {w-2}, &mldr;, x_ 0]$:
$$
B2U_w(\vec{x}) \equiv \sum_{i=0}^{w-1}x_i2^i \tag{1}
$$</p><p>$$UMax_ w \equiv \sum_ {i=0}^{w-1}2^i=2^w-1$$</p><p>$$UMax_ 4=B2U_ 4([1111])=2^4-1=15$$</p><p>无符号数编码的唯一性： 函数$B2U_w$是一个双射。</p><h3 id=补码编码><a href=#%e8%a1%a5%e7%a0%81%e7%bc%96%e7%a0%81>补码编码</a></h3><p>最常见的有符号数的计算机表示方式就是<strong>补码</strong>（two&rsquo;s-complement）。</p><p>补码会将字的最高有效位解释为<strong>负权</strong>（negative weight）。</p><h4 id=补码编码的定义><a href=#%e8%a1%a5%e7%a0%81%e7%bc%96%e7%a0%81%e7%9a%84%e5%ae%9a%e4%b9%89>补码编码的定义</a></h4><p>对向量 $\vec{x}=[x_ {w-1}, x_ {w-2}, &mldr;, x_ 0]$ :</p><p>$$
B2T_ w(\vec{x})=-x_ {w-1}2^{w-1} + \sum_ {i=0}^{w-2}x_ i2^i \tag{2}
$$</p><p>最高有效位 $x_ {w-1}$ 也称为<strong>符号位</strong>，它的权重为 $-2^{w-1}$ ，是无符号表示中权重的负数。符号位被设置为 $1$ 时，表示值为负，而当设置为 $0$ 时，值为非负。</p><p>$$
\begin{align}
B2T_ 4([0001]) &= -0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0 = 1 \\
B2T_ 4([0101]) &= -0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 5 \\
B2T_ 4([1011]) &= -1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = -5 \\
B2T_ 4([1111]) &= -1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = -7
\end{align}
$$</p><p>补码编码的唯一性： 函数$B2T_w$是一个双射。</p><p>下图是针对不同字长，几个重要数字的位模式和数值。
<a data-fancybox=gallery href=2-14.png><img class=mx-auto alt src=2-14.png>
</a>补码的范围是不对称的： $|TMin|=|TMax|+1$，$TMin$ 没有与之对应的整数。之所以有这样的不对称性，是因为一半的位模式（符号位设置为1的数）表示负数，而另一半（符号位为0的数）表示非负数。</p><p>因为 $0$ 是非负数，也就意味着能表示的正数比负数少一个。</p><p><strong>最大的无符号数刚好比补码的最大值的两倍大 $1$ ：$UMax_w=2TMax_w+1$</strong>。 补码表示中所有表示负数的位模式在无符号数中都变成了正数。</p><p>术语补码来源于这样一个情况，<strong>对于非负数 $x$ ，我们用$2^w-x$来计算 $-x$ 的 $w$ 位表示。</strong></p><h3 id=无符号和补码的转换><a href=#%e6%97%a0%e7%ac%a6%e5%8f%b7%e5%92%8c%e8%a1%a5%e7%a0%81%e7%9a%84%e8%bd%ac%e6%8d%a2>无符号和补码的转换</a></h3><p><strong>C语言允许在各种不同的数字数据类型之间做强制类型转换，但是强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span> <span class=kt>int</span> <span class=n>v</span><span class=o>=-</span><span class=mi>12345</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>uv</span><span class=o>=</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>short</span><span class=p>)</span><span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;v=%d,uv=%u</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>v</span><span class=p>,</span><span class=n>uv</span><span class=p>);</span><span class=c1>//v=-12345,uv=53191
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以发现-12345和53191的二进制位模式相同，因为 $2^{16}-12345=53191$ 。</p><p>大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：<strong>数值可能会变，但是位模式不变。</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>$U2B_ w$</td><td>将数值映射为无符号数的位表示，给定 $0\leq{x}\leq{UMax_ w}$ 范围内一个整数 $x$，函数 $U2B_ w(x)$ 会给出 $x$ 的唯一的 $w$ 位无符号表示。</td></tr><tr><td>$T2B_ w$</td><td>将数值映射为补码的位表示，当 $x$ 满足 $TMin_ w \leq{x}\leq{TMax_ w}$，函数 $T2B_ w(x)$ 会给出 $x$ 的唯一的 $w$ 位补码表示。</td></tr><tr><td>$T2U_ w$</td><td>$T2U_ w(x) \equiv B2U_ w(T2B_ w(x))$ ，输入是 $TMin_ w$ ~ $TMax_ w$ 的数，输出是一个 $0$~$UMax_ w$ 的值，输入和输出的数有相同的位模式。</td></tr><tr><td>$U2T_ w$</td><td>$U2T_ w(x) \equiv B2T_ w(U2B_ w(x))$ ，输入是 $0$ ~ $UMax_ w$ 的数，输出是 $TMin_ w$ ~ $TMax_ w$ 的值，输入和输出的数具有相同的位模式。</td></tr></tbody></table><p><strong>$-x$的补码的位模式和$2^w-x$的无符号数的位模式相同</strong>。因此计算一个负数补码的位模式，只要计算对应的无符号数的位模式即可。</p><h4 id=补码转换为无符号数><a href=#%e8%a1%a5%e7%a0%81%e8%bd%ac%e6%8d%a2%e4%b8%ba%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0>补码转换为无符号数</a></h4><p>对满足 $TMin_w \leq {x} \leq {TMax_w}$ 的 $x$ 有：
$$
T2Uw(x)=\begin{cases}
x+2^w &, x&lt;0 \\
x &, x\geq{0} \tag{3}
\end{cases}
$$</p><p>推导如下：</p><ol><li><p>由公式（1）和公式（2）可以得出
$$
\begin{align}
B2U_ w(\vec{x}) - B2T_ w(\vec{x}) &= \sum_ {i=0}^{w-1}x_ {i}2^i - (-x_ {w-1}2^{w-1} + \sum_ {i=0}^{w-2}x_ {i}2^{i}) \\
&= x_ {w-1}2^{w-1} + x_ {w-1}2^{w-1} \\
&= x_ {w-1}2^w \\
B2U_ w(\vec{x}) &= x_{w-1}2^w + B2T_ w(\vec{x})
\end{align}
$$</p></li><li><p>令 $\vec{x} = T2B_ w(x)$ 则有
$$
\begin{align}
B2U_ w(\vec{x}) &= B2U_ w(T2B_ w(x)) \\
&= T2U_ w(x) \\
&= x_ {w-1}2^w + B2T_ w(T2B_ w(x)) \\
&= x_ {w-1}2^w + x
\end{align}
$$</p></li><li><p>得出结论如下
$$
T2U_ w(x) = x_ {w-1}2^w + x \tag{4}
$$</p></li><li><p>当 $x \geq 0$ 时， $x_ {w-1} = 0$ ，则 $T2U_ w(x) = x$ ；当 $x &lt; 0$ 时，$x_ {w-1} = 1$， 则 $T2U_ w(x) = 2^w + x$， 符合公式 $(3)$ 。</p></li></ol><h4 id=无符号数转换为补码><a href=#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0%e8%bd%ac%e6%8d%a2%e4%b8%ba%e8%a1%a5%e7%a0%81>无符号数转换为补码</a></h4><p>对满足 $0\leq{u}\leq {UMax_ w}$ 的 $u$ 有：
$$
U2T_ w(u)=\begin{cases}
u &, u\leq{TMax_w} \\
u-2^w &, u>TMax_w \tag{5}
\end{cases}
$$</p><p>推导如下：</p><ol><li><p>由公式（1）和公式（2）可以得出
$$
\begin{align}
B2U_ w(\vec{u}) - B2T_ w(\vec{u}) &= \sum_ {i=0}^{w-1}u_ {i}2^i - (-u_ {w-1}2^{w-1} + \sum_ {i=0}^{w-2}u_ {i}2^{i}) \\
&= u_ {w-1}2^{w-1} + u_ {w-1}2^{w-1} \\
&= u_ {w-1}2^w \\
B2T_ w(\vec{u}) &= B2U_ w(\vec{u}) - u_{w-1}2^w
\end{align}
$$</p></li><li><p>令 $\vec{u} = U2B_ w(u)$ 则有
$$
\begin{align}
B2T_ w(\vec{u}) &= B2T_ w(U2B_ w(u)) \\
&= U2T_ w(u) \\
&= B2U_ w(U2B_ w(u)) - u_ {w-1}2^w \\
&= u - u_ {w-1}2^w
\end{align}
$$</p></li><li><p>得出结论如下
$$
U2T_ w(u) = u - u_ {w-1}2^w \tag{6}
$$</p></li><li><p>当 $u > TMax_ w$ 时， $u_ {w-1} = 1$ ，则 $U2T_ w(u) = u - 2^w$ ；当 $u \leq TMax_ w$ 时，$u_ {w-1} = 0$， 则 $U2T_ w(u) = u$， 符合公式 $(4)$ 。</p></li></ol><p>映射区间如图所示：
<a data-fancybox=gallery href=2-18.png><img class=mx-auto alt src=2-18.png></a></p><h3 id=扩展数><a href=#%e6%89%a9%e5%b1%95%e6%95%b0>扩展数</a></h3><h4 id=无符号数的零扩展><a href=#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0%e7%9a%84%e9%9b%b6%e6%89%a9%e5%b1%95>无符号数的零扩展</a></h4><p>将无符号数转换为更大的数据类型，只需要在位表示的开头添加 $0$， 称为<strong>零扩展</strong>。</p><p>数学描述如下：</p><p><strong>定义宽度为 $w$ 的位向量 $\vec{u}=[u_ {w-1}, u_ {w-2}, &mldr;, u_ 0]$ 和宽度为 $w&rsquo;$ 的位向量 $\vec{u&rsquo;}=[0, &mldr;, 0, u_ {w-1}, u_ {w-2}, &mldr;, u_ {0}]$，其中 $w&rsquo;>w$ ，则 $B2U_ w(\vec{u})=B2U_ w(\vec{u&rsquo;})$。</strong></p><h4 id=补码的符号扩展><a href=#%e8%a1%a5%e7%a0%81%e7%9a%84%e7%ac%a6%e5%8f%b7%e6%89%a9%e5%b1%95>补码的符号扩展</a></h4><p>将补码数字转换为更大的数据类型，需要执行<strong>符号扩展</strong>，即在位表示中添加最高有效位的值。</p><p>数学描述如下：</p><p><strong>定义宽度为 $w$ 的位向量 $\vec{x} = [x_ {w-1}, x_ {w-2}, &mldr;, x_ 0]$ 和宽度为 $w&rsquo;$ 的位向量 $\vec{x&rsquo;}=[\underbrace{x_ {w-1}, &mldr;, x_ {w-1}}, x_ {w-1}, x_ {w-2}, &mldr;, x_ 0]$，其中 $w&rsquo;>w$ ，则$B2T_ w(\vec{x}) = B2T_ {w&rsquo;}(\vec{x&rsquo;})$。</strong></p><p>推导：</p><ol><li>令 $w&rsquo; = w + k$，则待证明公式如下：</li></ol><p>$$B2T_ {w+k}([\underbrace{x_ {w-1}, &mldr;, x_ {w-1}}_ {k}, x_ {w-1}, x_ {w-2}, &mldr;, x_ 0]) = B2T_ w([x_ {w-1},x_ {w-2}, &mldr;, x_ 0])$$</p><ol start=2><li><p>当 $k$ 取任意值时，证明如下：
$$
\begin{align}
B2T_ {w+k}([\underbrace{x_ {w-1}, &mldr;, x_ {w-1}}_ {k}, x_ {w-1}, x_ {w-2}, &mldr;, x_ 0]) &= -x_ {w-1}2^{w+k-1} + \sum_ {i=0}^{w+k-2}x_ {i}2^{i}\\
&= -x_ {w-1}2^{w+k-1} + \sum_ {i=w-1}^{w+k-2}x_ {i}2^{i} + \sum_ {i=0}^{w-2}x_ {i}2^{i} \\
&= -x_ {w-1}2^{w+k-1} + x_ {w-1}\sum_ {i=w-1}^{w+k-2}2^{i} + \sum_ {i=0}^{w-2}x_ {i}2^{i} \\
&= -x_ {w-1}(2^{w+k-1} - \sum_ {i=w-1}^{w+k-2}2^{i}) + \sum_ {i=0}^{w-2}x_ {i}2^{i} \\
&= -x_ {w-1}(2^{w+k-1} - 2^{w+k+1} + 2^{w-1}) + \sum_ {i=0}^{w-2}x_ {i}2^{i} \\
&= -x_ {w-1}2^{w-1} + \sum_ {i=0}^{w-2}x_ {i}2^{i} \\
&= B2T_ {w}([x_ {w-1}, x_ {w-2}, &mldr;, x_0)])
\end{align}
$$</p></li><li><p>上式的证明过程中使用等比数列的求和公式，如下：$S_ n = a_ {1} \frac{1 - q^n}{1 - q}$ 。</p></li><li><p>补码符号扩展的关键属性是 $2^{w} - 2^{w-1} = 2^{w-1}$。因此加上一个权值为 $-2^{w}$ 的位，和将一个权值为 $-2^{w-1}$ 的位转换为一个权值为 $2^{w-1}$ 的位，这两项运算的综合效果就会保持原始的数值。</p></li></ol><h3 id=截断数><a href=#%e6%88%aa%e6%96%ad%e6%95%b0>截断数</a></h3><p>将一个 $w$ 位的数 $\vec{x} = [x_ {w-1}, x_ {w-2}, &mldr;, x_ {0}]$ 截断为一个 $k$ 位数字时，会丢弃高 $w - k$ 位，得到一个位向量 $\vec{x&rsquo;} = [x_ {k-1}, x_ {k-2}, &mldr;, x_ 0]$。</p><p>截断一个数字可能会改变其值，这是<strong>溢出</strong>的一种形式。</p><h4 id=截断无符号数><a href=#%e6%88%aa%e6%96%ad%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0>截断无符号数</a></h4><p>令 $\vec{x}$ 等于位向量 $[x_ {w-1}, x_ {w-2}, &mldr;, x_ {0}]$，而 $\vec{x&rsquo;}$ 是将其截断为 $k$ 位的结果：$\vec{x&rsquo;} = [x_ {k-1}, x_ {k-2}, &mldr;, x_ {0}]$。</p><p>令$x=B2U_w(\vec{x})$，$x&rsquo;=B2U_k(\vec{x&rsquo;})$，则$x&rsquo;=x \mod 2^{k}$。</p><p><strong>所有被截去的位其权重形式都为 $2^{i}$ ，其中 $i \geq k$ 。</strong> 因此，每一个权重在取模操作下结果都为 $0$ 。</p><p>推导：
$$
\begin {aligned}
B2U_w([x_{w-1},x_{w-2},&mldr;,x_{0}]) \mod 2^{k} &= [\sum_{i=0}^{w-1}x_{i}2^{i}] \mod 2^{k}\\
&= ([\sum_{i=k}^{w-1}x_{i}2^{i}] \mod 2^{k} + [\sum_{i=0}^{k-1}x_{i}2^{i}] \mod 2^{k}) \mod 2^{k}\\
&=(0+[\sum_{i=0}^{k-1}x_{i}2^{i}] \mod 2^{k}) \mod 2^{k}\\
&=[\sum_{i=0}^{k-1}x_{i}2^{i}] \mod 2^{k}\\
&=B2U_k([x_{k-1},x_{k-2},&mldr;,x_{0}])
\end {aligned}
$$</p><p>对于任何 $i \geq {k}$， $2^{i} \mod 2^{k} = 0$。</p><h4 id=截断补码数值><a href=#%e6%88%aa%e6%96%ad%e8%a1%a5%e7%a0%81%e6%95%b0%e5%80%bc>截断补码数值</a></h4><p>补码截断也具有相似的属性，只不过要将截断后的最高位转换为符号位。</p><p>令 $\vec{x}$ 等于位向量 $[x_ {w-1}, x_ {w-2}, &mldr;, x_ {0}]$，而 $\vec{x&rsquo;}$ 是将其截断为 $k$ 位的结果：$\vec{x&rsquo;} = [x_ {k-1}, x_ {k-2}, &mldr;, x_ {0}]$。</p><p>令 $x=B2U_w(\vec{x})$，$x&rsquo; = B2T_ k(\vec{x&rsquo;})$，则 $x&rsquo; = U2T_ k(x \mod 2^k)$ 。</p><p><strong>计算补码截断时，先将补码的位模式转为无符号数，再使用无符号数截断方式，最后再转换会补码。</strong></p><p>$$
B2T_ k[x_ {k-1}, x_ {k-2}, &mldr;, x_ {0}] = U2T_ k(B2U_ w([x_ {w-1}, x_ {w-2}, &mldr;, x_ {0}]) \mod 2^k)
$$</p><h2 id=整数运算><a href=#%e6%95%b4%e6%95%b0%e8%bf%90%e7%ae%97>整数运算</a></h2><h3 id=无符号数加法><a href=#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0%e5%8a%a0%e6%b3%95>无符号数加法</a></h3><p>两个非负整数 $x$ 和 $y$，满足 $0 \leq x$，$y &lt; 2^w$。</p><p>每个数都可以表示为 $w$ 位的无符号数字，则其和的可能范围为 $0 \leq x + y \leq 2^{w+1} -2$，表示这个和可能需要 $w+1$ 位。</p><p><strong>运算$+_ {w}^{u}$</strong> ：对于参数 $0 \leq x, y &lt; 2^w$，该操作是把整数和 $x + y$ 截断为 $w$ 的结果，再把这个结果看做是一个无符号数。</p><p><strong>数学描述如下：</strong></p><p>对满足 $0 \leq x, y &lt; 2^{w}$ 的 $x$ 和 $y$ 有：
$$
x +_{w}^{u} y= \begin {cases}
x+y &, x+y &lt; 2^{w} \\
x+y-2^{w} &, 2^{w} \leq x+y &lt; 2^{w+1}
\end {cases}
$$</p><ol><li>如果 $x+y&lt;2^{w}$ 的和的 $w+1$ 位的位表示中的最高位为 $0$，因此丢弃它不会改变这个数的值。</li><li>如果 $2^{w} \leq x+y &lt;2^{w+1}$ 的和的$w+1$位表示中的最高位会等与 $1$，因此丢弃它就相当于从和中减去了 $2^{w}$。</li></ol><h4 id=检测无符号数加法中的溢出><a href=#%e6%a3%80%e6%b5%8b%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0%e5%8a%a0%e6%b3%95%e4%b8%ad%e7%9a%84%e6%ba%a2%e5%87%ba>检测无符号数加法中的溢出</a></h4><p>对于 $0 \leq x, y \leq UMax_w$ 中的 $x$ 和 $y$，令 $s \equiv x +_ {w}^{u} y$，则对计算$s$，当且仅当 $s &lt; x$时，发生了溢出。</p><p>推导如下：</p><ol><li>由于是无符号加法，所以 $s = x + y \geq x$。如果 $s$ 没有溢出，则可以肯定 $s \geq x$。</li><li>如果 $s$ 确实溢出，则有 $s = x + y - 2^w$。又因为 $y &lt; 2^w$，因此 $s = x + (y - 2^w) &lt; x$。</li></ol><h3 id=无符号数求反><a href=#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0%e6%b1%82%e5%8f%8d>无符号数求反</a></h3><h4 id=阿贝尔群><a href=#%e9%98%bf%e8%b4%9d%e5%b0%94%e7%be%a4>阿贝尔群</a></h4><p>模数加法形成了一种数学结构，称为<strong>阿贝尔群</strong>。</p><p>它有一个单位元 $0$，并且每个元素有一个加法逆元。</p><p>考虑 $w$ 位的无符号数的集合，执行加法运算 $+_ w^u$。</p><p>对于每个值 $x$，必然有某个值 $-_ {w}^{u}x$ 满足 $-_ {w}^{u}x +_ {w}^{u} x=0$。</p><h4 id=无符号数求反-1><a href=#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0%e6%b1%82%e5%8f%8d-1>无符号数求反</a></h4><p>对于满足 $0 \leq x &lt; 2^w$ 的任意 $x$，其 $w$ 位的无符号逆元 $-_ {w}^{u}x$ 由下式给出：
$$
-_{w}^{u}x=\begin {cases}
x &, x=0\
2^w-x &, x>0
\end {cases}
$$</p><h3 id=补码加法><a href=#%e8%a1%a5%e7%a0%81%e5%8a%a0%e6%b3%95>补码加法</a></h3><p>对满足条件 $-2^{w-1} \leq x, y \leq 2^{w-1} - 1$ 的整数值 $x$ 和 $y$，其和的值范围为 $-2^{w} \leq x + y \leq 2^{w} - 2$ 。需要 $w+1$ 位，才能准确表示。</p><p><strong>运算$x+_ {w}^{t} y$：</strong> 整数和 $x + y$ 被截断为 $w$ 位的结果，并将这个结果看作补码数。</p><p><strong>数学描述如下</strong>：</p><p>对满足 $-2^{w-1}\leq x,y\leq 2^{w-1}-1$ 的整数 $x$ 和 $y$，有：
$$
x+_{w}^{t} y=\begin {cases}
x+y-2^{w} &, 2^{w-1}\leq x+y 正溢出\\
x+y &, -2^{w-1}\leq x+y &lt;2^{w-1} 正常 \\
x+y+2^w &, x+y&lt;-2^{w-1} 负溢出 （加上2^w才是抵消掉被截断的最高位）
\end {cases}
$$
该公式左侧的和 $x + y$ 的取值范围为 $-2^{w} \leq x + y \leq 2^{w} - 2$；右侧的是该和截断为 $w$ 位补码的结果。</p><h4 id=推导><a href=#%e6%8e%a8%e5%af%bc>推导</a></h4><ol><li>补码加法与无符号数加法有相同的位级表示，则运算 $+_ {w}^t$ 的计算方式为：将其参数转换为无符号数，执行无符号数加法，再将结果转换为补码。公式描述如下：
$$
x +_ {w}^{t} y \equiv U2T_ {w}(T2U_ {w}(x) + T2U_ {w}(y))
$$</li><li>由公式 $(4)$ 可以得出，
$$
\begin{align}
T2U_ {w}(x) &= x_ {w-1}2^{w} + x \\
T2U_ {w}(y) &= y_ {w-1}2^{w} + y
\end{align}
$$</li><li>由于 $+_ {w}^u$ 是模 $2^w$ 的加法，以及模数加法的属性，可以得出：
$$
\begin{align}
x +_ {w}^{t} y &= U2T_ {w}(T2U_ {w}(x) + T2U_ {w}(y)) \\
&= U2T_ {w}[(x_ {w-1}2^{w} + x + y_ {w-1}2^{w} + y) \mod 2^{w}] \\
&= U2T_ {w}[(x + y) \mod 2^{w}]
\end{align}
$$</li><li>定义 $z \equiv x + y$，$z&rsquo; \equiv z \mod 2^w$ ，$z&rsquo;&rsquo; \equiv U2T_ {w}(z&rsquo;)$ ，结果分析如下：<ol><li>当 $-2^w \leq z &lt; -2^{w-1}$， 有 $z&rsquo; = z + 2^w$，且 $0 \leq z&rsquo; &lt; -2^{w-1} + 2^{w} = 2^{w-1}$ ，可得出 $ z&rsquo;&rsquo; = x + y + 2^w$。此时 $z$ 最高位为 $1$，次高位为 $0$，截断最高位相当于减去 $2^w$，负溢出。</li><li>当 $-2^{w-1} \leq z &lt;0$，有 $z&rsquo; = z + 2^w$，且 $-2^{w-1} + 2^{w} = 2^{w-1} \leq z&rsquo; &lt; 2^w$，由公式 $(5)$ 可得出 $z&rsquo;&rsquo; = x + y$ 。</li><li>当 $0 \leq z &lt; 2^{w-1}$，有 $z&rsquo; = z$，且 $0 \leq z&rsquo; &lt; 2^{w-1}$，可得出 $z&rsquo;&rsquo; = z$。</li><li>当 $2^{w-1} \leq z &lt; 2^w$ 有 $z&rsquo; = z$，且 $2^{w-1} \leq z&rsquo; &lt; 2^{w}$，由公式 $(5)$ 可得出 $z&rsquo;&rsquo; = z&rsquo; - 2^{w} = x + y - 2^{w}$。</li></ol></li></ol><p><strong>补码数将 $w+1$位 截断为 $w$ 位。先将二进制位模式转换为无符号数然后取模运算再转换为补码。</strong></p><h3 id=补码的非><a href=#%e8%a1%a5%e7%a0%81%e7%9a%84%e9%9d%9e>补码的非</a></h3><p>对 $TMin_ w \leq x \leq TMax_ w$ 的 $x$，其补码的非 $-_ {w}^{t}x$ 由下式给出：
$$
-_{w}^{t}x=\begin {cases}
TMin_w &, x=TMin_w\\
-x &, x>TMin_w
\end {cases}
$$</p><p>$TMin_w+TMin_w=-2^{w-1}+(-2^{w-1})=-2^{w}$，这将导致负溢出，因此$TMin_w+_{w}^{t}TMin_w=-2^{w}+2^{w}=0$。</p><h3 id=无符号数乘法><a href=#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0%e4%b9%98%e6%b3%95>无符号数乘法</a></h3><p>范围在$0\leq x,y\leq 2^{w}-1$内的整数$x$和$y$可以被表示为$w$位的无符号数，但是它们的乘积$x*y$的取值范围为$0$到$2^{2w}-2^{w+1}+1$之间。 这可能需要$2w$来表示。不过，C语言中的无符号乘法被定义为产生$w$位的值，就是$2w$位的整数乘积的低$w$位来表示的值。我们将这个值表示为$x *_{w}^{u} y$。</p><p>对满足$o \leq x,y \leq UMax_w$的 $x$ 和 $y$ 有：
$$ x * _ {w}^{u} y = (x * y) \mod 2^{w} $$</p><h3 id=补码乘法><a href=#%e8%a1%a5%e7%a0%81%e4%b9%98%e6%b3%95>补码乘法</a></h3><p>范围在$-2^{w-1}\leq x,y \leq 2^{w-1}-1$内的整数$x$和$y$可以被表示为$w$位的补码数字，但是它们的乘积$x * y$ 的取值范围为 $-2^{w-1} * (2^{w-1}-1) = -2^{2w-2} + 2^{w-1}$ 到 $(-2^{w-1}) * (-2^{w-1}) = 2^{2w-2}$ 之间。要想用补码来表示这个乘积，可能需要 $2w$ 位。</p><p>然而C语言中的有符号乘法是通过将$2w$位的乘积截断为$w$来实现的。我们将这个数值表示为$x * _{w}^{t} y$。将一个补码数截断为 $w$ 位相当于先计算该值模 $2^w$，再把无符号数转换为补码。</p><p>数学描述如下：</p><p>对满足 $TMin_ w \leq x,y \leq TMax_ w$ 的 $x$ 和 $y$ 有：
$$x * _ {w}^{t} y = U2Tw[(x * y) \mod 2^{w}]$$</p><h4 id=乘以2的幂><a href=#%e4%b9%98%e4%bb%a52%e7%9a%84%e5%b9%82>乘以2的幂</a></h4><p>设$x$为位模式$[x_{w-1},x_{w-2},&mldr;,x_0]$表示的无符号整数。那么，对于任何$k\geq 0$，我们都认为$[x_{w-1},x_{w-2},&mldr;,x_0,\underbrace{0,&mldr;,0}_{k}]$给出了$x2^{k}$的$w+k$位的无符号表示，这里右边增加了$k$个0。</p><p>推导：
$$
\begin{align}
B2U_ {w+k}([x_ {w-1}, x_ {w-2}, &mldr;, x_ {0}, \underbrace{0, &mldr;, 0}_ {k}]) &= \sum_{i=0}^{w-1}x^i2^{i+k}\\
&= [\sum_{i=0}^{w-1}x_i2^i]*2^{k}\\
&= x2^{k}
\end{align}
$$
C变量 $x$ 和 $k$ 有无符号数值 $x$ 和 $k$，且 $0 \leq k &lt; w$，则C表达式<code>x&lt;&lt;k</code>产生数值$x * _ w^u2^k$。</p><h3 id=除2的幂><a href=#%e9%99%a42%e7%9a%84%e5%b9%82>除2的幂</a></h3><p><strong>在大多数机器上，整数除法要比整数乘法更慢&ndash;需要30个或更多的时钟周期。</strong></p><p>除以2的幂也可以用移位来实现，只不过用的是右移，而不是左移。</p><p>无符号和补码数分别使用<strong>逻辑移位</strong>和<strong>算术移位</strong>来达到目的。</p><p>对于任何实数 $a$，都有 $\lfloor a \rfloor \leq a &lt; \lfloor a \rfloor + 1$ 和 $\lceil a \rceil - 1 &lt; a \leq \lceil a \rceil$。</p><p><strong>整数除法总是舍入到零。</strong> 对于 $x \geq 0$ 和 $y > 0$，结果会是 $\lfloor \frac{x}{y} \rfloor$，而对于 $x &lt; 0$ 和 $y > 0$，结果会是 $\lceil \frac{x}{y} \rceil$。</p><h4 id=无符号数除法><a href=#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0%e9%99%a4%e6%b3%95>无符号数除法</a></h4><p>对无符号数运算使用移位是非常简单的，部分原因是由于无符号数的右移一定是逻辑右移。</p><p><strong>C变量 $x$ 和 $k$ 有无符号数值 $x$ 和 $k$， 且 $0 \leq k &lt; w$，则C表达式 $x &#187; k$ 产生数值 $\lfloor \frac{x}{2^k} \rfloor$。</strong></p><p>推导如下：</p><ol><li><p>设 $x$ 为位模式 $[x_ {w-1}, x_ {w-2}, &mldr;, x_ {0}]$ 表示的无符号整数，而 $k$ 的取值范围为 $0 \leq k &lt; w$ 。</p></li><li><p>设 $x&rsquo;$ 为 $w - k$ 位位表示 $[x_ {w-1}, x_ {w-2}, &mldr;, x_ {k}]$ 的无符号数，而 $x&rsquo;&rsquo;$ 为 $k$ 位位表示 $[x_ {k-1}, &mldr;, x_ {0}]$ 的无符号数。
$$
\begin{align}
x &= \sum_ {i=0}^{w-1}x_ {i}2^{i} \\
x&rsquo; &= \sum_ {i=k}^{w-1}x_ {i}2^{i-k} \\
2^{k}x&rsquo; &= 2^{k}\sum_ {i=k}^{w-1}x_ {i}2^{i-k}\\
&= \sum_ {i=k}^{w-1}x_ {i}2^{i} \\
x&rsquo;&rsquo; &= \sum_ {i=0}^{k}x_ {i}2^{i} \\
x &= 2^{k}x&rsquo; + x&rsquo;'
\end{align}
$$</p></li><li><p>由于 $0 \leq x&rsquo;&rsquo; &lt; 2^k$，因此
$$
\begin{align}
\frac{x}{2^k} &= x&rsquo; + \frac{x&rsquo;&rsquo;}{2^k} \\
\lfloor \frac{x&rsquo;&rsquo;}{2^k} \rfloor &= 0 \\
\lfloor \frac{x}{2^k} \rfloor &= x'
\end{align}
$$</p></li></ol><p>对位向量 $[x_ {w-1}, x_ {w-2}, &mldr;, x_ {0}]$ 逻辑右移 $k$ 位得到位向量 $[0, &mldr;, 0, x_ {w-1}, x_ {w-2}, &mldr;, x_ k]$ 。这个位向量有数值$x&rsquo;$，我们可以看到该值可以通过计算<code>x>>k</code>得到。</p><h4 id=补码除法><a href=#%e8%a1%a5%e7%a0%81%e9%99%a4%e6%b3%95>补码除法</a></h4><p>为了保证负数仍然为负，移位执行的是<strong>算术右移</strong>。</p><p><strong>C变量 $x$ 和 $k$ 分别由补码值 $x$ 和无符号数值 $k$，且 $0 \leq k &lt; w$，则当执行算术移位时，C表达式 <code>x>>k</code> 产生数值 $\lfloor x/2^{k} \rfloor$</strong>。</p><p>推导：</p><ol><li>当 $x \geq 0$ 时，变量 $x$ 的最高有效位为 $0$，移位效果和逻辑右移是一样的。因此，对于非负数来说，算术右移 $k$ 位与除以 $2^k$ 是一样的。</li><li><strong>除以2的幂的补码除法</strong>，向下舍入:<ol><li>设$x$为位模式$[x_{w-1},x_{w-2},&mldr;,x_{0}]$表示的补码整数，而$k$的取值范围为$0\leq k&lt;w$。设$x&rsquo;$为$w-k$位$[x_{w-1},x_{w-2},&mldr;,x_{k}]$表示的补码数，而$x&rsquo;&rsquo;$为低$k$位$[x_{k-1},&mldr;,x_{0}]$表示的无符号数。通过与对无符号数类似的分析，我们有$x=2^{k}x&rsquo;+x&rsquo;&rsquo;$，而$0\leq x&rsquo;&rsquo;&lt;2^{k}$，得到$x&rsquo;=\lfloor x/2^{k} \rfloor$</li><li>进一步，可以观察到，算术右移位向量$$[\underbrace{x_{w-1},&mldr;,x_{w-1}}<em>{k},x</em>{w-1},x_{w-2},&mldr;,x_k]$$。它刚好就是将$[x_{w-1},x_{w-2},&mldr;,x_k]$从$w-k$位符号扩展到$w$。因此这个移位后的位向量就是$\lfloor x/2^k \rfloor$的补码的表示。</li><li>如下所示例子：
<a data-fancybox=gallery href=2-29.png><img class=mx-auto alt src=2-29.png></a></li></ol></li><li>我们可以通过在移位之前“偏置”这个值，来修正负数向下设置的问题。</li><li><em>除以2的幂的补码除法</em>*，向上舍入<ol><li>C变量$x$和$k$分别有补码值$x$和无符号数值$k$，且$0\leq k &lt; w$，则当执行算术移位时，C表达式<code>(x+(1&lt;&lt;k)-1)>>k</code>产生数值$\lfloor x/2^k \rfloor$。</li><li>如下图所示：
<a data-fancybox=gallery href=2-30.png><img class=mx-auto alt src=2-30.png></a></li><li>我们可以看到低$k$位左边的位可能会加1，也可能不会加1。对于不需要舍入的情况，加上偏量只影响那些被移掉的位。对于需要舍入的情况，加上偏量导致较高的位加1，所以结果会向零舍入。</li><li>偏置技术利用如下属性： 对于整数$x$和$y(y>0)$，$\lceil x/y \rceil = \lfloor (x+y-1)/y \rfloor$</li><li>推导：<ol><li>查看$\lceil x/y \rceil = \lfloor (x+y-1)/y \rfloor$，假设$x=qy+r$，其中$0 \leq r &lt; y$，得到$(x+y-1)/y=q+(r+y-1)/y$，因此$\lfloor (x+y-1)/y \rfloor=q+\lfloor (r+y-1)/y \rfloor$。当$r=0$时，后面一项等于0，而当$r>0$时，等于1。也就是说，通过给$x$增加一个偏量$y-1$，然后在将除法向下舍入，当$y$整除$x$时，我们得到$q$，否则得到$q+1$。</li></ol></li></ol></li></ol><h2 id=浮点数><a href=#%e6%b5%ae%e7%82%b9%e6%95%b0>浮点数</a></h2><ul><li><p>浮点表示对形如$V=x*2^y$的有理数进行编码。</p></li><li><p><strong>十进制表示法</strong>，十进制表示法使用如下形式的表示：$$d_{m}d_{m-1}&mldr;d_{1}d_{0}.d_{-1}d_{-2}&mldr;d_-{n}$$，其中每个十进制数字$d_{i}$的取值范围是$0~9$。这个表达描述的数值$d$定义如下：
$$
d=\sum_{i=-n}^{m}10^i*d_{i}
$$</p></li><li><p>数字权的定义与十进制小数点符号“.”相关，这意味着小数点左边的数字的权时10的正幂，得到整数值，而小数点右边的数字的权是10的负幂，得到小数值。</p></li><li><p>考虑一个形如$b_{m}b_{m-1}&mldr;b{1}b_{0}.b_{-1}b_{-2}&mldr;b_{-n-1}b_{-n}$的表示法，其中每个二进制数字，或者称为位，$b_{i}$的取值范围是0和1。这种表示方法表示的数b定义如下：
$$
b=\sum_{i=-n}^{m}2^i*b_{i}
$$</p></li><li><p>符号“.”现在变为了二进制的点，点左边的位的权是2的正幂，点右边的权是2的负幂。</p></li><li><p>$101.11_2$表示数字$$1<em>2^2+1</em>2^0+1<em>2^{-1}+1</em>2^{-2}=5\frac{3}{4}$$</p></li><li><p><strong>IEEE浮点标准用$$V=(-1)^{s}<em>M</em>2^{E}$$的形式来表示一个数</strong>：</p><ul><li><strong>符号</strong> $s$决定这数是负数还是整数，而对于数值0的符号位解释作为特殊情况处理。</li><li><strong>尾数</strong> $M$是一个二进制小数，它的范围是$1$<del>$2-\epsilon$，或者$0$</del>$1-\epsilon$。</li><li><strong>阶数</strong> $E$的作用是对浮点数加权，这个权重是2的$E$次幂。</li></ul></li><li><p>将浮点数的位划分位三个字段，分别对这些值进行编码：</p><ul><li>一个单独的符号位$s$直接编码符号$s$。</li><li>$k$位的阶码字段$exp=e_{k-1}&mldr;e_{1}e_{0}$编码阶码$E$。</li><li>$n$位小数字段$frac=f_{n-1}&mldr;f_{1}f_{0}$编码尾数$M$，但是编码出来的值也依赖与阶码字段的值是否等于0</li></ul></li><li><p>在单精度浮点格式（C语言中的<code>float</code>）中，$s$，$exp$和$frac$字段分别为1位，8位和23位，得到一个32位的表示。在双精度浮点格式（C语言中的<code>double</code>）中，$s,exp$和$frac$字段分别为1位，11位和52位，得到一个64位的表示。如下图所示：{% asset_img 2-32.png %}</p></li><li><p>给定位表示，根据$exp$的值，被编码的值可以分为三种不同的情况。如下图所示：{% asset_img 2-33.png %}</p></li><li><p><strong>规格化的值</strong>：</p><ul><li>这是最普遍的情况。当$exp$的位模式既不全为0，也不全为1时，都属于这类情况。</li><li>在这种情况下，阶码字段被解释为以<strong>偏置</strong>形式表示的有符号整数。也就是说，阶码的值是$E=e-Bias$，其中$e$是无符号数，其位表示为$e_{k-1}&mldr;e_{1}e_{0}$，而$Bias$是一个等于$2^{k-1}-1$的偏置值。由此产生指数的取值范围，对于单精度是$-126$<del>$+127$，而对于双精度是$-1022$</del>$+1023$。</li><li>小数字段$frac$被解释为描述小数值$f$，其中$0\leq f&lt;1$，其二进制表示为$0.f_{n-1}&mldr;f_{1}f_{0}$，也就是二进制小数点在最高有效位的左边。尾数定义位$M=1+f$。这种方式也叫做隐含的以1开头的表示，因为我们可以把$M$看成一个二进制表达式为$1.f_{n-1}f_{n-2}&mldr;f_{0}$的数字。既然我们总是能够调整阶码$E$，使得尾数$M$在范围$1\leq M &lt;2$之中，那么这种表示方式是一种轻松获得一个额外精度位的技巧。</li></ul></li><li><p><strong>非规格化的值</strong>：</p><ul><li>当阶码域为全0时，所表示的数就是非规格化形式。在这种情况下，阶码值是$E=1-Bias$，而尾数的值是$M=f$，也就是小数字段的值，不包含隐含的开头的1。</li><li>非规格化数有两个用途。<ul><li>首先它们提供了一种表示数值0的方法，因为使用规格化数，我们必须总是使$M\geq 1$，因此我们不能表示0。实际上，$+0.0$的浮点表示的为模式为全0：符号位是0，阶码字段和小数域也全为0，这就得到$M=f=0$。当符号位为1，而其他域全为0时，我们得到值$-0.0$。根据IEEE的浮点格式，值$+0.0$和$-0.0$除了符号位不同外，其他位均相同。</li><li>非规格化数的另外一个功能就是表示那些非常接近于0.0的数。它们提供了一种属性，称为逐渐溢出，其中，可能的数值分布均匀地接近于0.0。</li></ul></li></ul></li><li><p><strong>特殊值</strong>：</p><ul><li>最后一类数值是指阶码全为1的时候出现的。当小数域全为0时，得到的值表示无穷，当$s=0$时得到$+\infty$，或者当$s=1$时是$-\infty$。当小数域为非零时，结果值表示“NaN”。一些运算的结果不能是实数或无穷，就会返回这样的NaN值（$\sqrt{-1}$）。</li></ul></li><li><p>下图给出了$k=4$的阶码位和$n=3$的小数位，偏置量是$2^{4-1}-1=7$。{% asset_img 2-35.png %}</p></li><li><p>因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算。</p></li><li><p>对于值$x$，我们一般想用一种系统的方法，能够找到“最接近的”匹配值$x&rsquo;$，它可以用期望的浮点形式表示出来。这就是<strong>舍入</strong>运算的任务。<strong>一个关键问题是在两个可能值的中间确定舍入方向</strong>。</p></li><li><p>如图所示显示了4中舍入方式：{% asset_img 2-37.png %}向偶数舍入，也被称为向最接近的值舍入，是默认的方式，试图找到一个最接近的匹配值。</p></li><li><p>为什么选用向偶数的舍入方式，是因为其他舍入方式在舍入一组数据时，得到的一组数的平均数会比这些数的实际值或大或小。</p></li><li><p>在我们不想舍入到整数时，也可以使用向偶数舍入。我们只是简单地考虑最低有效位是奇数还是偶数。</p></li><li><p>相似的，向偶数舍入法能够运用到二进制小数上。我们将最低有效位的值0认为是偶数，值1认为是奇数。一般来说，只有对形如$XX&mldr;X.YY&mldr;Y100&mldr;$的二进制位模式的数，这种舍入方式才有效，其中$X$和$Y$表示认为位值，最右边的$Y$是要被舍入的位值。<strong>只有这种位模式表示在两个可能的结果正中间的值</strong>。这是因为在$0$和$2^{-n}$之间的数值是$2^{-(n+1)}$。</p></li></ul></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://DBL2017.github.io/>生如夏花</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/>https://DBL2017.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/csapp/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br><div class="post-meta meta-tags"><ul class=clearfix><li><a href=/tags/csapp>CSAPP</a></li><li><a href=/tags/%E6%95%B4%E6%95%B0%E7%BC%96%E7%A0%81>整数编码</a></li><li><a href=/tags/%E6%B5%AE%E7%82%B9%E6%95%B0>浮点数</a></li><li><a href=/tags/ieee754>IEEE754</a></li></ul></div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=DBL2017/DBL2017.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></div></div></div><div class=content-right><div class=sidebar><section class=widget><form id=form-search action=https://DBL2017.github.io/search/ method=get accept-charset=utf-8 _lpchecked=1><input type=text name=q maxlength=20 placeholder=请输入查找关键字 required>
<button type=submit class=submit title=提交><svg t="1714448321870" class="icon" style="width:22px;height:22px" viewBox="0 0 1024 1024" p-id="1771" width="200" height="200"><path d="M781.9264 691.1232l236.928 236.9216-90.816 90.8032-236.9152-236.9216c-72.032 53.3568-161.184 84.9088-257.7088 84.9088C194.048 866.8352.0 672.7872.0 433.408.0 194.048 194.048.0 433.4144.0c239.3728.0 433.4208 194.048 433.4208 433.4144.0 96.5248-31.552 185.6768-84.9088 257.7088zm-348.512 47.2896c168.448.0 304.9984-136.5504 304.9984-304.9984s-136.5504-304.992-304.9984-304.992-304.992 136.5504-304.992 304.9856c0 168.448 136.5504 304.9984 304.992 304.9984z" fill="#4a4a4a" p-id="1772"/></svg></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bcontainer_of/ title=内核数据结构之container_of>内核数据结构之container_of</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/eve-ng/eve-ng%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ title=EVE-NG环境搭建>EVE-NG环境搭建</a></li><li><a href=https://DBL2017.github.io/post/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/ns-3/ns-3%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ title=NS-3环境搭建>NS-3环境搭建</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/%E5%87%BD%E6%95%B0/ title=函数>函数</a></li><li><a href=https://DBL2017.github.io/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/win10%E4%B8%8A%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/ title=WIN10上搭建samba服务器和Ubuntu虚拟机共享文件>WIN10上搭建samba服务器和Ubuntu虚拟机共享文件</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/ title=代码块和控制结构>代码块和控制结构</a></li><li><a href=https://DBL2017.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/lua%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/ title=Lua语言学习框架>Lua语言学习框架</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/iptables%E5%9B%9B%E8%A1%A8%E4%BA%94%E9%93%BE/ title=iptables四表五链>iptables四表五链</a></li><li><a href=https://DBL2017.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows%E4%B8%AD%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E8%B7%83%E7%82%B9%E6%95%B0%E5%92%8C%E6%B0%B8%E4%B9%85%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F/ title=Windows中通过配置跃点数和永久路由选择上网方式>Windows中通过配置跃点数和永久路由选择上网方式</a></li><li><a href=https://DBL2017.github.io/post/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/free%E5%91%BD%E4%BB%A4%E4%B8%ADbuff-cache%E5%8D%A0%E6%BB%A1%E5%86%85%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/ title=free命令中buff-cache占满内存的问题>free命令中buff-cache占满内存的问题</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=https://DBL2017.github.io/categories/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/>传输协议 (14)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/>工具使用 (21)</a></li><li><a href=https://DBL2017.github.io/categories/%E5%BC%80%E6%BA%90%E4%B8%89%E6%96%B9/>开源三方 (2)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统 (12)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8/>数字安全 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/>数据结构和算法 (5)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言 (9)</a></li><li><a href=https://DBL2017.github.io/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/>网络工程师 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记 (56)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/>问题排查 (4)</a></li><li><a href=https://DBL2017.github.io/categories/%E9%BB%98%E8%AE%A4/>默认 (2)</a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://mermaid.live/ title=Mermaid>Mermaid 编辑</a></li><li><a target=_blank href=https://excalidraw.com/ title=EXCALIDRAW>Excalidraw 绘图</a></li><li><a target=_blank href=https://git-scm.com/docs title=Git命令参考手册>Git命令参考手册</a></li><li><a target=_blank href=https://www.gnu.org/software/make/manual/make.html title="GNU make官方文档">GNU make官方文档</a></li><li><a target=_blank href=https://www.emojiall.com/ title=Emojiall表情网站>Emojiall表情网站</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://DBL2017.github.io/index.xml>文章 RSS</a></li></ul></section></div></div></div><div class=container-footer><footer id=footer><div>&copy; 2025 <a href=https://DBL2017.github.io/>生如夏花 By
生如夏花</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>广电总局</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered
by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://DBL2017.github.io/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">生如夏花</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"]}}</script><script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=/js/jquery.fancybox.min.min.9040007c0fd2a6cdc356495acb1c45ba3328b261b0d9f75d3da19bc47229189108aab8ca043864c1801d59431de72dec8d51ae50539f9ce1f5964bf5f38786c3.js integrity="sha512-kEAAfA/Sps3DVklayxxFujMosmGw2fddPaGbxHIpGJEIqrjKBDhkwYAdWUMd5y3sjVGuUFOfnOH1lkv184eGww==" crossorigin=anonymous></script><a id=rocket href=#top></a><script src=/js/totop.min.8c7573186baa30f09c49b5cf3176c3b105785324d961b3d5c2f7f099d14673160a29aeebdec25909d046aa14936cd43451e17664662d518550d5e8998dbec670.js integrity="sha512-jHVzGGuqMPCcSbXPMXbDsQV4UyTZYbPVwvfwmdFGcxYKKa7r3sJZCdBGqhSTbNQ0UeF2ZGYtUYVQ1eiZjb7GcA==" crossorigin=anonymous></script><script src=/js/clipboard.min.0765794be1674926c1a3810afcf039f605f367cb11cef727ad49e6aa70f9fca0a37d329d64c55822896869eb0960763e73e085ee7675cbc497e4d3256a6e6a67.js integrity="sha512-B2V5S+FnSSbBo4EK/PA59gXzZ8sRzvcnrUnmqnD5/KCjfTKdZMVYIoloaesJYHY+c+CF7nZ1y8SX5NMlam5qZw==" crossorigin=anonymous></script><script>var spy=new Gumshoe("#TableOfContents a",{nested:!0,nestedClass:"active"})</script><script>hljs.highlightAll()</script></div></div></body></html>